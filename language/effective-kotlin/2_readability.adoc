= 2장. 가독성 (Readability)

== Item 11. 가독성을 목표로 설계하라 (Design for readability)

[quote]
개발자가 코드를 작성하는 데는 1분 걸리지만, 이를 읽는 데는 10분이 걸린다

프로그래밍은 쓰기보다 읽기가 중요하다

가독성 = 코드를 읽고 얼마나 빠르게 이해할 수 있는지

=== 인식 부하 감소

숙련된 개발자만을 위한 코드는 좋은 코드가 아니다 +
-> 사용 빈도가 적은 관용구는 코드를 복잡하게 만든다

* 수정하기 쉽고
* 디버깅하기 더 간단하게

인지 부하를 줄이는 방향으로 코드를 작성하라 +
뇌가 프로그램의 작동 방식을 이해하는 과정을 더 짧게 만들기

=== 극단적이 되지 않기

지불할 만한 가치가 있는 비용은 유지 (너무 극단적으로 배제하지 말 것)

=== 컨벤션

표현력을 위한 규칙, 각각은 다음 장들에서 다룸

* 연산자는 의미에 맞게 사용
* 람다는 마지막 아규먼트로 사용한다 (여기서는 맞지 않음)
* 함수 이름과 내부 처리의 일치
* 이미 있는 것을 다시 만들지 않기

== Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용 (An operator’s meaning should be consistent with its function name)

연산자 오버로딩은 이름의 의미에 맞게 사용 -> 의미가 명확하지 않다면 사용하지 않는 것이 좋다

책에서 나온 factorial 연산을 이미 invert 연산자로 정의된 not() 으로 정의해선 안된다

=== 분명하지 않은 경우?

관례를 충족하는지 아닌지 확실하지 않을 때는 +
infix 를 활용한 확장 함수를 이용

top-level function 을 사용하는 것도 좋음 (file 에 정의)

=== 규칙을 무시해도 되는 경우

DSL 설계 시

== Item 13. Unit? 을 리턴하지 말라 (Avoid returning or operating on Unit?)

가독성, 파악이 쉽지 않다

Unit? 은 Boolean 으로 대체할 수 있다

== Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라 (Consider making types explicit)

`val data = getSomeData()` 와 같은 경우 명시해주는게 코드 파악이 더 쉬움

안전을 위해서도 지정하는 것이 좋음 (3, 4장과 이어서)

== Item 15. 리시버를 명시적으로 참조하라 (Consider referencing receivers explicitly)

더 자세하게 설몀하기 위한, 명시적으로 긴 코드 사용 (this 등)

=== 여러 개의 리시버

* 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내는게 좋다
** p87 코드보단, p89 코드

=== DSL 마커

* DSL 에서는 외부 함수를 사용하는게 위험한 경우가 있음
* `DslMarker`: 암묵적으로 외부 리시버를 사용하는 것을 막는 메타 어노테이션
* 가장 가까운 리시버만을 사용 or 명시적으로 외부 리시버를 사용하지 못하게 할 때 활용

== Item 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다 (Properties should represent a state, not a behavior)

* 프로퍼티는 사용자 정의 setter, getter 를 가질 수 있다
** java 필드처럼 정의한다면 backing field 가 있고 `field` 라는 식별자가 제공된다
** 읽기 전용에서는 field 가 만들어지지 않음
* var 로 이용하는건 derived property 라고 부름
* 필드가 필요 없다 -> 개념적으로 접근자를 나타낸다

프로퍼티로 알고리즘 동작을 나타내는 것은 좋지 않다

* 관습적으로 getter 에 계산량이 필요하다고 예상하지 않음
** 함수로 구현해야 한다
* 상태를 나타내거나 설정하기 위한 목적으로만 사용하는게 좋다
* 로직을 포함하지 않아야 한다

프로퍼티 = 상태 집합, 함수 = 행동

== Item 17. 이름 있는 아규먼트를 사용하라 (Consider naming arguments)

파라미터가 명확하지 않은 경우에, 직접 지정해서 명확하게 만들어주기 +
사용 & 읽는 측면 둘 다에서 중요

* 디폴트 값을 가지면 -> 설명을 위해 붙이는게 좋음
* 같은 타입이 있다면 -> 잘못 입력했을 때를 대비하여 붙이는게 좋음
* 함수 타입 파라미터 -> p101 예시
** 다른 언어의 라이브러리인 경우 별도 extension 을 만들어 지원할 수도 있다

== Item 18. 코딩 컨벤션을 지켜라 (Respect coding conventions)

컨벤션을 지켜야 +
어떤 프로젝트든 쉽게 이해, 다른 개발자도 쉽게 이해, 작동 방식 쉽게 추측, 코드 병합 및 이동이 쉬움

IntelliJ formatter, ktlint

static checker 를 활용하여 일관성을 유지해라