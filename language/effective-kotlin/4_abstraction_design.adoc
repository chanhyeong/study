= 4. 추상화 설계

== Item 29. 외부 API 를 wrap 해서 사용하라 (Consider wrapping external APIs)

API 를 신뢰할 수 없다면 불안정한 것, 그대로 사용하는 것은 위험 +
활용해야 한다면 API 를 로직과 직접 결합시키지 않는 것이 좋다

장단점을 모두 이해하고 wrap 할 API 를 결정해야 한다 (p182)

== Item 30. 요소의 가시성을 최소화하라 (Minimize elements’ visibility)

* 작은 인터페이스는 배우고 유지하기 쉽다
* 변경 시 기존 것을 숨기는 것보다 새로운 것을 노출하는게 쉽다
** 처음에는 작은 API 로 개발하도록 강제하는 것이 더 좋을 수 있다
* 가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있다
** 동시성을 처리할 때 중요

p186 가시성 한정자 (visibility modifier) - 클래스 멤버, 톱레벨 요소

모듈 (함께 컴파일되는 코틀린 소스) 과 패키지

API 를 상속할 때 오버라이드해서 가시성을 제한할 수 없다

== Item 31. 문서로 규약을 정의하라 (Define contracts with documentation)

함수와 클래스의 이름만으로 예측할 수 없는 세부 사항들을 설명

=== 규약

예측되는 행위

* 적절하게 정의되어 있다면
** 만든이: 어떻게 사용될지 걱정하지 않아도 됨
** 쓰는이: 내부 구현을 몰라도 되고, 의존한 다른 것을 만들 수 있다
* 설정하지 않는다면
** 만든이: 사용자의 행위 예측을 못하여 사용자의 구현을 망칠 수도
** 쓰는이: 할 수 있는/없는 것을 모르므로 세부 구현에 의존

=== 규약 정의하기

이름, 주석과 문서, 타입

=== KDoc 형식

KDoc 마크다운 형식으로 작성

==== 주석의 구조

. 요소에 대한 요약 설명
. 상세 설명
. 태그 - 추가적인 설명
** param, return, constructor, ... (p196)

링크를 걸 때는 대괄호, 링크에 대한 추가 설명은 대괄호를 두 번 연속

Dokka - 공식적인 문서 생성 도구, 온라인에 게시하고 외부 사용자에게 제공할 수 있는 문서 파일을 만들어 줌

=== 타입 시스템과 예측

클래스가 어떤 동작을 할 것이라 예측되면, 서브클래스도 이를 보장해야 한다 (리스코프 치환 원칙, Liskov substituion principle)

예시 코드에서는 인터페이스 정의만으로는 예상할 수 없는 세부 정보를 주석에 기입

=== 조금씩 달라지는 세부 사항

구현체마다 다른 세부 내용은 규약에 명시되어 있지 않으므로 괜찮다

== Item 32. 추상화 규약을 지켜라 (Respect abstraction contracts)

무언가를 할 수 있다는 것이 해도 괜찮다는 의미는 아니다

프로그램을 안정적으로 유지하고 싶다면 규약을 지켜라