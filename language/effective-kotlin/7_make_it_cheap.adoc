= 7. 비용 줄이기

== Item 45. 불필요한 객체 생성을 피하라 (Avoid unnecessary object creation)

=== 객체 생성 비용

wrap 하면 세 가지 비용 발생

* 많은 용량
* 접근에 추가적인 함수 호출
* 생성, 할당, 레퍼런스 비용

=== 캐시를 활용하는 팩토리 함수

팩토리 함수는 항상 같은 객체를 리턴하게 할 수 있다

객체 생성이 무겁거나, 동시에 여러 mutable 객체를 사용해야 하는 경우

memoization

메모리가 피룡할 때 가비지 컬렉터가 자동으로 메모리를 해제해주는 SoftReference 사용

=== 무거운 객체를 외부 스코프로 보내기

무거운 객체/연산을 외부로 추출하여 추가로 생성/계산하지 않도록 만든다

=== 지연 초기화

무거운 클래스를 사용할 때

첫 호출 시 무거운 객체 초기화로 느린 경우가 있을 수 있음 -> 상황에 맞게 사용해야 한다

=== 기본 자료형 사용하기

코드와 라이브러리의 성능이 굉장히 중요한 부분에, 최적화 기법으로 사용

== Item 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라 (Use the inline modifier for functions with parameters of functional types)

inline 의 역할 - '함수를 호출하는 부분' 을 '함수의 본문' 으로 대체 +
함수로 점프하는 과정을 없앰

=== 타입 아규먼트를 reified 로 사용

JVM 바이트 코드에는 제네릭이 존재하지 않음

함수 호출이 본문으로 대체 -> reified 지정하면 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체

=== 더 빠르게 동작

함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문

코틀린/JVM 에서는 JVM 익명 클래스 or 일반 클래스로 함수가 동작 -> 객체 wrap 으로 코드 속도가 느려짐

함수에서는 값을 캡처하여 객체로 래핑, 사용할 때마다 객체를 통해 작업이 이루어짐

함수가 객체로 컴파일, 지역 변수 래핑이 누적되면 속도가 느려진다

=== 비지역적 리턴을 사용할 수 없다

=== inline 의 비용

* 재귀적으로 동작할 수 없음
* 가시성 제한을 가진 요소를 사용할 수 없음
* 구현을 숨길 수 없음
* 코드의 크기가 커짐

=== crossinline 과 noinline

함수 타입 파라미터를 inline 으로 받고 싶지 않을 때

* crossinline: 인라인 함수를 받지만, 비지역적 리턴을 하는 함수를 받을 수 없음
* noinline: 인라인 함수를 받지 못하게

== Item 47. 인라인 클래스의 사용을 고려하라 (Consider using inline value classes)

다른 자료형을 래핑해서 새로운 자료형을 만들 때 많이 사용

* 측정 단위 표현
** 올바른 타입을 사용하도록 강제 (p323~333)
* 타입 오용 문제 방어
** 오버헤드 없이 안전을 위해 새로운 타입 도입

인터페이스를 구현하는 인라인 클래스는 의미가 없다

`typealias` -> 길고 반복적으로 자주 사용할 때 유용

== Item 48. 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라 (Eliminate obsolete object references)

객체에 대한 참조를 companion 으로 유지하면 메모리 해제를 할 수 없다

객체를 더 이상 사용하지 않을 때 null 로 설정해주면 된다 +
-> 많은 변수를 캡처할 수 있는 함수 타입, Any/제네릭 등 미지의 클래스 일 때는 더 중요하다

상태를 유지할 때는 메모리 관리를 염두해 두어야 한다

라이브러리를 구현할 때는 메모리와 성능이 더 중요하다 (가독성과 확장성보다)

SoftReference 를 활용하면, 메모리가 필요한 경우 가비지 컬렉터가 알아서 해제