= 1. 모듈화 관련 이슈들

모듈화는 복잡도를 관리하고 줄이기 위해 사용되는 기술 중 하나

모듈 시스템은 애플리케이션의 전박적인 구조 +
디자인, 컴파일, 패키징, 배포 등

== 모듈화는 무엇인가?

시스템을 상호 연결된 모듈로 분해하는 것 +
모듈 자체에 대한 설명, 다른 모듈과의 관계성을 설명하는 메타데이터, 모듈 코드로 구성된 식별 가능한 artifact

모듈은 관련 코드를 그룹핑. 3가지 핵심 사항

[discrete]
==== _강력한 캡슐화_

모듈은 다른 모듈로부터 내부 코드를 숨길 수 있어야 한다 +
(오픈할 코드, 내부 코드 구분) +
(커플링 방지)

캡슐화된 코드는 다른 코드에 영향을 주지 않고 자유롭게 수정

[discrete]
==== _잘 정의된 인터페이스_

캡슐화되지 않은 코드는 모듈의 public API 로 정의한다 +
변경하게되면 다른 모듈이 영향을 받을 수 있기 때문에 잘 정의되고 안정된 인터페이스를 다른 모듈에 공개해야 한다.

[discrete]
==== _명시적 의존성_

특정 기능 구현을 위해 다른 모듈을 사용하는 경우, 모듈을 정의하는 시점에 명시되어야 한다 +
명시적 의존성을 이용하여 모듈 그래프를 만들 수 있다 (애플리케이션의 구조 및 구성하는 모듈을 이해햐는데 도움) +
모듈 그래프를 통해 안정적으로 구성하기 위한 정보를 얻을 수 있음

대규모 애플리케이션이 모듈화 되어 있지 않을 때 - 스파케티 아키텍처, 하나의 대형 코드, big ball of mud

== Java 9 이전 버전 살펴보기

[quote]
동일 컴포넌트의 다른 패키지에서의 접근 허용, 외부 컴포넌트에서 접근은 막고 싶을 때는? +
-> 적절한 방법이 없다

명시적인 import 구문 -> 컴파일 시점에 적용 +
-> 코드를 JAR 로 패키징하면, 실제 코드가 실행되기 위하여 어떤 JAR 가 필요한지 알 수 없는 문제

[NOTE]
====

의존성 관리를 위한 도구: Maven 및 OSGi

. Maven
** JAR 간 의존성을 POM (Project Object Model) 파일에 정의 - 컴파일 시점에 발생하는 의존성 관리 문제 해결
** Maven Central 저장소 제공 - 모든 Java 라이브러리가 POM 과 함께 게시됨
*** Gradle, Ant: 동일 저장소 및 메타데이터를 이용
.OSGi
** 런타임에 적용
** import 된 패키지를 JAR 에 메타데이터로 나열 (bundle)
** 외부에 노출해야 하는 패키지를 명시적으로 정의

둘 다 JVM 이나 Java 언어 자체를 제어하지는 않음 +
Java 9 은 대체하기 위한 것은 아님

====

=== JAR 가 모듈로 사용될 수 있는가?

JAR 파일: 이름, 연관된 코드의 집합으로 구성되고 잘 정의된 public 인터페이스를 제공

JAR 에는 의존성에 대한 정보가 없다

.MyApplication 을 실행하려면? 올바른 클래스 패스를 직접 지정해야 한다
[source,bash]
----
java -classpath lib/guava-19.0.jar:\
                lib/hibernate-validator-5.3.1.jar:\
                lib/jboss-logging-3.3.0Final.jar:\
                lib/classmate-1.3.1.jar:\
                lib/validation-api-1.1.0.Final.jar \
        -jar MyApplication.jar
----

=== 클래스 패스 지옥

classpath: Java runtime 시 클래스를 찾기 위해 사용

p26 에서 JAR 또는 논리적 그룹화에 대한 개념이 들어가있지 않음 +
-> `-classpath` 옵션에 정의된 순서대로 나열 +
-> JVM 이 클래스를 로드하려고 할 때 classpath 를 순차적으로 체크하여 클래스가 발견되면 검색 중지, 로딩

classpath 에서 찾을 수 없으면? 런타임 오류 +
클래스는 lazy loading. 애플리케이션 시작 시점에 classpath 의 완전성을 확인할 수 없음

classpath 에 중복 클래스가 있는 경우 어려울 수 있다 +
동일한 라이브러리의 두 가지 버전이 설정된 경우 (ex. Guava 19, Guava 18) +
동일한 이름을 가진 두 개의 클래스는 하나의 클래스만 로딩된다

== Java 9 모듈

Java 9 모듈 시스템의 두 가지 목표

. JDK 자체를 모듈화
. 애플리케이션에서 사용할 수 있는 모듈 시스템

Java 9 에서는 모듈 간의 의존성을 표현하는 방법 제공 (코드보다 상위 레벨)

의존성 관련 정보를 컴파일 시점, 런타임에 사용할 수 있다면? +
-> 사용하지 않는 모듈에 의도치 않은 의존성이 생기는 것을 방지

Java 플랫폼 모듈 시스템의 이점들

[discrete]
==== _안정적인 구성_

코드를 컴파일, 실행 전에 주어진 모듈의 조합이 모든 의존성을 만족하는지 체크 +
런타임 에러를 줄일 수 있음

[discrete]
==== _강력한 캡슐화_

다른 모듈에 무엇을 노출할지 명시적으로 선택 +
내부 구현 코드에 대하여 의도하지 않은 의존성이 발생하는 것을 방지

[discrete]
==== _확장성 있는 개발_

명시적인 바운더리 설정 - 동시에 작업하면서 유지 보수 가능한 코드 생성

[discrete]
==== _보안_

JVM 의 가장 하위 레이어에서 이루어짐 +
리플렉션 접근 불가능, 런타임 공격 제한

[discrete]
==== _최적화_

어떤 모듈이 함께 동작하는지 알기 때문에 JVM 이 시작하는 동안 다른 코드를 고려할 필요가 없다 +
배포용 모듈을 최소한으로 구성할 수 있는 가능성을 연다 -> 전체 프로그램 최적화 가능