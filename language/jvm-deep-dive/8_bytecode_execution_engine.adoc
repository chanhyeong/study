= 8장. 바이트코드 실행 엔진

자바 가상 머신 명세에서는 바이트코드 실행 엔진의 개념 모델을 정의하고 있다 +
해석 실행 or 컴파일 실행

== 런타임 스택 프레임 구조

* 메소드를 기본 실행 단위로 사용
* 메소드 호출과 실행의 내부 데이터 구조로 스택 프레임 이용
** 지역 변수 테이블, operand 스택, 동적 링크, 반환 주소 등이 담김
* 메소드 호출 시작 ~ 종료까지 과정은 스택 프레임을 VM 으로 푸시하는 작업에 해당
* 소스 코드 컴파일 시점에 스택 프레임에 넣을 지역 변수 테이블의 크기와 operand 스택에 필요한 깊이를 계산 -> 메소드 테이블 Code 속성에 기록
** 스택 프레임에 할당해야하는 메모리 크기는 런타임 영향을 받지 않음
* 자바 프로그램 관점: 스택에 쌓여 있는 메소드는 모두 실행 중인 상태
* 실행 엔진 관점: 스택 맨 위에 있는 메소드만 실행 중이며 유효
** **현재 스택 프레임**, **현재 메소드**

=== 지역 변수 테이블

* 용량 기준: 변수 슬롯. 개별 32비트 이하
** boolean, byte, char, short, int, float, reference, returnAddress
* reference type: 가리키는 객체의 시작 주소 or 인덱스 + 객체의 타입 정보
* returnAddress: jsr, jsr_w, ret 에 다른 바이트코드 명령어의 주소를 알려 주는 용도
** 예외 시 점프에 사용했지만 지금은 예외 테이블을 사용
* 64비트 타입은 high-order alignment 방식으로 연결
** thread stack 에 thread 별로 따로 만들어지기 때문에 데이터 경합이나 thread safe 문제는 없음
* 인덱스 방식으로 이용 - 0 ~ 담을 수 있는 변수 슬롯의 최대 갯수
** 인접한 두 변수 슬롯이 공동으로 하나의 64비트 데이터를 저장한다면, JVM 은 하나에만 독립적 접근은 할 수 없다 - 클래스 로딩 (검증) 실패
* 매개 변수도 지역 변수 테이블을 통해 전달
** this -> parameter -> local variable 순서
* 변수의 유효 범위를 벗어나면 해당 슬롯을 다른 변수를 담는 데에 재사용
* 재사용이 GC 동작에 영향을 주기도 한다 (부작용)
** 다음 변수가 나타나지 않는 경우에 gc 가 일어나지 않음
* 사용하지 않는 변수에 null 을 할당하는 습관은 좋지 않다 (물론 효과는 있다. 상당히 큰 객체의 경우)
** 범위를 적절히 지정하여 회수하는 시간을 제어하는게 더 낫다
*** 바이트코드 실행 엔진을 이해해야 함
*** JIT 컴파일러가 null 할당을 잘못된 작업으로 판단하여 무시할 가능성이 높음 - 없는 코드로 간주
** 지역 변수에는 '준비' 단계가 없어 초깃값을 지정하기 전까지는 사용할 수 없다
*** 잘못된 코드를 컴파일 단계에서 걸러낼 수 있음

=== operand 스택

* 메소드 실행 초반엔 비어 있음. 실행 동안 스택에 내용을 push/pop
** operand 값을 맨 위에 push, 다음 연산 수행. 호출 시 매개 변수를 operand 스택을 통해 전달
* 원소의 데이터 타입은 바이트코드 명령어의 순서와 정확히 일치해야 한다
** 컴파일 단계에서 검증 + 클래스 검증 단계에서 데이트 흐름 분석하여 또 검증
* 서로 다른 메소드의 VM 스택에 있는 스택 프레임은 독립적이다
** 최적화 과정에서 부분적으로 겹쳐 사용

=== 동적 링크

* 참조는 런타임 상수 풀에 담겨 있고, 각 메소드 스택 프레임에서 런타임 상수 풀 내의 원소를 참조하는 식으로 구성
* 바이트코드의 메소드 호출 명령어는 피호출 메소드가 사용할 심볼 참조를 상수 풀에서 가져와 매개 변수로 넘김
** 심볼 참조 일부: 클래스 로딩 단계에서 참조가 직접 참조로 변경
** 위 과정이 동적 링크

=== 반환 주소

시작한 메소드를 종료하는 방법

. return 바이트코드 명령어를 만나면, normal method invocation completion
. 예외가 발생하고 처리가 제대로 이루어지지 않은 경우
** 메소드의 예외 테이블에 적절한 예외 핸들러가 없음
** abrupt method invocation completion
* 메소드 종료 시 호출한 위치로 돌아가야 한다
** 정상 종료 시에는 호출자의 프로그램 카운터 값을 반환 주소로 사용 (스택 프레임 O)
** 비정상 종료 시 예외 핸들러 테이블에 의해 반환 주소가 결정 (스택 프레임 X)
* 종료 시 수행할 수 있는 작업
.. 호출자의 지역 변수 테이블과 피연산자 스택 복원
.. 반환값이 있는 경우 반환값을 호출자 스택 프레임의 피연산자 스택에 푸시
** PC 값을 조정하여 메소드 호출 명령어의 바로 다음 명령어를 가리키게 함

=== 기타

* 스택 프레임에 추가 정보를 포함할 수도 있음 (디버깅, 프로파일링)

== 메소드 호출

* 메소드 호출 단계에서는 호출할 메소드의 버전을 선택
** 동일한 메소드명으로 존재하는 경우 어느 클래스의 메소드를 실행할 지
* 클래스 파일 컴파일에는 링킹이 없음 -> 심볼 참조다
** 호출 과정이 복잡하다
* 클래스 로딩 시점 or 런타임에 대상 메소드의 '직접 참조'를 알아내야 한다

=== 해석

* 호출 대상은 클래스 파일 상수풀에 '심볼 참조'로 기록
** 해석 단계에서 일부를 직접 참조로 변환
** 전제 - 호출할 버전을 실행되기 전에 알아낼 수 있고, 런타임에서는 다른 버전으로 변경될 수 없음
* invokestatic, invokespecial 명령어는 해석 단계에서 특정할 수 있다
** static, private, constructor (`<init>`), parent method (+ final)
** 이것들은 non-virtual 이고 다른건 virtual
* virtual 명령어 - invokevirtual, invokeinterface, invokedynamic

=== 디스패치

* 올바른 대상 메소드를 결정하는 방법 - 다형성 특성의 가장 기본에 해당되는 내용

==== 정적 디스패치

* p409 코드 8-6
** Human: static type or apparent type
** Man: actual type or runtime type
** 최종 정적 타입은 컴파일 타입에 알 수 있지만, 타입 변경 결과는 런타임에 결정 -> **컴파일러는 객체의 실제 타입이 무엇인지 알지 못한다**
** VM (컴파일러) 은 호출할 메소드를 선택할 때 실제 타입이 아닌 정적 타입을 참고한다
* 정적 디스패치: **메소드 버전 선택에 정적 타입을 참고하는 모든 디스패치 작업**
** 컴파일타임에 이루어진다
* 하나를 특정하지 못하여 '비교적 더 적합한' 버전을 선택하는 경우
** 리터럴 (명시적인 정적 타입이 없음). p412 코드 8-7
** 상속 관계에서 가까울수록 우선순위가 높다
** 가변 길이 매개변수 메소드의 우선순위가 가장 낮다

정리: 컴파일타임에 확정, 클래스 로딩 중에 해석, 오버로딩될 수 있고, 오버로딩된 버전 중에서 선택도 정적 디스패치를 통해 이루어진다

==== 동적 디스패치

'JVM 은 어떤 메소드를 호출할지 어떻게 결정하는가?' +
'JVM 이 실제 타입을 기준으로 메소드 버전을 선택해 알려 주는 방식은 구체적으로 어떤가?'

* p416 코드 8-9
** 16~21 라인: 두 객체의 참조를 스택 맨 위로 푸시, invokevirtual 수행
*** 둘 다 `DynamicDispatch$Human.sayHello` 를 호출하지만 실제 메소드가 다름
* invokevirtual 이 다형성을 구현하는 방식
.. 객체의 실제 타입을 찾음
.. 타입에서 일치하는 메소드를 찾으면 접근 권한 검사 -> return or throw
.. 없다면 상위 클래스 재귀 검사
.. AbstractMethodError
* invokevirtual 명령어
** 상수 풀에 있는 메소드의 심볼 참조를 직접 참조로 변환 + **메소드 수신 객체의 실제 타입을 보고 메소드 버전 선택**
* 동적 디스패치: 런타임에 실제 타입을 보고 메소드 버전을 결정하는 방식
** 필드에는 사용하지 않고 메소드에만 적용. 필드는 다형성과 무관
* 하위 클래스의 필드가 상위 클래스의 필드를 가린다 - p418 코드 8-10

==== 단일 디스패치와 다중 디스패치

* 메소드 볼륨: 메소드 수신 객체 + 매개 변수
** 볼륨 수에 따라 단일 or 다중
** 단일: 한 볼륨 안에서 대상 메소드 선택
** 다중: 둘 이상의 볼륨 안에서 대상을 찾음
* p420 코드 8-11
** 정적 디스패치 (컴파일 타임): 변수의 타입이 Father or Son, QQ or _360
*** 선택에 이용된 볼륨이 2개여서 다중 디스패치
** 동적 디스패치: 라인에 해당하는 invokevirtual 명령어가 실행될 때 메소드 시그니처는 컴파일 타임에 정해짐
*** 메소드 수신 객체의 실제 타입이 Fater or Son 인지만 VM 이 선택할 요소
*** 선택 기준 볼륨이 하나여서 단일 디스패치
* '정적 다중 디스패치' + '동적 단일 디스패치'
* var 는 컴파일타임에 정적으로 추론
* (jdk.dynalink 는 10년 전이 마지막 업데이트)

==== VM 의 동적 디스패치 구현

* 메소드 버전 선택에는 런타임에 수신 객체 타입의 메소드 메타데이터를 보고 적절한 메소드를 찾는 작업이 이루어짐
** 타입 메타데이터를 자주 검색하지 않고, 해당 타입에 대한 가상 메소드 테이블 (vtable) 을 만들어 최적화
*** invokeinterface (itable) 도 있음
* vtable 에는 각 메소드의 실제 시작 주소가 담김
* 하위 클래스에서 override 되지 않으면 부모 클래스에 있는 동일한 메소드의 주소와 같음
* 시그니처가 같은 메소드는 부모 클래스와 자식 클래스의 vtable 에서 인덱스가 같도록 함
** 형 변환 시 검색할 vtable 만 변경하면 되고, 필요한 시작점 주소는 다른 vtable 인덱스로 변환할 수 있음
* vtable 은 링킹 단계에서 초기화
** (aop, instrumentation 은 링킹 (검증, 준비, 해석) 단계에서 바이트코드 조작? 클래스 로더를 가로채서 만드나?)
* 자바 메소드는 기본적으로 virtual
** vtable 외에 클래스 계층 구조 분석도 최적화 수단으로 사용
** guided inline, inlince cache 등도 사용