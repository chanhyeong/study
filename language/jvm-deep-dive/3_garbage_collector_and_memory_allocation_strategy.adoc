= 3장. 가비지 컬렉터와 메모리 할당 전략

overflow 와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는데 GC 가 방해되는 순간이 오면 +
GC 와 메모리 할당 내부를 이해하고 있는게 모니터링하고 조율하기 좋다

== 대상이 죽었는가?

어떤 객체가 살아있고, 죽었는지

=== 참조 카운팅 알고리즘 (미사용)

순환 참조 문제를 풀기 어려움, 자바에서는 사용하지 않음

. 객체를 가리키는 참조 카운터 (reference counter) 추가
** 참조하는 곳이 늘어날 때마다 카운터 값을 1씩 증가
. 참조하는 곳이 사라질 때마다 1씩 감소
. 0 이된 객체는 더 이상 사용 불가

=== 도달 가능성 분석 (reachability analysis) 알고리즘

* GC root (루트 객체) 를 시작 노드 집합으로 사용
** 시작 노드에서 출발하여 참조하는 다른 객체들로 탐색 - 참조 체인 (reference chain)
* 참조 체인이 더 없다면 더 이상 사용할 수 없는 객체 -> 회수 대상

==== GC 루트로 이용할 수 있는 객체

* VM stack 에서 참조하는 객체: 실행 중인 메소드에서 사용하는 ...
* 메소드 영역에서 클래스가 static 필드로 참조하는 객체
* 메소드 영역에서 상수로 참조되는 객체
* 네이티브 메소드 스택에서 JNI 가 참조하는 객체
* JVM 내부에서 쓰이는 참조: Class 객체, 기본 Exception, System ClassLoader
* synchronized lock 으로 잠겨있는 객체
* JVM 내부 상황을 반영하는 JMXBean

뒤에 세대 단위 컬렉션, 부분 컬렉션의 경우 신세대부터 분석 +
다른 영역에 있는 객체도 참조할 수 있으므로 연관 영역 객체들도 GC root 집합에 포함시켜야 도달 가능성을 분석할 수 있음

=== 4가지 참조 구분

* strong reference: 절대 회수하지 않음
* soft reference: 유용하지만 필수는 아닌 객체
** overflow 직전 두 번째 회수를 위한 회수 목록에 추가
** 두 번째 회수 후에도 부족하면 overflow 예외
** `SoftReference`
* weak reference: soft 와 비슷하지만 더 약함
** 다음 GC 까지만 살아 있음
* phantom reference: 객체 수명에 아무런 영향을 주지 않음. 객체 인스턴스를 가져오는 것도 불가
** 유일한 목적은 객체 회수 알림을 받기 위함
** `PhantomReference`

=== 살았나 죽었나?

* 사망 선고를 내리려면 두 번의 marking 거쳐야 한다
* 필터링 조건: finalizer (종료자) 메소드를 실행해야 하는 객체인가?
** 실행해야 하는 경우: F-Queue 에 추가
*** VM 이 나중에 우선순위가 낮은 종료자 스레드를 생성하여 finalize() 실행
* finalize 는 객체가 부활할 수 있는 마지막 기회 - 참조 체인 상의 아무 객체와 연결하면 된다
** 사용하지 마라. finalize 를 호출해주는건 1번 뿐이고 2번째는 반드시 죽는다

=== 메소드 영역 회수하기

크게 2가지를 회수 - '상수', '클래스'

* 비용 효율이 좋지 않음 == 판단이 어려움. 아래 3개 조건을 모두 만족해야 함
** 클래스의 인스턴스가 모두 회수됨
** 클래스를 읽어들인 클래스 로더가 회수됨
** 클래스에 해당하는 Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션으로도 미사용

아래와 같은 환경에서는 JVM 이 타입 언로딩을 지원해야 한다 - 메소드 영역이 과도한 압박에 시달리는 일을 막을 수 있음

. reflection, dynamic proxy, cglib 등의 바이트코드 프레임워크를 많이 사용하는 경우
. JSP 동적 생성
. 클래스 로더를 자주 사용자화하는 OSGi 환경 등

== GC 알고리즘

=== 세대 단위 컬렉션 이론

. weak generational hypothesis: 대다수 객체는 일찍 죽는다
. strong generational hypothesis: 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다

영역을 나누고 나이에 따라 각기 다른 영역에 할당, 살아 남는 소수의 객체를 유지

* 보통은 최소 2개 - 신세대/구세대
* 영역별 GC 도 가능해진다 - minor, major, full
* 객체 특성에 따라 GC 알고리즘 구분 적용 - mark-sweep, mark-copy, mark-compact

살아남을 객체를 찾으려면 도달 가능성을 분석할 때 **'고정된 GC root + 구세대 객체까지 모두 탐색'**해야 결과를 신뢰할 수 있다 +
-> 성능 면에서 부담이 커진다

. intergenerational reference hypothesis: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다

신세대 객체가 세대 간 참조를 가진 경우 -> GC 를 거쳐 구세대로 승격 +
= 세대 간 참조가 자연스럽게 사라진다

* 세대 간 참조의 수는 아주 적기 때문에, 구세대 전체를 훑는 건 낭비
** 신세대에 기억 집합이라는 전역 데이터 구조를 두고, 어느 조각에 세대 간 참조가 있는지 기록하여 관리

=== mark-sweep

* 표시 -> 쓸기
* 2가지 단점
.. 실행 효율이 일정하지 않다
*** 대부분이 회수 대상이라면 표시, 회수 둘 다 일이 커진다
.. 메모리 파편화가 심하다
*** 불연속적인 메모리 파편이 만들어진다

=== mark-copy

* 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 블록만 사용
* 한 쪽이 꽉차면 산 객체만 복사, 기존 블록 청소
* 가용 메모리를 줄여서 낭비가 심하다
* IBM 연구: 신세대 객체 중 98% 가 첫 GC 에서 살아남지 못함
** 1:1 로 나눌 필요가 없다 -> 아펠 스타일 컬렉션

==== Appel style collection

* 신세대: 큰 1개의 에덴 공간 + 2개의 작은 생존자 공간
** 메모리 할당 시 생존자 공간 1개와 에덴만 사용
** GC 시작 시 에덴과 생존자 공간에서 살아남은 객체 -> 나머지 생존자 공간으로 복사, 이전 공간을 바로 비움
** 에덴:생존자 = 8:1 -> 10% 의 공간만 낭비
* 메모리 할당 보증 - 10% 가 넘는 특이 케이스에 대처하는 설계
** 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우, 구세대를 활용해 메모리 할당 보증

=== mark-compact

* mark-copy 는 공간 낭비로 인해 구세대에는 적합하지 않음
* 표시 -> 컴팩트
** 생존한 모든 객체를 한 쪽으로 모아서 나머지 공간을 한꺼번에 비운다
* 메모리 이동이 일어난다
** 생존한 객체를 이동시킨 후, 기존 참조를 모두 갱신하는 것은 매우 부담
** stop-the-world
* 이동하면 회수가 복잡 -> 일시 정지 시간 감소, 전체 GC 처리량 감소
** CMS collector
* 이동하지 않으면 할당이 복잡 -> 일시 정지 시간 증가, 전체 GC 처리량 증가
** Parallel old collector
* 혼합
** mark-sweep 사용하다가 파편화가 심해지면 mark-compact

== 핫스팟 알고리즘 상세 구현

필요한 기초 지식들

=== root node enumeration

* 도달 가능성 분석 알고리즘에서 GC 루트 집함으로부터 참조 체인을 찾는 작업
** user thread 를 일시 정지해야 함 - stop the world 를 피할 수 없음
* 가장 오래 걸리는 작업은 동시에 실행할 수 있음 - 일관성이 보장되는 스냅샷 상태에서
* 주류 VM 은 주소 자료형을 알 수 있어서 위치를 전부 확인할 필요는 없음
** 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다 -> OopMap
* OopMap
** 클래스 로딩이 완료되면 객체에 포함된 각 데이터 타입 확인
** JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록
** 스캔 과정에서 이 정보를 직접 얻어 낸다

=== safe point

참조 관계나 OopMap 의 내용 변경이 가능한 명령어가 많음 +
모두 OopMap 을 만들어 넣으면 메모리를 더 사용해야 함

* 모든 명령어에 OopMap 을 생성하진 않고 특정한 위치 (safe point) 에만 기록
* safe point 에 도달할 때까지는 절대 멈춰 세우지 않음
* 메소드 호출, loop, exception handling 등 명령어 흐름이 다중화 될 때 safe point 생성

GC 가 시작되면 가까운 safe point 까지 실행하고 멈추게 할 방법이 필요

* voluntary suspension: flag bit 를 설정하여 각 thread 가 실행 중 적극적으로 폴링
** 플래그 값이 true 만 가장 가까운 곳에서 스스로 멈춘다
** 폴링은 효율적이어야 함 -> memory protection trap 을 사용하여 어셈블리어 하나로도 수행할 수 있게 단순화 함
* preemptive suspension (미사용): 모든 user thread interrupt
** 중단된 위치가 safe point 가 아니라면 재개하고 도달할 때까지 반복

=== safe region

* 실행 중이지 않은 (sleep, block) user thread 대상
* 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장
** 여기서는 어디서든 GC 를 시작해도 무방하다
* user thread 가 safe region 진입 표시 -> GC 가 신경쓰지 않음
** 벗어나려는 thread 는 VM 이 루트 노드 열거를 완료했는지, pause 해야하는 다른 GC 단계가 완료됐는지 확인

=== 기억 집합과 카드 테이블

* 기억 집합: 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조
** (구세대 -> 신세대를 가리키는 테이블 정도로 생각)
** 정밀도 지정으로 공간과 관리 비용 절약 가능
** 워드 (메모리의 워드, 64비트) < 객체 (객체 단위) < 카드 (메모리 블록 단위, 가장 많이 쓰임)

카드 테이블: 카드 정밀도로 기억 집합을 구현

* 바이트 배열인 CARD_TABLE 의 원소 각각 (카드 페이지) 이 메모리 영역에서 특정 크기의 메모리 블록 하나에 대응
* 카드 페이지 하나 - 하나 이상의 객체
** 하나에라도 세대 간 포인터를 갖는다면 dirty, 없으면 0
** dirty 만 확인하면 어떤 블록이 세대 간 포인터를 포함하는지 쉽게 파악 가능

=== 쓰기 장벽

카드 테이블 원소를 관리하는 문제 - 언제 더럽혀지고 주체는 무엇인지

* 읽기 장벽: 동시 비순차 실행 문제를 해결하기 위한 메모리 장벽 기술
* 쓰기 장벽: 참조 타입에 객체가 대입되면, around advice 가 생성되어 대입 사전/사후로 추가 동작을 수행
** 추가로 실행할 명령어를 생성해 대입 연산 모두에 추가

=== 동시 접근 가능성 분석

일관성이 보장되는 스냅샷 상태에서 전체 과정을 진행해야 한다

* GC root 는 수가 적고, OopMap 등의 최적화 기법들로 인해 thread 가 멈춰 있는 시간은 매우 짧음
* 루트 노트 열거가 끝나면 객체 그래프 탐색
** **이 단계의 일시 정지 시간은 heap 크기에 비례**
** 이 시간을 줄이면 좋다
* tri-color marking 기법
** 마주치는 객체들에 '방문한 객체인가' 조건에 따라 3가지 색을 칠한다
** white: 방문하지 않은 객체 - 분석한 뒤에도 같으며녀 도달 불가능
** black: 방문한 적 있고 모든 참조 스캔 완료 - 확실히 생존
*** 다른 객체에서 검은 객체를 가리키는 참조가 있으면 다시 스캔하지 않아도 된다
** gray: 방문한 적 있으나 참조 중 스캔을 완료하지 않은 참조가 존재

user thread 가 참조 관계를 변경하면 문제가 되는데, 다음 2개 중 하나를 적용하여 해결 가능

* 증분 업데이트 (CMS)
** 검은색 객체에 흰색 객체로의 참조가 추가되면 새로 추가된 참조를 기록
** 스캔이 끝난 후 검은 객체를 루트로 하여 다시 스캔
* 시작 단계 스냅샷 (G1, 셰넌도어)
** 회색 객체가 흰색 객체로의 참조를 끊으려 하면 기록
** 스캔이 끝난 후 회색 객체를 루트로 하여 다시 스캔

== 클래식 가비지 컬렉터

=== Serial collector

* 단일 스레드 동작
* gc 가 시작되면 회수가 완료될 때까지 다른 모든 작업 thread 가 멈춰 있어야 한다
* 간단하고 효율적이다
** 요구하는 메모리 사용량이 적음, 스레드 상호 작용에 의한 오버헤드가 없음

=== ParNew collector

* 여러 thread 를 활용하여 serial collector 를 병렬화한 버전
* 구세대 CMS + 신세대 ParNew 로 조합으르 많이 했으나 JDK 9 부터 G1 이 대체하도록 빼버림

=== Parallel scavenge collector

* mark-copy 를 기초, 여러 thread 로 병렬 회수
* 처리량을 제어하는게 목표
** 사용자 코드를 실행하는 데 사용하는 시간과 프로세서가 소비하는 총 시간의 비율

=== Serial old collector

* Serial collector 의 구세대 버전
* mark-compact 알고리즘 사용
* 목적: JDK5 와 그 이전 PS 컬렉터와 사용 or CMS 컬렉터가 실패할 때를 위한 대비책

=== Parallel old collector

* PS 컬렉터의 구세대용 버전

=== CMS collector

* mark-sweep 모두 user thread 와 동시에 수행
* GC 에 따른 일시 정지 시간을 최소로 줄이는 것이 목적

==== 단계

. 최초 표시 (STW): GC root 와 직접 연결된 객체만 표시
. 동시 표시: 객체 그래프 전체 탐색
. 재표시 (STW): 동시 표시 중 참조 관계를 변경한 객체를 바로 잡음
. 동시 쓸기: 죽었다고 판단한 객체 쓸어 담기

==== 단점

. 프로세서 자원에 아주 민감하다
** user thread 를 멈추진 않지만 앱을 느리게 하고 처리량을 떨어뜨리는 건 불가피하다
** 프로세서 자원 25% 정도를 사용
. 부유 쓰레기를 처리하지 못하여 동시 모드 실패를 유발할 가능성이 있다
** user thread 와 동시에 돌기 때문에, GC 타이밍에 새로운 쓰레기가 계속 생겨난다
** 구세대 GC 시작 비율: JDK5 68%, JDK6 92%
** 메모리를 더 많이 요구한다면 동시 모드가 실패 -> STW -> serial old 를 가동하여 구세대 GC
. mark-sweep 으로 인한 파편화 문제

G1, 셰년도어, ZGC 로 넘어가고 있음

=== G1 Collector

Garbage First

* 부분 회수 + region 회수
* 서버용 애플리케이션에 집중한 컬렉터, JDK9 부터 서버 모드용 기본 컬렉터
* 정지 시간 예측 모델 (pause prediction model)
** 목표 정지 시간을 지정하면 그 시간 이상을 넘지 않도록 통제

==== 정지 시간 예측 모델

* heap 어느 곳이든 회수 대상에 포함할 수 있다 - collection set, CSet
* '어느 영역에 쓰레기가 가장 많은가', '회수 시 이득이 어디가 가장 큰가'
* 영역 기반 힙 메모리 레이아웃
** 연속된 heap 을 독립 리전으로 나눔
* 큰 객체를 저장하기 위해 거대 (humongous) 리전 유형
** 리전 용량의 절반보다 큰 객체. 보통은 구세대로 취급
* 리전별 역할을 동적으로 바꿀 수 있고, 연이어 배치될 필요도 없다

각 리전의 쓰레기 누적값 추적

* 값: GC 로 회수할 수 있는 공간의 크기와 회수에 드는 시간의 경험값
* 사용자 설정 값이 허용하는 한도 내에서 **회수 효과가 가장 큰 리전부터 회수**

G1 구현 시 해결해야 했던 주요 문제들

. 객체들의 리전 간 참조 문제를 해결해야 한다
** 모든 리전이 각자의 기억집합을 관리
** 양방향을 기록해야 하므로 구현이 더 복잡, 메모리를 10% ~ 20% 정도 더 사용
. 동시 표시 단계 동안 GC thread, user thread 가 서로 간섭하지 않도록 보장해야 한다
** 각 리전을 위해 TAMS 라는 2개의 포인터 설계
** 공간 일부가 새 객체를 할당하기 위한 공간으로 나뉘고, 새로 생성되는 객체의 주소는 이 두 포인터보다 높은 주소 영역에 할당되어야 한다
** 메모리 회수 속도가 메모리 할당 속도를 따라가지 못한다면 Full GC 를 해야 한다
. 신뢰할 수 있는 정지 시간 예측 모델을 구현해야 한다

이론적 기초는 감소 (decaying) 평균이다

* 리전별 회수 시간, 기억 집합 dirty 카드 개수 등 소요 시간 기록
** 평균, 표준 편차, 신뢰도 등의 통계 분석
* 감소 평균은 '최근'의 평균적인 상태를 더 정확하게 알려준다

==== 단계

. 최초 표시
** 표시, TAMS 포인터 수정 (시작 단계 스냅샷 생성)
** 매우 짧고 마이너 GC 수행 간 끝나므로 일시 정지는 거의 없다
. 동시 표시
. 재표시
. 복사 및 청소
** 통계 기반으로 리전들을 줄 세운 다음 회수 계획을 세움
** 살아남은 객체들을 빈 리전으로 이주 (pause)

G1 의 목표는 지연 시간을 제어하는 동시에 처리량을 최대한 높이는 것

* 정지 시간의 기댓값을 설정할 수 있는 것이 큰 장점. 기본값은 200ms
* 너무 짧으면? 쓰레기가 쌓여간다
* 애플리케이션의 메모리 할당 속도에 맞춰 회수하는 방향으로 변화
** 객체가 버려지는 속도를 컬렉터가 따라갈 수 있다면 완벽하게 동작하는 아이디어이며, 최초 구현이 G1

=== 오늘날의 가비지 컬렉터들

* serial collector 가 serial old 흡수
* PS, parallel old 가 합쳐져 parallel
* CMS -> G1
* ZGC, 셰넌도어

== 저지연 가비지 컬렉터

garbage collector 를 측정하는 가장 중요한 지표 +
-> 처리량, 지연 시간, 메모리 사용량 (이게 중요도가 커지고 있다)

=== 셰넌도어

* 오라클이 주도하지 않은 첫 번째 HotSpot garbage collector
* 다른 회사의 OpenJDK 에만 존재하는 컬렉터다
* 목표: 힙 크기와 상관없이 GC 로 인한 정지를 10ms 이하로 줄이는 것
** 모든 단계를 사용자 스레드와 동시 수행
* G1 과 힙 레이아웃이 비슷하고 공통점이 많다

==== 개선 사항

. 동시 모으기 지원: 사용자 스레드와 동시에 모으기 단계를 수행
. 세대 단위 컬렉션 미사용
. 기억 집합 대신 **연결 행렬** 로 리전 간 참조 관계 기록

==== 동작 방식

. 최초 표시
. **동시 표시**
. 최종 표시
. 동시 청소: 산 객체가 없는 리전들 청소
. **동시 이주**: 살아남은 객체들을 다른 빈 리전으로 이주
** 다른 객체들에서의 참조 해결을 위해 **읽기 장벽과 포워딩 포인터** 이용
. 최초 참조 갱신
** 참조 갱신: 이주된 객체에 대한 참조를 새로운 주소로 수정
** 스레드들이 집결지를 설정해 직전 단계의 모든 GC 스레드와 사용자 스레드가 이주를 끝마쳤음을 보장
** 일시 정지가 있음
. **동시 참조 갱신**: 참조 갱신을 실제로 시작. 참조 타입을 선형 검색하며 수정
. 최종 참조 갱신: GC 루트 집합의 참조도 갱신 (마지막 일시 정지)
. 동시 청소: 회수 집합에 대한 동시 청소 재수행

==== 포워딩 포인터

객체 이동과 사용자 프로그램을 동시에 수행하는 방법

* 기존엔 '미모리 보호 트랩': 옛 공간에 접근 시 미리 설정한 예외 처리기가 실행됨
** OS 의 지원 없이는 user <-> kernal 모드를 수시로 전환해야 해서 비용이 큰 해법
* 포워딩 포인터: 원래 객체 레이아웃 구조 상단에 참조 필드 추가
** 동시 이주가 아닌 경우 자신을 가리킴
** 우회하여 접근하는 오버헤드가 각 객체 모두에 더해지긴 한다
* 데이터를 쓰려고 할 때는 새로 복사된 객체에만 써야 한다 - thread race condition 발생
** 포워딩 포인터에 접근하는 동작을 CAS 로 하여 동시 이주 중에도 문제 없게 함
* 쓰기 장벽과 읽기 장벽을 둘 다 사용
** '객체로의 접근'에 속하는 모든 동작을 보호하기 위함

==== 추가 개선

. 로드 참조 장벽 (load reference barrier) 도입
** 객체 참조 타입의 데이터를 읽거나 쓸 때만 끼어드는 메모리 장벽 모델
** 참조가 아닌 필드 (primitive, 객체 비교, 객체 락) 에는 간섭하지 않음
** 자가 수리 장벽 (self-fixing barrier) 도입
** GC 루트 처리와 클래스 언로딩까지 일시 정지가 아닌 동시 실행
. 포워딩 포인터를 객체 헤더에 통합
. 스택 워터마크를 활용한 thread 스택 동시 처리
** thread 스택 중 변화가 생기는 부분은 최상위 뿐이다 -> 나머지는 GC thread 가 맘대로 스캔 가능
** -> 스택 워터마크 도입
.. 최초 표시 때 thread 최상위 프레임에 스택 워터마크 설정
.. 사용자 thread 가 최상위 프레임을 스캔하고 워터마크를 한 칸 낮춤
.. GC thread 가 워터마크까지 스캔
.. 사용자 thread 가 최상위 스택 프레임을 파괴할 때마다 아래 과정 수행
... 워터마크를 한 칸 낮춤
... GC thread 가 워터마크 위로는 스캔하지 못하게 막음
... 1의 결과로 워터마크 위로 떠오른 스택 프레임을 스캔

=== ZGC

처리량에 미치는 영향을 최소화 하고 일시 정지 시간을 10ms 로 줄이고자 함

[quote]
ZGC 는 세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다. 낮은 지연 시간을 최우선 목표로 하며, 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 포인터, 메모리 다중 매핑 기술을 이용하는 가비지 컬렉터다.

==== 리전 기반 메모리 레이아웃

* ZGC 의 리전은 동적으로 생성/파괴 (크기까지) 
** small, medium, large

==== 병렬 모으기와 컬러 포인터

* 컬러 포인터: garbage collector 나 VM 자체에만 이용하는 추가 데이터 저장
** 이전에는 객체 헤더에 저장 (hash code, gen age, lock record)
** 이동한 객체와 관련해 필요한 정보를 객체와 관련 없는 곳에서 얻기
** **객체를 가리키는 포인터에 직접 표시**. 포인터 자체에 소량의 추가 정보를 직접 저장
* 주소 공간을 44비트까지로 제한, 상위 4개 비트를 플래그 비트로 사용
** Finalizable, Remapped, Marked1, Marked0
* 32bit 플랫폼에서는 미동작, 압축 포인터 지원 불가
* 이점 3가지
.. 한 리전 안의 생존 객체들이 이동하면 그 즉시 해당 리전을 재활용할 수 있다.
.. GC 과정에서 메모리 장벽 수를 크게 줄일 수 있다
*** 쓰기 장벽의 주 이유: 객체 참조를 변경
*** 정보를 포인터 자체에 둔다면 일부 기록 작업이 필요 없다
*** 확장 가능한 저장 구조로 쓸 수 있다

(물리 메모리에 대응되는 주소라면, OS 에서 이미 쓰고 있다면 어떻게 하는가? 대응되는 주소가 아닌가?)

* 컬러 포인터와 OS 의 정의 주소는 다르다
* x86 80386 부터는 메모리를 프로세스 단위로 격리
** real mode 의 물리 메모리 주소와는 다른 주소 사용
** 프로세서에서 페이지 관리 메커니즘을 활용 -> 선형 메모리 공간과 물리 메모리 공간을 블록으로 나누어 페이지로 부름
** 매핑 테이블을 이용하여 선형의 가상 공간 페이지와 물리 공간 페이지 사이의 변환 처리
* ZGC 는 서로 다른 여러 가상 메모리 주소를 물리 메모리 주소로 매핑하기 위해 **다중 매핑** 이용
** 다대일 매핑, **ZGC 가 가상 메모리로 다루는 주소 공간이 실제 메모리 용량보다 크다**
** 큰 객체 복사를 수비게 해주는 등의 이점도 있음

==== 동작 방식

. 동시 표시: 도달 가능성 분석, 컬러 포인터의 Marked0, Marked1 이 여기서 갱신
. 동시 재배치 준비: 청소해야 할 리전들을 선정하여 재배치 (relocation) 집합을 만듦
** 매 GC 마다 모든 리전을 스캔 (기억 집합 x)
** 생존 객체를 다른 리전으로 복사 후 리전 자체를 회수할지 여부만 결정
. 동시 재배치: 재배치 집합 안의 생존 객체들을 새로운 리전으로 복사
** 컬러 포인터로 인해 참조만으로 재배치 집합에 속하는지 알 수 있음
** 재배치 집합 내 객체로 접근 시 메모리 장벽 -> 새로운 객체로 포워드 시키고 해당 참조도 갱신 (self-healing)
. 동시 재매핑: 재배치 집합에 있는 옛 객체를 향하는 참조를 전부 갱신

==== 다른 컬렉터들과의 비교

. 기억 집합을 사용하지 않는다
** -> 객체 할당 속도를 제한한다
** -> 생성되는게 너무 많으면 회수 단계에서는 표시가 어려워서 대부분 살아남고 부유 쓰레기가 많아진다 -> 여유 공간이 줄어든다
** 힙 크기를 늘려서 시간을 늘리는 방법 뿐
** 결국은 세대 단위 컬렉션을 도입하여 새 객체는 특별한 영역에 생성하고 더 자주 더 빠르게 회수
** (세대 단위가 없기 때문에 기억 집합도 필요 없음 -> 객체 전체를 스캔 -> 부유 쓰레기 증가)
. NUMA 메모리를 고려한 메모리 할당 (Non-Uniform Memory Access)
** 프로세서 코어 각각에서의 메모리 관리
** 객체 생성을 요청한 thread 가 수행 중인 프로세서의 지역 메모리에 우선적으로 객체 할당 - 접근 효율을 높임

=== generational ZGC

세대를 구분해서 가장 큰 이점: 수명이 짧은 젊은 객체들을 더 자주 회수 +
ZGC 에서 세대를 구분하지 않은 이유는 구현 복잡도 때문

* 젊은 객체들만 대상으로 하면 더 적은 노력으로 더 많은 메모리 공간을 확보할 수 있다 + 성능 개선
* -XX:+UseZGC -XX:+ZGenerational
* 세대 간 참조를 추적하기 위한 쓰기 장벽도 활용
* 컬러 포인터에 '세대 간 참조를 포함하는지' 정보를 추가
* 도달 가능 객체 표시 작업을 쓰기 장벽으로 옮겨 옴

==== 다중 매핑 메모리 제거

* 메모리 사용량을 더 정확히 측정

==== 다양한 장벽 최적화

* garbage collector 코드가 컴파일된 애플리케이션 코드에 섞여서 실행
* 기억 집합 장벽, 시작 단계 스냅샷 표시 장벽, 쓰기 장벽 버퍼, 장벽 패치 등 적용

==== 이중 버퍼를 이용한 기억 집합 관리

* 비트맵 이용: 객체 필드의 위치를 정확하게 기록
** 비트 하나가 객체 필드 주소 하나 표현
* 구세대 리전 각각이 한 쌍의 기억 집합을 가짐
* 비트맵 하나는 애플리케이션 thread 의 쓰기 장벽에서 수정, 읽기 전용 복사본인 다른 비트맵은 GC thread rk ckarh
** minor GC 가 시작될 때마다 두 비트맵을 원자적으로 교환

==== 밀집도 기반 리전 처리

* 최근에 할당된 리전이라면 더 많은 객체가 살아 있을 가능성이 크다
* 신세대 리전들의 밀집도 분석
* 회사 대상으로 선정되지 않은 리전은 그대로 나이를 먹어서 생존자 리전, 더 먹으면 구세대로 승격
* 다음번 GC 에서는 밀집도가 더 높아져 회수 대상이 될 가능성이 커진다
* 리전을 그대로 둔 채 노화시키는 방식으로 신세대 리전들을 회수하는 비용을 줄일 수 있다

==== 거대 객체 처리

* 거대한 객체도 신세대에 바로 할당 -> 재배치 없이 노화

== 적합한 가비지 컬렉터 선택하기

=== 엡실론 컬렉터

* GC 를 전혀 하지 않는 컬렉터

=== 컬렉터들 간 비교 및 취사 선택

* 작은 데이터 -> Serial
* 단일 프로세서만 사용, 일시 정지 시간 관련 제약이 없음 -> Serial
* 최대 성능 중요, 지연 시간 제약이 없거나 일부 허용 -> 기본 GC or Parallel
* 응답 시간이 중요하고 GC 일시 정지가 짧아야 한다면 -> G1
* 응답 시간이 매우 중요하면 -> ZGC

=== VM 과 GC log

* -Xlog:gc*
* `[3.080s][info][gc, cpu] GC(5) User=0.03s Sys=0.00s Real=0.01s`