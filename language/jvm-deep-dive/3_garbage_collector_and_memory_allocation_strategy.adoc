= 3장. 가비지 컬렉터와 메모리 할당 전략

overflow 와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는데 GC 가 방해되는 순간이 오면 +
GC 와 메모리 할당 내부를 이해하고 있는게 모니터링하고 조율하기 좋다

== 대상이 죽었는가?

어떤 객체가 살아있고, 죽었는지

=== 참조 카운팅 알고리즘 (미사용)

순환 참조 문제를 풀기 어려움, 자바에서는 사용하지 않음

. 객체를 가리키는 참조 카운터 (reference counter) 추가
** 참조하는 곳이 늘어날 때마다 카운터 값을 1씩 증가
. 참조하는 곳이 사라질 때마다 1씩 감소
. 0 이된 객체는 더 이상 사용 불가

=== 도달 가능성 분석 (reachability analysis) 알고리즘

* GC root (루트 객체) 를 시작 노드 집합으로 사용
** 시작 노드에서 출발하여 참조하는 다른 객체들로 탐색 - 참조 체인 (reference chain)
* 참조 체인이 더 없다면 더 이상 사용할 수 없는 객체 -> 회수 대상

==== GC 루트로 이용할 수 있는 객체

* VM stack 에서 참조하는 객체: 실행 중인 메소드에서 사용하는 ...
* 메소드 영역에서 클래스가 static 필드로 참조하는 객체
* 메소드 영역에서 상수로 참조되는 객체
* 네이티브 메소드 스택에서 JNI 가 참조하는 객체
* JVM 내부에서 쓰이는 참조: Class 객체, 기본 Exception, System ClassLoader
* synchronized lock 으로 잠겨있는 객체
* JVM 내부 상황을 반영하는 JMXBean

뒤에 세대 단위 컬렉션, 부분 컬렉션의 경우 신세대부터 분석 +
다른 영역에 있는 객체도 참조할 수 있으므로 연관 영역 객체들도 GC root 집합에 포함시켜야 도달 가능성을 분석할 수 있음

=== 4가지 참조 구분

* strong reference: 절대 회수하지 않음
* soft reference: 유용하지만 필수는 아닌 객체
** overflow 직전 두 번째 회수를 위한 회수 목록에 추가
** 두 번째 회수 후에도 부족하면 overflow 예외
** `SoftReference`
* weak reference: soft 와 비슷하지만 더 약함
** 다음 GC 까지만 살아 있음
* phantom reference: 객체 수명에 아무런 영향을 주지 않음. 객체 인스턴스를 가져오는 것도 불가
** 유일한 목적은 객체 회수 알림을 받기 위함
** `PhantomReference`

=== 살았나 죽었나?

* 사망 선고를 내리려면 두 번의 marking 거쳐야 한다
* 필터링 조건: finalizer (종료자) 메소드를 실행해야 하는 객체인가?
** 실행해야 하는 경우: F-Queue 에 추가
*** VM 이 나중에 우선순위가 낮은 종료자 스레드를 생성하여 finalize() 실행
* finalize 는 객체가 부활할 수 있는 마지막 기회 - 참조 체인 상의 아무 객체와 연결하면 된다
** 사용하지 마라. finalize 를 호출해주는건 1번 뿐이고 2번째는 반드시 죽는다

=== 메소드 영역 회수하기

크게 2가지를 회수 - '상수', '클래스'

* 비용 효율이 좋지 않음 == 판단이 어려움. 아래 3개 조건을 모두 만족해야 함
** 클래스의 인스턴스가 모두 회수됨
** 클래스를 읽어들인 클래스 로더가 회수됨
** 클래스에 해당하는 Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션으로도 미사용

아래와 같은 환경에서는 JVM 이 타입 언로딩을 지원해야 한다 - 메소드 영역이 과도한 압박에 시달리는 일을 막을 수 있음

. reflection, dynamic proxy, cglib 등의 바이트코드 프레임워크를 많이 사용하는 경우
. JSP 동적 생성
. 클래스 로더를 자주 사용자화하는 OSGi 환경 등

== GC 알고리즘

=== 세대 단위 컬렉션 이론

. weak generational hypothesis: 대다수 객체는 일찍 죽는다
. strong generational hypothesis: 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다

영역을 나누고 나이에 따라 각기 다른 영역에 할당, 살아 남는 소수의 객체를 유지

* 보통은 최소 2개 - 신세대/구세대
* 영역별 GC 도 가능해진다 - minor, major, full
* 객체 특성에 따라 GC 알고리즘 구분 적용 - mark-sweep, mark-copy, mark-compact

살아남을 객체를 찾으려면 도달 가능성을 분석할 때 **'고정된 GC root + 구세대 객체까지 모두 탐색'**해야 결과를 신뢰할 수 있다 +
-> 성능 면에서 부담이 커진다

. intergenerational reference hypothesis: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다

신세대 객체가 세대 간 참조를 가진 경우 -> GC 를 거쳐 구세대로 승격 +
= 세대 간 참조가 자연스럽게 사라진다

* 세대 간 참조의 수는 아주 적기 때문에, 구세대 전체를 훑는 건 낭비
** 신세대에 기억 집합이라는 전역 데이터 구조를 두고, 어느 조각에 세대 간 참조가 있는지 기록하여 관리

=== mark-sweep

* 표시 -> 쓸기
* 2가지 단점
.. 실행 효율이 일정하지 않다
*** 대부분이 회수 대상이라면 표시, 회수 둘 다 일이 커진다
.. 메모리 파편화가 심하다
*** 불연속적인 메모리 파편이 만들어진다

=== mark-copy

* 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 블록만 사용
* 한 쪽이 꽉차면 산 객체만 복사, 기존 블록 청소
* 가용 메모리를 줄여서 낭비가 심하다
* IBM 연구: 신세대 객체 중 98% 가 첫 GC 에서 살아남지 못함
** 1:1 로 나눌 필요가 없다 -> 아펠 스타일 컬렉션

==== Appel style collection

* 신세대: 큰 1개의 에덴 공간 + 2개의 작은 생존자 공간
** 메모리 할당 시 생존자 공간 1개와 에덴만 사용
** GC 시작 시 에덴과 생존자 공간에서 살아남은 객체 -> 나머지 생존자 공간으로 복사, 이전 공간을 바로 비움
** 에덴:생존자 = 8:1 -> 10% 의 공간만 낭비
* 메모리 할당 보증 - 10% 가 넘는 특이 케이스에 대처하는 설계
** 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우, 구세대를 활용해 메모리 할당 보증

=== mark-compact

* mark-copy 는 공간 낭비로 인해 구세대에는 적합하지 않음
* 표시 -> 컴팩트
** 생존한 모든 객체를 한 쪽으로 모아서 나머지 공간을 한꺼번에 비운다
* 메모리 이동이 일어난다
** 생존한 객체를 이동시킨 후, 기존 참조를 모두 갱신하는 것은 매우 부담
** stop-the-world
* 이동하면 회수가 복잡 -> 일시 정지 시간 감소, 전체 GC 처리량 감소
** CMS collector
* 이동하지 않으면 할당이 복잡 -> 일시 정지 시간 증가, 전체 GC 처리량 증가
** Parallel old collector
* 혼합
** mark-sweep 사용하다가 파편화가 심해지면 mark-compact

== 핫스팟 알고리즈므 상세 구현

필요한 기초 지식들

=== root node enumeration

* 도달 가능성 분석 알고리즘에서 GC 루트 집함으로부터 참조 체인을 찾는 작업
** user thread 를 일시 정지해야 함 - stop the world 를 피할 수 없음
* 가장 오래 걸리는 작업은 동시에 실행할 수 있음 - 일관성이 보장되는 스냅샷 상태에서
* 주류 VM 은 주소 자료형을 알 수 있어서 위치를 전부 확인할 필요는 없음
** 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다 -> OopMap
* OopMap
** 클래스 로딩이 완료되면 객체에 포함된 각 데이터 타입 확인
** JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록
** 스캔 과정에서 이 정보를 직접 얻어 낸다

=== safe point

참조 관계나 OopMap 의 내용 변경이 가능한 명령어가 많음 +
모두 OopMap 을 만들어 넣으면 메모리를 더 사용해야 함

* 모든 명령어에 OopMap 을 생성하진 않고 특정한 위치 (safe point) 에만 기록
* safe point 에 도달할 때까지는 절대 멈춰 세우지 않음
* 메소드 호출, loop, exception handling 등 명령어 흐름이 다중화 될 때 safe point 생성

GC 가 시작되면 가까운 safe point 까지 실행하고 멈추게 할 방법이 필요

* voluntary suspension: flag bit 를 설정하여 각 thread 가 실행 중 적극적으로 폴링
** 플래그 값이 true 만 가장 가까운 곳에서 스스로 멈춘다
** 폴링은 효율적이어야 함 -> memory protection trap 을 사용하여 어셈블리어 하나로도 수행할 수 있게 단순화 함
* preemptive suspension (미사용): 모든 user thread interrupt
** 중단된 위치가 safe point 가 아니라면 재개하고 도달할 때까지 반복

=== safe region

* 실행 중이지 않은 (sleep, block) user thread 대상
* 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장
** 여기서는 어디서든 GC 를 시작해도 무방하다
* user thread 가 safe region 진입 표시 -> GC 가 신경쓰지 않음
** 벗어나려는 thread 는 VM 이 루트 노드 열거를 완료했는지, pause 해야하는 다른 GC 단계가 완료됐는지 확인

=== 기억 집합과 카드 테이블

* 기억 집합: 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조
** (구세대 -> 신세대를 가리키는 테이블 정도로 생각)
** 정밀도 지정으로 공간과 관리 비용 절약 가능
** 워드 (메모리의 워드, 64비트) < 객체 (객체 단위) < 카드 (메모리 블록 단위, 가장 많이 쓰임)

카드 테이블: 카드 정밀도로 기억 집합을 구현

* 바이트 배열인 CARD_TABLE 의 원소 각각 (카드 페이지) 이 메모리 영역에서 특정 크기의 메모리 블록 하나에 대응
* 카드 페이지 하나 - 하나 이상의 객체
** 하나에라도 세대 간 포인터를 갖는다면 dirty, 없으면 0
** dirty 만 확인하면 어떤 블록이 세대 간 포인터를 포함하는지 쉽게 파악 가능

=== 쓰기 장벽

카드 테이블 원소를 관리하는 문제 - 언제 더럽혀지고 주체는 무엇인지

* 읽기 장벽: 동시 비순차 실행 문제를 해결하기 위한 메모리 장벽 기술
* 쓰기 장벽: 참조 타입에 객체가 대입되면, around advice 가 생성되어 대입 사전/사후로 추가 동작을 수행
** 추가로 실행할 명령어를 생성해 대입 연산 모두에 추가

=== 동시 접근 가능성 분석

일관성이 보장되는 스냅샷 상태에서 전체 과정을 진행해야 한다

* GC root 는 수가 적고, OopMap 등의 최적화 기법들로 인해 thread 가 멈춰 있는 시간은 매우 짧음
* 루트 노트 열거가 끝나면 객체 그래프 탐색
** **이 단계의 일시 정지 시간은 heap 크기에 비례**
** 이 시간을 줄이면 좋다
* tri-color marking 기법
** 마주치는 객체들에 '방문한 객체인가' 조건에 따라 3가지 색을 칠한다
** white: 방문하지 않은 객체 - 분석한 뒤에도 같으며녀 도달 불가능
** black: 방문한 적 있고 모든 참조 스캔 완료 - 확실히 생존
*** 다른 객체에서 검은 객체를 가리키는 참조가 있으면 다시 스캔하지 않아도 된다
** gray: 방문한 적 있으나 참조 중 스캔을 완료하지 않은 참조가 존재

user thread 가 참조 관계를 변경하면 문제가 되는데, 다음 2개 중 하나를 적용하여 해결 가능

* 증분 업데이트 (CMS)
** 검은색 객체에 흰색 객체로의 참조가 추가되면 새로 추가된 참조를 기록
** 스캔이 끝난 후 검은 객체를 루트로 하여 다시 스캔
* 시작 단계 스냅샷 (G1, 셰넌도어)
** 회색 객체가 흰색 객체로의 참조를 끊으려 하면 기록
** 스캔이 끝난 후 회색 객체를 루트로 하여 다시 스캔

== 클래식 가비지 컬렉터

=== Serial collector

* 단일 스레드 동작
* gc 가 시작되면 회수가 완료될 때까지 다른 모든 작업 thread 가 멈춰 있어야 한다
* 간단하고 효율적이다
** 요구하는 메모리 사용량이 적음, 스레드 상호 작용에 의한 오버헤드가 없음

=== ParNew collector

* 여러 thread 를 활용하여 serial collector 를 병렬화한 버전
* 구세대 CMS + 신세대 ParNew 로 조합으르 많이 했으나 JDK 9 부터 G1 이 대체하도록 빼버림

=== Parallel scavenge collector

* mark-copy 를 기초, 여러 thread 로 병렬 회수
* 처리량을 제어하는게 목표
** 사용자 코드를 실행하는 데 사용하는 시간과 프로세서가 소비하는 총 시간의 비율

=== Serial old collector

* Serial collector 의 구세대 버전
* mark-compact 알고리즘 사용
* 목적: JDK5 와 그 이전 PS 컬렉터와 사용 or CMS 컬렉터가 실패할 때를 위한 대비책

=== Parallel old collector

* PS 컬렉터의 구세대용 버전

=== CMS collector

* mark-sweep 모두 user thread 와 동시에 수행
* GC 에 따른 일시 정지 시간을 최소로 줄이는 것이 목적

==== 단계

. 최초 표시 (STW): GC root 와 직접 연결된 객체만 표시
. 동시 표시: 객체 그래프 전체 탐색
. 재표시 (STW): 동시 표시 중 참조 관계를 변경한 객체를 바로 잡음
. 동시 쓸기: 죽었다고 판단한 객체 쓸어 담기

==== 단점

. 프로세서 자원에 아주 민감하다
** user thread 를 멈추진 않지만 앱을 느리게 하고 처리량을 떨어뜨리는 건 불가피하다
** 프로세서 자원 25% 정도를 사용
. 부유 쓰레기를 처리하지 못하여 동시 모드 실패를 유발할 가능성이 있다
** user thread 와 동시에 돌기 때문에, GC 타이밍에 새로운 쓰레기가 계속 생겨난다
** 구세대 GC 시작 비율: JDK5 68%, JDK6 92%
** 메모리를 더 많이 요구한다면 동시 모드가 실패 -> STW -> serial old 를 가동하여 구세대 GC
. mark-sweep 으로 인한 파편화 문제

G1, 셰년도어, ZGC 로 넘어가고 있음

=== G1 Collector

Garbage First

* 부분 회수 + region 회수
* 서버용 애플리케이션에 집중한 컬렉터, JDK9 부터 서버 모드용 기본 컬렉터
* 정지 시간 예측 모델 (pause prediction model)
** 목표 정지 시간을 지정하면 그 시간 이상을 넘지 않도록 통제

==== 정지 시간 예측 모델

* heap 어느 곳이든 회수 대상에 포함할 수 있다 - collection set, CSet
* '어느 영역에 쓰레기가 가장 많은가', '회수 시 이득이 어디가 가장 큰가'
* 영역 기반 힙 메모리 레이아웃
** 연속된 heap 을 독립 리전으로 나눔
* 큰 객체를 저장하기 위해 거대 (humongous) 리전 유형
** 리전 용량의 절반보다 큰 객체. 보통은 구세대로 취급
* 리전별 역할을 동적으로 바꿀 수 있고, 연이어 배치될 필요도 없다

각 리전의 쓰레기 누적값 추적

* 값: GC 로 회수할 수 있는 공간의 크기와 회수에 드는 시간의 경험값
* 사용자 설정 값이 허용하는 한도 내에서 **회수 효과가 가장 큰 리전부터 회수**

G1 구현 시 해결해야 했던 주요 문제들

. 객체들의 리전 간 참조 문제를 해결해야 한다
** 모든 리전이 각자의 기억집합을 관리
** 양방향을 기록해야 하므로 구현이 더 복잡, 메모리를 10% ~ 20% 정도 더 사용
. 동시 표시 단계 동안 GC thread, user thread 가 서로 간섭하지 않도록 보장해야 한다
** 각 리전을 위해 TAMS 라는 2개의 포인터 설계
** 공간 일부가 새 객체를 할당하기 위한 공간으로 나뉘고, 새로 생성되는 객체의 주소는 이 두 포인터보다 높은 주소 영역에 할당되어야 한다
** 메모리 회수 속도가 메모리 할당 속도를 따라가지 못한다면 Full GC 를 해야 한다
. 신뢰할 수 있는 정지 시간 예측 모델을 구현해야 한다

이론적 기초는 감소 (decaying) 평균이다

* 리전별 회수 시간, 기억 집합 dirty 카드 개수 등 소요 시간 기록
** 평균, 표준 편차, 신뢰도 등의 통계 분석
* 감소 평균은 '최근'의 평균적인 상태를 더 정확하게 알려준다

==== 단계

. 최초 표시
** 표시, TAMS 포인터 수정 (시작 단계 스냅샷 생성)
** 매우 짧고 마이너 GC 수행 간 끝나므로 일시 정지는 거의 없다
. 동시 표시
. 재표시
. 복사 및 청소
** 통계 기반으로 리전들을 줄 세운 다음 회수 계획을 세움
** 살아남은 객체들을 빈 리전으로 이주 (pause)

G1 의 목표는 지연 시간을 제어하는 동시에 처리량을 최대한 높이는 것

* 정지 시간의 기댓값을 설정할 수 있는 것이 큰 장점. 기본값은 200ms
* 너무 짧으면? 쓰레기가 쌓여간다
* 애플리케이션의 메모리 할당 속도에 맞춰 회수하는 방향으로 변화
** 객체가 버려지는 속도를 컬렉터가 따라갈 수 있다면 완벽하게 동작하는 아이디어이며, 최초 구현이 G1

=== 오늘날의 가비지 컬렉터들

* serial collector 가 serial old 흡수
* PS, parallel old 가 합쳐져 parallel
* CMS -> G1
* ZGC, 셰넌도어