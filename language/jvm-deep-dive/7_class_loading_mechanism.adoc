= 7장. 클래스 로딩 메커니즘

클래스 파일을 로드하는 방법 + 정보를 VM 안에서 활용하는 방법

클래스 로딩, 링킹, 초기화가 모두 프로그램 실행 중에 이루어진다

인터페이스 중심으로 작성 - 실제 구현 클래스를 결정하는 일은 실행 시까지 미룰 수 있다

== 클래스 로딩 시점

* 로딩 -> 검증 (Verification) -> 준비 (Preparation) -> 해석 (Resolution) -> 초기화 (Initialization) -> 사용 (Using) -> 언로딩 (Unloading)
** 링킹: 검증, 준비, 해석
* '로딩'을 정확히 어떤 상황에서 시작해야 하는지 명시하지 않음 - 구현자가 자유롭게 선택
* '초기화' 는 즉시 시작되어야 하는 상황 여섯가지를 규정 - 초기화되어 있지 않은 경우
.. new, getstatic, putstatic, invokestatic 를 만났을 때
.. Class 클래스나 java.lang.Reflect 등 리플렉션 메소드를 사용할 때
.. 클래스 초기화 시 상위 클래스가 ...
.. main 타입 실행
.. 타입 메소드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때
.. 디폴트 메소드를 정의했다면, 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화
* 위 동작을 타입에 대한 능동 참조 (active reference) 라고 함. 그 외는 수동 참조 (passive reference)

클래스를 초기화하려면 상위 클래스를 모두 초기화해야 하지만, 인터페이스 초기화에서는 상위 인터페이스 초기화가 필요 없다 -> 실제 사용될 때 이루어짐

== 클래스 로딩 처리 과정

=== 로딩

이 단계에서는 3가지 작업을 수행해야 한다

. full qualified name 을 보고 해당 클래스를 정의하는 binary byte stream 을 가져옴
** 구현 제약이 없음
** zip, 네트워크, 다른 파일, DB 로딩, 암호화된 파일에서 로딩, ...
. byte stream 으로 표현된 정적인 저장 구조를 메소드 영역에서 사용하는 런타임 데이터 구조로 변환
. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성
** 애플리케이션이 메소드 영역에 저장된 타입 데이터를 활용할 수 있는 통로
** (리플렉션은 heap 에 생성?)

JVM 에 내장된 부트스트랩 클래스 로더를 사용 or 사용자 정의 클래스 로더 사용

* array class 는 JVM 이 직접 메모리에 동적으로 생성
** 배열의 컴포넌트 타입이 참조 타입이면, 재귀적으로 수행하여 컴포넌트 타입을 로딩
*** array class 는 컴포넌트 타입을 로드하는 클래스 로더의 namespace 에 위치
** 참조 타입이 아니면 JVM 은 array class 를 부트스트랩 클래스 로더에 맡김
** 컴포넌트 타입이 참조 타입이 아닌 array class 라면, 모든 클래스와 인터페이스에서 접근 가능

로딩이 끝나면 메소드 영역에 저장. 저장 형식은 자유

로딩과 링킹의 일부 동작은 서로 중첩되어 진행

=== 검증

2가지 목적

. 클래스 파일의 byte stream 에 포함된 데이터가 JVM 명세를 따르는지 확인
. 코드로 변환 시 JVM 의 보안을 위협하지 않는지 확인

바이트코드를 컴파일러가 아니라 직접 생성해낼 수도 있음 +
-> JVM 이 스스로를 보호하기 위한 필수 조치

. 파일 형식 검증
. 메타데이터 검증
. 바이트코드 검증
. 심볼 참조 검증

검증을 생략 (-Xverify:none) 하면 VM 이 클래스를 로딩하는 시간이 제법 줄어든다

=== 준비

* 클래스 변수를 메모리에 할당하고 초기값을 설정하는 단계
* JDK 7 까지는 메소드 영역을 perm gen 에 구현, JDK 8 부터는 클래스 변수가 클래스 객체와 함께 heap 에 저장
* 인스턴스 변수가 아닌 클래스 변수만 할당 - 인스턴스 변수는 객체가 인스턴스화 될 때 heap 에 저장
* 준비 단계에서 클래스 변수에 할당되는 초기값은 헤당 데이터 타입의 제로 값
** puststatic 명령어는 `<clinit>` 에서 수행 - 이런 실제 할당은 초기화 단계에서 이루어짐

=== 해석

* 상수 풀의 심볼 참조를 직접 참조로 대체하는 과정
** 심볼 참조: 몇 가지 심볼로 참조 대상을 설명
** 직접 참조: 포인터, offset or 대상의 위치를 간접적으로 가리키는 핸들
*** VM 에 구현된 메모리 레이아웃과 밀접하게 관련
*** 참조 대상이 VM 의 메모리에 이미 존재해야 한다
* 상수 풀에 있는 심볼 참조를 바로 해석할지 또는 심벌 참조가 실제로 사용될 때까지 기다릴지는 VM 이 결정
* 메소드나 필드에 접근할 수 있는지도 여기서 확인
* 첫 번째 해석 결과를 캐시해두어 반복 해석 회피
* invokedynamic 에서는 해석 결과가 달라질 수 있음
** dynamically computed call site specifier
** 명령어를 실행할 때까지 해석을 수행할 수 없다
* 7가지 타입의 심볼 참조에 대해 수행
** CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_String_info, CONSTANT_MethodHandle_info, CONSTANT_MethodType_info

==== 클래스 또는 인터페이스 해석

아직 해석되지 않은 심볼 참조를 직접 참조로 해석한다면?

. 읽어들일 대상이 배열이 아니면 fully qualified name 을 클래스 로더에 전달하여 로드
. 배열이고 원소 타입이 객체라면 원소 타입을 위와 같은 규칙으로 로드 -> 배열 객체 생성
. 예외가 발생하지 않았다면 유효한 클래스/인터페이스. 접근이 가능한지 추가 확인
** JDK 9 부터는 모듈 간 접근 권한까지 확인

==== 필드 해석

클래스 심볼참조가 먼저 해석되어야 함

. 필드가 클래스 자체에 포함되어 있다면 가리키는 직접 참조를 반환하고 끝냄
. 인터페이스를 구현하고 있다면 재귀로 검색. 발견하면 반환하고 끝냄
. 계층 구조 아래에서부터 상위 클래스를 재귀적으로 검색

==== 메소드 해석

필드 해석과 동일함 +
클래스와 인터페이스의 메소드 심볼 참조는 구분되어 있음 -> 첫 번째 단계에서 클래스 메소드만 고름

==== 인터페이스 메소드 해석

위와 동일

==== 초기화

JVM 이 사용자 클래스에 작성된 자바 프로그램 코드를 실행하기 시작 +
개발자가 프로그램에 기술한 대로 초기화 +
`<clinit>` 은 컴파일러가 자동으로 생성 - 프로그램 동작에 영향을 주는 방식은 알아두는게 좋다

* 모든 클래스 변수 할당과 static 블록의 내용을 취합하여 컴파일러가 자동으로 생성
** 수집 순서는 파일에 등장하는 순서에 영향
* 클래스 생성자와는 다르다
* 부모 클래스의 생성자를 명시적으로 호출하지 않아도 하위 클래스 실행 전 부모 클래스 것부터 먼저 실행
* 부모 클래스에 정의된 static 블록이 자식 클래스보다 먼저 실행
* 클래스나 인터페이스에 반드시 필요한 것은 아니다 - static 블록이 없거나 값 할당이 없다면 생성하지 않을 수 있다
* 인터페이스는 static 블록은 불가능하지만 변수에 초기값을 할당 할 수 있다
** 인터페이스는 부모 인터페이스의 것을 먼저 실행할 필요가 없다
* JVM 은 멀티스레드 환경에서 적절히 동기화되도록 해야 한다 - 한 스레드만 수행, 나머지는 대기
** 오래 걸리면 스레드가 장시간 블록될 수 있다

== 클래스 로더

필요한 클래스를 얻는 방법을 애플리케이션이 정할 수 있게 +
fully qualifed name 을 보고 해당 클래스를 정의하는 binary byte stream 가져오기를 VM 외부에서 수행하도록

클래스 계층 분할, OSGi, hot deploy, code encryption 등에서 사용

=== 클래스와 클래스 로더

* 각 클래스 로더는 독립적인 클래스 이름 공간을 가진다
** 서로 다른 클래스 로더로 읽어 들였다면, 같은 VM 이고 똑같은 클래스 파일로 로드했어도 다른 클래스로 인식

=== 부모 위임 모델

JVM 관점에서는 2가지만 존재 (JVM 부트스트랩 클래스 로더 or abstract java.lang.ClassLoader 를 상속한 구현체)

자바 개발자 관점에서는 3계층

* 부트스트랩 클래스 로더
* 확장 클래스 로더 (sun.misc.Launcher$ExtClassLoader)
** 시스템 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할
** 클래스 라이브러리를 확장하는 메커니즘
* 애플리케이션 클래스 로더 (sun.misc.Launcher$AppClassLoader)
** getSystemClassLoader()

JDK 8 까지는 3개가 협력하여 로딩, 필요시 사용자 정의 추가 +
'부트스트랩 <- 확장 <- 애플리케이션 <- 사용자 정의' 순서로 delegate +
상위 클래스 로더로 우선 요청을 위임, 대상이 아니라고 판단되면 하위로 넘김 +

=== 부모 위임 모델에 대한 도전

. ClassLoader 이전의 사용자들
. 사용자 코드를 거꾸로 다시 호출해야 하는 기본 타입이 존재하는 경우
** 다른 업체에서 구현해 classpath 에 배포한 SPI 를 호출 -> 부트스트랩 클래스 로더는 바깥 코드를 인식하고 로드하는게 불가능
** java.lang.Thread.setContextClassLoader 를 추가 -> SPI 서비스 코드 로드 -> 부모가 자식 로더에 요청
** 공급자가 둘 이상이면? -> JDK 6 의 java.util.ServiceLoader 클래스와 META-INF/services 에 구성 정보 제공하여 보완
. 동적인 프로그램 능력 - code hot swap, module hot deploy
** 구성 요소를 런타임에 교체하거나 추가

==== OSGi

OSGi 가 클래스 로더를 이용하 hot deploy 를 구현하는 방법 - 독자적인 클래스 로더 매커니즘 +
모듈 == 번들, 번들 각각은 자체 클래스 로더를 가짐 +
번들을 교체할 때는 hot code 교체를 위해 자체 클래스 로더와 함께 교체

. java.*: 부모 클래스 로더에 위임
. OSGi 프레임워크의 부트 위임 목록에 포함된 클래스: 부모 클래스 로더에 위임
. 위에 해당되지 않는다면 - import 목록 클래스들을 export 된 클래스가 속한 번들 클래스 로더에 위임
. 위에 해당되지 않는다면 - 현재 번들의 classpath 를 찾아 자체 클래스 로더로 로드
. 위에 해당되지 않는다면 - 대상 클래스가 자체 fragment 번들에 있는지 확인
. 위에 해당되지 않는다면 - 동적 import 목록에서 번들을 찾아서 해당 번들의 클래스 로더에 위임
. 실패

자바 표준화에서 밀려나긴 했음. hot deploy 이점을 얻는 대신 복잡성이 크게 증가

== 자바 모듈 시스템

'자유롭게 설정 가능한 캡슐화 격리 메커니즘' 을 위해 클래스 로딩 아키텍처를 적절히 변형

. requires: 다른 모듈에 대한 의존성 목록
. exports: 다른 모듈에서 사용할 수 있는 패키지 목록
. open: 다른 모듈에서 리플렉션 API 로 접근할 수 있는 패키지
. uses: 현재 모듈이 사용할 서비스 목록
. provides: 다른 모듈에 제공하는 서비스 목록

필요한 타입이 classpath 에 없더라도 처음 사용할 때 예외 보고 +
-> JDK 9 부터는 의존하는 다른 모듈을 명시할 수 있어서 필요한 의존성이 있는지 애플리케이션 개발 단계에서 확인 가능

public 타입에 접근할 수 있던 문제도 해결 - 외부 모듈에 공개할 타입을 명시

=== 모듈 호환성

* modulepath 개념 도입: 라이브러리 위치에 따라 모듈인지 전통적인 JAR 패키지인지 결정
* JAR 파일을 classpath 에 배치하면 module-info.java 를 포함하더라도 JAR 패키지로 취급
* classpath 상의 JAR 파일용 접근 규칙: 모든 JAR 파일, 기타 리소스 파일은 자동으로 unnamed module 로 패키징된 것으로 간주 - 격리 효과가 없음
* modulepath 상의 모듈용 접근 규칙: named module 은 자신의 의존성 정의에서 명시한 모듈과 패키지에만 접근 가능
** unnamed module 의 모든 내용은 named module 에서 볼 수 없다
* modulepath 상의 JAR 파일용 접근 규칙: 기존 JAR 파일을 modulepath 에 넣어두면 자동으로 모듈이 된다
** module-info.class 파일이 없는 모듈은 모든걸 export - 기존 방식의 JAR 는 모든 모듈에서 접근할 수 있다

모듈 정의에 버전 번호를 부여할 수 없음 - 다중 버전, 버전 선택 기능을 지원하지 않음

자바 모듈 시스템에서는 런타임에 여러 버전이 공존하면서 동적으로 교체, 배포하는 건 거의 불가능하다 +
JVMTI (Instrumentation) 을 이용하여 메소드 본문 hot swap 는 활용

=== 모듈화 시대의 클래스 로더

* 확장 클래스 로더 -> 플랫폼 클래스 로더로 대체
* 플랫폼 클래스 로더와 애플리케이션 클래스 로더가 java.net.URLClassLaoder 로 부터 파생되지 않음
** 기존 상속 관계나 URLClassLoader 에 직접 의존하는 프로그램은 JDK 9 이상에서는 충돌할 수 있음
** jdk.internal.loader.BuiltinClassLoader 에서 파생
* 클래스 로딩 위임 관계 변화
** 위임 전에 해당 클래스가 특정 시스템 모듈에 속하는지 확인 -> 속한다면 해당 모듈을 담당하는 모듈에 위임
