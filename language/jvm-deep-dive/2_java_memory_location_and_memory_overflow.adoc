= 2. 자바 메모리 영역과 메모리 오버플로

VM 의 메모리 관리 방식을 이해하지 못하면 문제 해결이 어렵다

== 런타임 데이터 영역

* 필요한 메모리를 몇 개의 데이터 영역으로 나눠서 관리 - 각각 목적, 생성/삭제 시점이 있음

=== 프로그램 카운터 (PC)

* **Thread 의 '바이트코드 줄 번호 표시기'**
** 바이트코드 인터프리터가 이 카운터의 값을 바꿔, 다음에 실행할 바이트코드 명령어를 선택
** exception handling, thread recovering, ...
* Thread 각각에 고유한 PC 필요. (CPU 코어를 여러 Thread 가 교대로 사용)
** Thread private memory
* 기타: Thread 가 네이티브 메소드 실행 시 값은 Undefined

=== 자바 가상 머신 스택

* 이것도 Thread private 하며 연결된 Thread 와 운명을 같이 함
* **자바 메소드를 실행하는 Thread 의 메모리 모델을 설명**
** 스택 프레임 - 지역 변수 테이블, 피연산자 스택, 동적 링크, 메소드 반환값 등
* 지역 변수 테이블에는
** 컴파일 타임에 알 수 있는 다양한 primitive 타입, 객체 참조, 반환 주소 타입을 저장
** 32비트의 지역 변수 슬롯, double 같은 경우는 2개를 차지
** 필요한 데이터 공간은 컴파일 과정에서 할당

==== 명세에 있는 2가지 오류

* StackOverflowError: Thread 가 요청한 스택 깊이가 허용 범위를 넘으면
* OutOfMemoryError: 스택 용량을 동적 확장 가능한 VM 에서 여유 메모리가 충분하지 않으면

=== 네이티브 메소드 스택

네이티브 메소드를 실행할 때 사용되는, 가상 머신 스택과 유사한 역할

=== 자바 힙

모든 Thread 가 공유

* 객체 인스턴스를 저장, 거의 모든 객체 인스턴스가 여기 할당
* 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 GC 힙이라고도 불림
** 세대별 컬렉션 이론 (generational collection theory) 을 기초로 설계
** 신세대, 구세대, 영구 세대, 에덴 공간, 생존자 공간
** 자바 가상 머신 명세에는 이야기가 없다
* 자바 힙을 작게 구분하는 목적: 메모리 회수와 할당을 더 빠르게 하기 위함
* 물리적으로 떨어진 메모리에 위치해도 상관없지만 논리적으로는 연속되어야 한다

=== 메소드 영역

모든 Thread 가 공유

* VM 이 읽은 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시
** non-heap 이라고 부르기도
* 영구 세대와는 다르다 - 메소드 영역은 GC 수집 볌위
** 핫스팟 가상 머심 개발 팀이 메소드 영역을 영구 세대에 구현
*** 영구 세대 최대 크기를 넘어서서, VM 에 따라 성능이 달라지는 메소드가 생김 (String::intern)
* JDK7 부터 영구 세대 -> 자바 힙으로 옮기고, JDK8 부터는 네이티브 메모리에 metaspace 를 구현 옮김
* 회수 대상: 상수 풀, 타입이기 떄문에 회수 효과가 매우 작다

=== 런타임 상수 풀

* 클래스 버전, 필드, 메소드, 인터페이스 등 클래스 파일에 포함된 설명 정보 + 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조

=== 다이렉트 메모리

* JDK1.4 에서 NIO 도입 - 채널과 버퍼 기반 I/O 메소드 소개
** 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리 이용
** 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 됨 -> 일부 시나리오에서 성능 개선
* 자바 힙 크기 제약과는 무관하지만, 하부 메모리를 넘어설 수는 없다
** 넘어서면 동적 확장 시도 시 OOM 발생

== 핫스팟 가상 머신에서의 객체 들여다보기

만들어지는 시기, 저장되는 상세 구조, 접근 방식 +

=== 객체 생성

==== new 명령에 해당하는 바이트코드를 만나면?

. **매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인**
** 심벌 참조가 뜻하는 클래스가 로딩, 해석 (resolve), 초기화 (initialize) 되었는지 확인
** 준비되지 않은 클래스라면 로딩부터 수행
** 로딩된 클래스라면 새 객체를 담을 메모리 할당
* 자바 힙은 규칙적이지 않으므로, 가용 메모리 블록들을 목록 (free list) 으로 따로 관리
** 객체 인스턴스를 담기에 충분한 공간을 찾아 할당 후 목록 갱신
. **여유 메모리의 시작 포인트 위치를 수정** - thread safe 하지 않음
** 두 가지 방법
.. 메모리 할당을 동기화 - CAS, 실패 시 재시도
.. Thread 마다 다른 메모리 공간 할당 - TLAB
*** 각 Thread 가 할당 받아 부족해지면 새로 버퍼 할당
. **메모리 할당이 끝나면, 할당받은 공간을 0으로 초기화**
** 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유 - 각 데이터 타입에 해당하는 0 값을 담고 있게 됨
* 다음으로 '각 객체에 필요한 설정' 을 해준다
** 객체 헤더에 저장: 어느 클래스의 인스턴스인지, 클래스의 메타 정보를 어떻게 찾는지, 이 객체의 해시 코드는 무엇인지, GC 세대 나이는 얼마인지
. **`<init>()` 메소드 실행**
** 개발자의 의도대로 여러 자원과 상태정보 구성

[NOTE]
====
컴파일러는 new 키워드를 발견하면 -> 바이트코드 명령어닌 `new` 와 `invokespecial` 로 변환 +
`new` 는 메모리 할당, `invokespecial` 은 `<init>()` 메소드 호출 담당
====

=== 객체의 메모리 레이아웃

세 부분으로 나눠 힙에 저장 (객체 헤더, 인스턴스 데이터, 정렬 패딩)

==== 객체 헤더

. mark word: 객체 자체의 런타임 데이터
** 해시 코드, GC 세대 나이, 락 상태 플래그, Thread 가 점유하고 있는 lock 등
** 32비트 or 64비트
** 데이터 구조는 동적으로 의미가 달라진다
** 32비트 VM d에서 25비트(객체 해시 코드) + 4비트(객체 세대 나이) + 1비트(0 고정) + 2비트(락 플래그 저장)
. klass word: 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터
** 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다
** 배열의 경우 베열 길이도 헤더에 저장 (klass word 다음)

==== 인스턴스 데이터

* 객체가 실제로 담고 있는 정보
** 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드
** 기본 할당 전략에서는 길이가 같은 필드들은 항상 같이 할당되고 저장
** 필드 길이가 같다면 부모 클래스에서 정의된 필드가 자식 클래스의 필드보다 앞에 배치

==== 정렬 패딩 (alignment padding)

* 객체의 시작 주소는 반드시 8바이트의 정수배여야 한다
* 인스턴스 데이터가 조건을 충족하지 못하는 경우에만 채운다

=== 객체에 접근하기

객체에 접근하는 방법은 VM 에서 구현하기 나름이며, **handle** or direct point 를 사용해 구현한다

==== handle

* 자바 힙에 핸들 저장용 풀이 별도로 존재
* 참조에 객체의 핸들 주소가 저장 - 핸들에는 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보
* 장점: 참조에 '안정적인' 주소가 저장
** GC 과정에서 객체의 위치가 바뀌어도 참조 자체는 손댈 필요가 없다
** 핸들 내의 인스턴스 데이터 포인터만 변경하면 된다

==== direct pointer

* 자바 힙에 위치한 객체에서 인스턴스 데이터 + 타입 데이터에 접근하는 길도 제공해야 한다
* 장점: 속도. 핸들을 경유하는 오버헤드가 없다
* HotSpot 은 direct pointer 방식을 사용

== 실전: OOM 에러

=== Java heap

* `-XX:+HeapDumpOnOutOfMemoryError`: 메모리가 오버플로 됐을 때 VM 이 예외 발생 시점의 헵 모므리 스냅샷을 파일로 저장
* 오버플로를 일으킨 객체가 꼭 필요한 객체인가 확인이 필요
** 메무리 누수인지? 오버플로인지?
** 누수된 객체까지 어떤 참조 경로가 존재하고, 어느 GC root 와 연결되어 GC 가 되지 못했는지 찾아보기

=== VM stack & natvie method stack

* HotSpot VM 은 VM 스택과 네이티브 메소드 스택을 구분하지 않는다
** `-Xss` 매개 변수로만 스택 크기 변경 가능

=== 메소드 영역과 런타임 상수 풀 오버플로

* `String::intern`: 네이티브 메소드. 문자열 상수 풀에 똑같은 문자열이 이미 있다면 기준 참조 반환, 없으면 새로 추가 후 반환
* JDK6 까지는 영구 세대에 할당 (`-XX:PermSize`, `-XX:MaxPermSize`)
* JDK7 에서는 자바 힙
* JDK8 에서는 메타스페이스
** 보호용 매개 변수
** `-XX:MaxMetaspaceSize` 최대 크기
** `-XX:MetaspaceSize` 초기 크기
** `-XX:MinMetaspaceFreeRatio` GC 후 가장 작은 메타스페이스 여유 공간 비율

=== 네이티브 다이렉트 메모리 오버플로

* `-XX:MaxDirectMemorySize` or 디폴트 (`-Xmx`)
* p91