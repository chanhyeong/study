= 13장. 스레드 안전성과 락 최적화

== 스레드 안전성

[quote]
----
여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서 객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면, "그 객체는 스레드 안전하다"라고 말한다.

* 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 없다.
* 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.
----

* 여러 스레드가 이용할 수 있는 공통 기능을 제공하려면 코드가 thread-safe 해야 함
* 호출자는 멀티스레드 환경인지 특별히 고려하지 않아도 안전하게 사용할 수 있어야 한다

=== 자바 언어의 스레드 안전성

공유 데이터의 '안전함의 정도' 에 따라 여섯 단계로 분류

* 불변, 절대적 스레드 안전, 조건부 스레드 안전, 스레드 호환, 스레드 적대적

==== 불변

* 아무런 안전장치 없이도 스레드 안전
* 기본 데이터 타입은 final 로 정의되기만하면 불변성 보장
* 자신의 상태 (== 필드) 를 수정하지 않도록 해야 함
* array 타입, java.lang.Number 하위 클래스도 불변

==== 절대적 스레드 안전

* 위의 '스레드 안정성 정의' 를 충족
* 모든 메소드에 synchronized 가 붙어있더라도 호출자가 추가로 동기화할 필요가 '절대로' 없는 건 아님
** 코드 13-2 의 경우 ArrayIndexOutOfBoundsException 이 발생할 수 있음

==== 조건부 스레드 안전

* 일반적으로 '스레드 안전' 이라고 하는 수준
* '단일한 작업 (메소드)' 을 별도 보호 조치 없이 안전하게 수행

==== 스레드 호환

* 객체 자체는 스레드로부터 안전하지 않지만, 호출자가 적절히 조치하면 멀티스레드 환경에서도 안전하게 사용할 수 있음

==== 스레드 적대적

* 호출자가 동기화 조치를 취하더라도 멀티스레드 환경에서 안전하게 사용할 수 없음
* Thread suspend(), resume()

=== 스레드 안전성 구현

코드 작성법과 VM 의 동기화와 락

==== 상호 배제 (mutual exclusive) 동기화

* 동기화: 공유 데이터에 여러 스레드가 접근하려는 상황에서, 단 하나의 스레드만 데이터를 사용할 수 있음

==== synchronized 키워드 (monitorenter, monitorexit)

* lock 으로 사용할 객체를 참조 타입 매개 변수로 받음
* 객체를 명시하지 않으면 키워드가 위치한 메소드가 무엇이냐에 따라 객체 선택
** 인스턴스 메소드: 해당 객체
** 정적 메소드: 클래스 (Class<?>) 객체
* <자바 가상 머신 명세>
** monitorenter 는 lock 을 얻으려 시도, 잠겨있지 않거나 이미 소유하고 있다면 카운터 값을 1 증가.
** monitorexit 는 카운터 값을 1 감소. 카운터가 0 이 되면 lock 해제
** lock 을 얻지 못한 스레드는 락을 해제할 때까지 블록
** 결론
*** 같은 스레드라면 synchronized 로 동기화된 블록에 다시 진입할 수 있음 - 이미 소유하면 block 되지 않음
*** 다른 스레드의 진입을 무조건 차단
* 매우 주의해서 사용해야 한다
** lock 을 소유 == 비용 측면에서 상당히 무거운 작업
** 사용자 모드와 커널 모드 사이의 전환을 피할 수 없음 - 프로세서 시간을 많이 소모

===== java.util.concurrent.locks.Lock 인터페이스

* 개발자가 nonblock 구조의 상호 배제 동기화 구현 가능
* ReentrantLock - synchronized 와 같이 재진입 가능한 lock
** 대기 중 인터럽트, fair lock, 둘 이상의 조건 지정 등 추가 기능 제공
** 대기 중 인터럽트: lock 해제가 길어지면 포기하고 다른 일을 함
** fair lock: 대기하는 스레드가 많을 때 시도한 순서대로 lock 을 얻음
*** synchronized 는 unfair lock
** 둘 이상의 조건 지정: 여러 개의 Condition 객체와 연결 지을 수 있음

===== 저자가 synchronized 를 권장하는 이유

* 자바 구문 수준의 동기화 수단이며 매우 명확하고 간결
* Lock 은 finally 에서 해제해야 함
* 동기화 최적화는 JVM 에 맡기는게 유리하다

==== non-blocking 동기화

* blocking 동기화 (상호 배제 동기화) 는 thread pause, awake 로 인한 성능 저하
** 비관적 동시성 전략
** user mode -> kernel mode 전환, lock 카운터 계산, 블록된 스레드를 깨워야 하는지 확인...
* 낙관적 동시성 전략: 충돌 감지를 기반으로 작동
** 일단 작업을 수행하고 충돌이 발생하면 보완
** 경합하는 공유 데이터가 없을 때까지 계속 재시도
* '하드웨어 명령어 집합의 발전' 필요 - 작업 진행 & 충돌 감지를 한 명령어처럼 원자적으로 수행
** TAS, FAA, Swap, CAS, LL/SC

===== CAS

* 메모리 위치 (V), 예상하는 이전 값 (A), 새로 설정할 값 (B)
* V 의 값이 A 와 같으면 B 로 갱신, 아니면 수행 안 함
** 갱신 여부와 상관 없이 A 반환
* JDK5 부터 sum.misc.Unsafe compareAndSwapInt(), compareAndSwapLong()
** JIT 컴파일로 메소드 호출을 없애고 프로세서에 맞는 CAS 명령어로 대체
* A -> B -> A 문제를 해결하려면 상호 배제 동기화를 이용하는게 맞다

==== 동기화가 필요 없는 메커니즘

* 아무런 장치의 도움 없이도 스레드 안전성을 보장할 수 있는 경우
** 태생부터 스레드에 안전한 코드
. 재진입 코드: 순수 코드
** 아무 때나 끼어들어 다른 코드를 수행하고 와도 상관없는 코드 - 오류도 없고 결과 영향도 없는
** 필요한 모든 정보를 매개 변수로 받음
** 메소드의 반환값을 예측할 수 있고 같은 입력엔 같은 결과 반환
. ThreadLocal 저장소
** 공유 데이터의 visibility 를 동일 스레드로 제한 - 동기화가 필요 없음
* 여러 스레드가 같은 변수에 접근해야 한다면 volatile 를 사용할 수 잇음

== 락 최적화

적응형 스핀, 락 제거, 락 범위 확장, 경량 락, 편향 락 +
데이터를 효율적으로 공유 + 스레드 사이 경합 문제 해결 -> 프로그램 실행 효율을 높이기

=== spin lock 과 adaptive spin

* spin lock: 스레드를 pause 하지 않고 lock 이 해제될 때까지 spin (루프 돌기)
** 스레드 전환 부하는 없애지만 프로세서 시간을 소비. lock 이 잠시만 잠겨 있을 때 좋음
** JDK6 부터 기본 활성화. 최대 10회
* adaptive spin: lock 의 이전 spin 시간과 lock 소유자의 상태에 따라 결정
** 100회까지 문턱값을 늘려봄

=== 락 제거

* 런타임에 데이터 경합이 일어나지 않는다고 판단되면 JIT 컴파일러가 락을 제거

=== 락 범위 확장

* 연이은 다수의 작업이나 순환문에서 똑같은 lock 객체 반복 사용
** 이 경우 lock 의 유효 범위를 해당 작업 전체로 늘림
** 빈번한 상호 배제 동기화를 방지

=== 경량 락

* OS mutex 를 사용한 기존 lock (중량 lock) 보다 가벼움
* 스레드 경합을 없에 성능 저하를 줄임
* 객체 헤더는 두 부분으로 나뉜다
** 첫 번째: 객체 자신의 런타임 데이터 (hash code, GC gen age 등)
*** mark word. 경량 락과 편향 락 구현의 핵짐
** 두 번째: 메소드 영역의 데이터 타입 데이터를 가리키는 포인터
** 객체 헤더는 효율적으로 써야 한다
** mark word 는 최소한으로 사용 - 길이가 정해지지 않은 동적 크기. 객체 상태에 따라 자신의 저장 공간 재사용
. lock 객체가 잠겨 있지 않다면 ('01') 현재 스레드의 스택 프레임에 lock 레코드 생성
** lock 레코드 == 현재 mark word 의 복사본
. CAS 연산으로 lock 객체의 mark word 를 lock 레코드 포인터로 변경
** lock flag 는 '00' 으로 변경
** 실패 시 현재 스레드의 스택 프레임인지 확인
*** 성공 시 계속 실행. 아니면 다른 스레드가 선점
. 둘 이상의 스레드가 같은 lock 을 두고 경합한다면 경량 락은 무의미. '10' 으로 변경하여 중량 락으로 확장
. 해제 과정도 CAS 연산으로 수행

'대부분의 락은 실제로는 경합하지 않는다' 는 경험 법칙에 의거하여 동기화 성능 개선 가능 +
경합 할생 시 CAS 연산 부하로 인해 중량 락보다 느려질 수 있음

=== 편향 락 (최신 JDK 에서는 제거됨)

데이터 동기화 장치를 제거하여 프로그램 실행 성능을 높이는 최적화 기법 +
CAS 연산조차 없앤다

* '편향': 마지막으로 썼던 스레드가 lock 을 찜해둔다
** 다른 스레드가 락을 가져가지 않으면 직전 사용한 스레드는 동기화할 필요가 없음