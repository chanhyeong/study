= 5장. 최적화 사례 분석 및 실전

기존 하드웨어와 소프트웨어를 유지하면서 문제 해결 or 개선

== 대용량 메모리 기기 대상 배포 전략

=== 이슈

* 12GB heap size
* 웹 사이트가 장시간 응답하지 않는 일이 빈번
* 원인: GC (parallel GC)
** 12GB 에 달하는 힙 메모리를 전체 GC 하기 위해 15초까지 정지
** **설계 상 파일을 사용자 요청 시 페이지를 디스크 -> 메모리로 읽어 들임**
* heap 을 너무 크게 잡아서 회수하고 재활용하는 데 너무 오래 걸림
** VM 하나가 거대한 heap 메모리 관리

=== 해결 방안

. 섀년도어, ZGC 등 지연 시간 통제를 목표로 하는 컬렉터 이용
. PGC 를 유지하면서 하는 방법 - 전체 GC 빈도를 가능한 낮게, 적어도 사용자가 이용하는 도중에는 않게
** 구세대가 안정되어야 함 == 너무 오래 생존하는 객체가 적어야 함
** 세션이나 적역 수준으로 오래 살아남는 개체가 매우 적어야 함
. VM 여러 개를 띄워 논리적인 클러스터 구성
** LB 를 두어 reverse proxy 로 분산
** 단점
*** 노드들이 전역 자원에 대해 경합
*** connection pool 등의 resource pool 을 효율적으로 활용이 어려움
*** 로컬 캐시를 많이 이용한다면 메모리 낭비

=== 최종 해결

* VM 여러 개를 띄워 논리적인 클러스터 구성
* PGC -> CMS 로 변경

== 클러스터 간 동기화로 인한 메모리 오버플로우

=== 이슈

* 글로벌 캐시 구축 -> 메모리 오버플로우가 가끔 발생
** 수많은 JBossCache NAKACK 객체 발견 (JGroups)
** 전송 실패 시 재전송을 위해 데이터를 제대로 수신했는지 확인할 때까지 메모리에 보관
* 보안용 글로벌 필터 -> 클러스터 노드들 사이의 네트워크 통신을 빈번하게 일으킴
** 전송량을 처리하지 못해 재전송된 데이터가 메모리에 쌓이다가 오버플로우

=== 해결 방안

* write (== 네트워크 통신) 를 줄이기

== 힙 메모리 부족으로 인한 오버플로 오류

=== 이슈

* GC 가 자주 있지 않고, 메모리가 모두 안정적인 상태에서 메모리 오버플로우 발생
* 전체 2GB, heap 1.6GB 사용 중인 상태에서, 다이렉트 메모리는 heap 에 속하지 않기 때문에 0.4GB 밖에 사용 불가
** 다이렉트 메모리도 GC 대상이지만, 공간이 부족해도 컬렉터에 알리지 못함
** 구세대가 차서 전체 GC 가 수해오디길 기다려야 함

== 시스템을 느려지게 하는 외부 명령어

=== 이슈

* 동시성 스트레스 테스트를 수행하면 응답 속도가 지나치게 느려짐
* fork 시스템 콜이 범인 - 새로운 프로세스 생성 명령어
* 요청 각각이 외부 shell script 를 실행하도록 작성
** Runtime.getRuntime().exec() 를 사용 -> 자원을 매우 많이 소모 (프로세스 생성 비용)
... 현재 VM 과 똑같은 환경 변수 설정을 공유하는 프로세스 복사
... 새로운 프로세스에서 외부 명령 실행
... 프로세스 종료

=== 해결

* 필요한 정보를 자바 API 로 가져옴

== 서버 VM 프로세스 비정상 종료

=== 이슈

* VM 프로세스가 갑자기 닫히는 일이 빈번
** `hs_err_pid###.log` 파일만 남기고 사리짐
* 외부 연결 시 제때 응답해주지 않자 대기 중인 스레드와 소켓 연결이 많아짐
** 한계를 넘어서 VM 프로세스가 비정상 종료

=== 해결

* 비동기 호출 -> Pub/Sub 메시지 큐로 변경

== 부적절한 데이터 구조로 인한 메모리 과소비

* RPC 서버, ParNew + CMS 컬렉터 조합

=== 이슈

* 데이터를 분석하기 위해 10분 단위로 80MB 크기의 파일을 메모리에 올림
** 100만개 이상의 HashMap 을 만들어냈다
** 분석 동안에는 에덴이 빠르게 채워져서 GC 가 일어나지만 마이너 GC 가 일어난 후에도 객체가 대부분 살아있음
* ParNew 는 복사 알고리즘 사용: 대부분의 객체가 죽어야 좋다
** 생존한 객체가 매우 많다면 생존자 공간으로 복사. 객체 참조까지 정확하게 관리 (무거운 작업)

=== 해결 방안

. 첫 번째 마이너 GC 후 신세대에서 살아남은 객체를 바로 구세대로 이동
** 죽은 객체 회수를 다음 Major GC 에 맡기기
. 프로그램 자체를 고치기
** `HashMap<Long, Long>` 은 효율이 좋지 않다 (-> 아마 array 로 교체?)

== 윈도우 가상 메모리로 인한 긴 일시 정지

=== 이슈

* GC 가 오래 걸려서 데이터가 섞임
** 컬렉션 준비 단계에서 실제 시작까지가 시간을 잡아 먹음
* 프로그램을 최소화하면 메모리 사용량이 줄어듦
** 작업 메모리가 디스크로 스왑, GC 를 하려면 스왑된 데이터를 메모리로 다시 읽어야 함

=== 해결

* -Dsun.awt.keepWorkingSetOnMinimize=true 옵션 추가

== 안전 지점으로 인한 긴 일시 정지

=== 이슈

* -XX:MaxGCPauseMillis=500 으로 설정했으나 3초 이상 길어지는 일이 자주 발생

[source]
----
[Times: user=1.51 sys=0.67, real=0.14 secs]
time: ..: Total time for which application threads were stopped: 2.2645818 seconds
----

* user, sys: processor (코어 하나에서 실행된) 시간. real: clock (현실) 시간
* GC 에는 0.14 초만 걸렸지만 user thread 일시 정지는 2.26 초나 걸림
** -XX:+PrintSafePointStatistics, -XX:PrintSafepointStatisticsCount=1 옵션 추가

[source]
----
vmop [threads: total initially_running wait_to_block]
..: ForceAsyncSafepoint [931 1 2]
[time: spin block sync cleanup vmop] page_trap_count
[      2255 0     2255 11      0   ] 1
----

* thread 2개가 느려서 장시간 대기 (2255 ms)
* -XX:SafepointTimeout, -XX:SafepointTimeoutDelay=2000 옵션 추가

==== 안전 지점 - "프로그램을 장시간 실행하는 특성이 있는가?"

* 메소드 호출, loop 점프, 비정상적인 점프는 모두 안전 지점이 될 수 있음
** HotSpot 에서는 안전 지점이 너무 많아지는 부담을 줄이고자 loop 를 평가하여 최적화
** int 등 범위가 작은 타입을 루프 변수로 사용하면 안전 지점으로 설정되지 않음 (counted loop)
** long 등 큰 타입은 uncounted loop
* loop 본문을 한 번 수행하는 시간 자체가 너무 길다면 counted loop 라도 오래 걸림

=== 해결 방안

* -XX:+UseCountedLoopSafepoints 옵션 추가
** JDK8 에서는 VM 을 비정상 종료 시키는 버그가 있어서 불가능

=== 해결

* HBase connection timeout 초기화 기능이 문제여서 loop 변수 타입을 long 으로 변경해주었다

== 실전: 이클립스 구동 시간 줄이기

. 최신 JDK 버전 사용하기
. 클래스 로딩 시간 최적화
** 로딩 시 안전한 바이트코드인지 검사하는 단계 스킵 `-Xverify:none`

=== 컴파일 설정 최적화에서 남겨볼만한 부분

* 컴파일 시간: hot code 를 JIT 컴파일러가 컴파일하는 데 쓴 시간
* 크로스 플랫폼 지원을 위해 바이트코드로 컴파일하여 .class 로 변환 -> VM 이 .class 를 해석하여 바이트코드 실행
* JDK 1.2 부터는 두 가지 JIT 컴파일러 제공
** HotSpot: 일정 횟수 이상 호출되는 메소드를 hot code 로 분류하여 JIT 컴파일러에 넘기고
** JIT 컴파일러가 해당 코드를 런타임에 네이티브 코드로 변환하여 수행 속도 개선
** **프로그램을 오래 실행할수록 코드가 꾸준히 최적화되어 점점 빨라진다**
* 동적 컴파일은 프로그램의 정상적인 실행 시간에 영향을 준다
** 실행 도중에도 컴파일 자체에 자원을 사용해야 함
* JIT 컴파일을 억제하는 -Xint 옵션 -> 순수 인터프리트
** 컴파일 시간은 0 으로 떨어지지만 총 구동 시간이 증가 -> JIT 컴파일러 혜택이 사라져서 전반적인 실행 속도가 급격히 느려짐