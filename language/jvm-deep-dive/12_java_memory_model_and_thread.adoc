= 12장. 자바 메모리 모델과 스레드

VM 이 멀티스레딩을 구현하는 방법 + 스레드들이 데이터를 공유하거나 경합하며 발생하는 다양한 문제외 해결책

== 하드웨어에서의 효율과 일관성

* 메모리 I/O 는 없애기 힘듦 -> 캐시를 둠 -> 캐시 일관성 (cache coherence) 문제 발생
** 공유 메모리 멀티프로세서 시스템: 프로세서 각각이 자신만의 캐시를 가지고 메인 메모리 공유 - 프로세서별 캐시 데이터는 다를 수 있음
* 일관성 문제 해결 -> 메모리 모델: 특정 프로토콜을 이용하여 특정 메모리나 캐시를 읽고 쓰게
* 비순차 실행 최적화 (out-of-order execution optimization) 로도 컴퓨팅 능력 향상 가능
** 프로세서의 실행 순서가 입력 순서와는 다를 수 있음
** JIT 컴파일러는 명령어 재정렬 (instruction reordering) 최적화 수행

== 자바 메모리 모델

* 다양한 하드웨어와 OS 의 메모리 모델로부터 자바 프로그램을 보호하고자 자바 메모리 모델을 따로 정의
** 메모리를 일관된 방식으로 이용

=== 메인 메모리와 작업 메모리

* 자바 메모리 모델의 주 목적: 프로그램에서 다양한 변수에 접근하는 규칙 정의
** 인스턴스 필드, 정적 필드, 배열 객체의 원소
** VM 실행 엔진과 JIT 컴파일러의 성능 최적화를 막지 않음
* 모든 변수는 메인 메모리에 저장된다고 규정
* 각 스레드는 작업 메모리를 가짐
** 사용하는 변수가 저장된 메인 메모리의 복사본
** 변수 read/write 는 작업 메모리에서 수행 - 메인 메모리에 있는 변수에 직접 접근 불가
** thread 끼리는 개별 작업 메모리 변수에 직접 접근 불가 - 메인 메모리를 거쳐서 전송

=== 메모리 간 상호 작용

메인 메모리 -> 작업 메모리로 변수 복사, 작업 메모리 -> 메인 메모리 동기화 방법을 8가지로 정의 +
JVM 은 각 연산이 원자적임을 보장

* 잠금 (lock): 메인 메모리 변수를 특정 스레드만 사용할 수 있게
* 잠금 해제 (unlock): 잠겨 있는 변수 해제
* 읽기 (read): 적재 연산을 위해 메인 메모리 변숫값을 특정 스레드의 작업 메모리로 복사
* 적재 (load): 작업 메모리의 변수에 복사해서 넣음
* 사용 (use): 작업 메모리의 변수를 실행 엔진으로 전달. 변수를 사용하는 명령어를 만날 때마다 실행
* 할당 (assign): 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
* 저장 (store): 작업 메모리의 변수를 메인 메모리로 전송
* 쓰기 (write): 메인 메모리의 변수에 기록

복사: 읽기 -> 적재. 동기화: 저장 -> 쓰기 +
순서대로만 수행하고 바로 이어서 수행될 필요는 없음

* 읽기와 적재, 저장과 쓰기는 단독으로 수행될 수 없음
* 최근 할당 연산을 버릴 수 없음
* 작업 메모리의 데이터를 할당 없이 메인 메모리로 동기화 할 수 없음
* 변수는 메인 메모리에서만 생겨날 수 있음
** 작업 메모리에 있는 변수를 곧바로 사용할 수 없음 - 할당과 적재가 이루어져야 함
* 변수는 한 번에 한 스레드만 잠글 수 있음
* 변수를 잠그면 작업 메모리의 변숫값은 지워짐
* 잠겨있지 않은 변수나 다른 스레드가 잠근 변수는 잠금 해제 불가
* 잠금을 해제하려면 변수를 메인 메모리로 동기화해야 함

=== volatile 변수용 특별 규칙

가장 가벼운 동기화 메커니즘

2가지 특성

. 모든 스레드에서 이 변수를 투명하게 볼 수 있음
** 한 스레드가 값을 변경하면 다른 스레드가 그 값을 즉시 볼 수 있음
** 동시성 환경에서 안전하다는 것은 아님 - 자바의 산술 연산자가 원자적이 아니라서
** 아래 2개를 만족하지 못하면 lock 으로 atomic 을 보장해야 함
... 값을 수정하는 스레드가 하나 뿐임을 보장
... 다른 상태 변수와 관련된 불변성 제약 조건에 관여하지 않음
. 명령어 재정렬 최적화를 막아줌
** 명령어 재정렬은 같은 스레드에서 메소드를 실행하는 동안에는 탐지할 수 없음
** 메모리 장벽과 같은 역할 -> 장벽 뒤의 명령어를 장벽 앞으로 재정렬할 수 없도록 막음

==== volatile 이 중요한 이유?

* 특정 상황에서 lock 보다 성능이 좋음
* volatile 의 읽기 성능은 일반 변수와 거의 같다
* 자바 메모리 모델에서 규정한 volatile 변수용 특별 규칙
** 특정 스레드가 변수를 '사용' 하려면 변수에 수행한 이전 연산이 '적재' 여야 한다 & '적재' 하려면 마지막 연산이 '사용' 이어야 한다
*** 변수가 사용될 때마다 변경 사항을 다른 스레드에서 볼 수 있도록 최신 값으로 고쳐야 함
** 특정 스레드가 변수를 '저장' 하려면 이전 연산이 '할당' 이어야 한다 & '할당' 하려면 마지막 연산이 '저장' 이어야 한다
*** 수정될 때마다 메인 메모리로 즉시 동기화

=== long, double 변수용 특별 규칙

64비트 데이터의 읽기와 쓰기는 32비트 연산 2개로 나눠 처리할 수 있음 -> long, double 변수의 비원자적 처리 +
-> 반만 수정된 값을 읽을 수 있음

32비트용 VM 에서 발생 가능 - -XX:+AlwaysAtmoicAccesses

=== 원자성, 가시성, 실행 순서

==== 원자성

* 원자적 변수 연산 - 읽기, 적재, 할당, 사용, 저장, 쓰기
* 원자성을 더 넓은 범위로 보장해야 할 때를 위해 잠금과 잠금 해제 연산 제공
* 직접 제공은 아니라 monitorenter, monitorexit -> synchronized 키워드

==== 가시성

* 공유 변수의 값을 한 스레드가 수정하면 다른 스레드가 즉시 알 수 있음
* volatile
* synchronized - 변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화
* final - 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없음

==== 실행 순서

[quote]
현재 스레드에서 보면 모든 연산이 순서대로 수행된다. 하지만 다른 스레드에서 보면 순서가 다를 수 있다

명령어 재정렬 & 작업 메모리와 메인 메모리 사이 동기화 지연

synchronized 블록 2개가 같은 lock 을 공유한다면 반드시 순서대로 수행

=== 선 발생 원칙

데이터 경합 발생 여부와 스레드 안전성을 확인하는 데 매우 유용한 수단

선 발생: 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계

아래는 동기화 장치의 지원 없이 이루어지는 선 발생 관계

* 프로그램 순서 규칙: 한 스레드 내에서는 순서대로 연산 발생
* monitor lock 규칙: 잠금 해제는 같은 lock 에 대한 잠금보다 선 발생
* volatile 변수 규칙: volatile 변수 쓰기는 읽기보다 선 발생
* thread start 규칙: Thread.start() 는 어떤 작업보다 선 발생
* thread termination 규칙: 모든 작업은 종료 감지보다 선 발생
* thread interruption 규칙: interrupt() 는 인터럽트 이벤트 발생 감지보다 선 발생
* finalize 규칙: 객체 초기화는 finalize() 보다 선 발생
* 전이성: A -> B, B -> C 이면 A -> C

시간 순서와 선 발생 원칙 사이에는 인과 관계가 없다. 선 발생 원칙에 기초해야 한다