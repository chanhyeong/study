= 12장. 자바 메모리 모델과 스레드

VM 이 멀티스레딩을 구현하는 방법 + 스레드들이 데이터를 공유하거나 경합하며 발생하는 다양한 문제외 해결책

== 하드웨어에서의 효율과 일관성

* 메모리 I/O 는 없애기 힘듦 -> 캐시를 둠 -> 캐시 일관성 (cache coherence) 문제 발생
** 공유 메모리 멀티프로세서 시스템: 프로세서 각각이 자신만의 캐시를 가지고 메인 메모리 공유 - 프로세서별 캐시 데이터는 다를 수 있음
* 일관성 문제 해결 -> 메모리 모델: 특정 프로토콜을 이용하여 특정 메모리나 캐시를 읽고 쓰게
* 비순차 실행 최적화 (out-of-order execution optimization) 로도 컴퓨팅 능력 향상 가능
** 프로세서의 실행 순서가 입력 순서와는 다를 수 있음
** JIT 컴파일러는 명령어 재정렬 (instruction reordering) 최적화 수행

== 자바 메모리 모델

* 다양한 하드웨어와 OS 의 메모리 모델로부터 자바 프로그램을 보호하고자 자바 메모리 모델을 따로 정의
** 메모리를 일관된 방식으로 이용

=== 메인 메모리와 작업 메모리

* 자바 메모리 모델의 주 목적: 프로그램에서 다양한 변수에 접근하는 규칙 정의
** 인스턴스 필드, 정적 필드, 배열 객체의 원소
** VM 실행 엔진과 JIT 컴파일러의 성능 최적화를 막지 않음
* 모든 변수는 메인 메모리에 저장된다고 규정
* 각 스레드는 작업 메모리를 가짐
** 사용하는 변수가 저장된 메인 메모리의 복사본
** 변수 read/write 는 작업 메모리에서 수행 - 메인 메모리에 있는 변수에 직접 접근 불가
** thread 끼리는 개별 작업 메모리 변수에 직접 접근 불가 - 메인 메모리를 거쳐서 전송

=== 메모리 간 상호 작용

메인 메모리 -> 작업 메모리로 변수 복사, 작업 메모리 -> 메인 메모리 동기화 방법을 8가지로 정의 +
JVM 은 각 연산이 원자적임을 보장

* 잠금 (lock): 메인 메모리 변수를 특정 스레드만 사용할 수 있게
* 잠금 해제 (unlock): 잠겨 있는 변수 해제
* 읽기 (read): 적재 연산을 위해 메인 메모리 변숫값을 특정 스레드의 작업 메모리로 복사
* 적재 (load): 작업 메모리의 변수에 복사해서 넣음
* 사용 (use): 작업 메모리의 변수를 실행 엔진으로 전달. 변수를 사용하는 명령어를 만날 때마다 실행
* 할당 (assign): 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
* 저장 (store): 작업 메모리의 변수를 메인 메모리로 전송
* 쓰기 (write): 메인 메모리의 변수에 기록

복사: 읽기 -> 적재. 동기화: 저장 -> 쓰기 +
순서대로만 수행하고 바로 이어서 수행될 필요는 없음

* 읽기와 적재, 저장과 쓰기는 단독으로 수행될 수 없음
* 최근 할당 연산을 버릴 수 없음
* 작업 메모리의 데이터를 할당 없이 메인 메모리로 동기화 할 수 없음
* 변수는 메인 메모리에서만 생겨날 수 있음
** 작업 메모리에 있는 변수를 곧바로 사용할 수 없음 - 할당과 적재가 이루어져야 함
* 변수는 한 번에 한 스레드만 잠글 수 있음
* 변수를 잠그면 작업 메모리의 변숫값은 지워짐
* 잠겨있지 않은 변수나 다른 스레드가 잠근 변수는 잠금 해제 불가
* 잠금을 해제하려면 변수를 메인 메모리로 동기화해야 함

=== volatile 변수용 특별 규칙

가장 가벼운 동기화 메커니즘

2가지 특성

. 모든 스레드에서 이 변수를 투명하게 볼 수 있음
** 한 스레드가 값을 변경하면 다른 스레드가 그 값을 즉시 볼 수 있음
** 동시성 환경에서 안전하다는 것은 아님 - 자바의 산술 연산자가 원자적이 아니라서
** 아래 2개를 만족하지 못하면 lock 으로 atomic 을 보장해야 함
... 값을 수정하는 스레드가 하나 뿐임을 보장
... 다른 상태 변수와 관련된 불변성 제약 조건에 관여하지 않음
. 명령어 재정렬 최적화를 막아줌
** 명령어 재정렬은 같은 스레드에서 메소드를 실행하는 동안에는 탐지할 수 없음
** 메모리 장벽과 같은 역할 -> 장벽 뒤의 명령어를 장벽 앞으로 재정렬할 수 없도록 막음

==== volatile 이 중요한 이유?

* 특정 상황에서 lock 보다 성능이 좋음
* volatile 의 읽기 성능은 일반 변수와 거의 같다
* 자바 메모리 모델에서 규정한 volatile 변수용 특별 규칙
** 특정 스레드가 변수를 '사용' 하려면 변수에 수행한 이전 연산이 '적재' 여야 한다 & '적재' 하려면 마지막 연산이 '사용' 이어야 한다
*** 변수가 사용될 때마다 변경 사항을 다른 스레드에서 볼 수 있도록 최신 값으로 고쳐야 함
** 특정 스레드가 변수를 '저장' 하려면 이전 연산이 '할당' 이어야 한다 & '할당' 하려면 마지막 연산이 '저장' 이어야 한다
*** 수정될 때마다 메인 메모리로 즉시 동기화

=== long, double 변수용 특별 규칙

64비트 데이터의 읽기와 쓰기는 32비트 연산 2개로 나눠 처리할 수 있음 -> long, double 변수의 비원자적 처리 +
-> 반만 수정된 값을 읽을 수 있음

32비트용 VM 에서 발생 가능 - -XX:+AlwaysAtmoicAccesses

=== 원자성, 가시성, 실행 순서

==== 원자성

* 원자적 변수 연산 - 읽기, 적재, 할당, 사용, 저장, 쓰기
* 원자성을 더 넓은 범위로 보장해야 할 때를 위해 잠금과 잠금 해제 연산 제공
* 직접 제공은 아니라 monitorenter, monitorexit -> synchronized 키워드

==== 가시성

* 공유 변수의 값을 한 스레드가 수정하면 다른 스레드가 즉시 알 수 있음
* volatile
* synchronized - 변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화
* final - 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없음

==== 실행 순서

[quote]
현재 스레드에서 보면 모든 연산이 순서대로 수행된다. 하지만 다른 스레드에서 보면 순서가 다를 수 있다

명령어 재정렬 & 작업 메모리와 메인 메모리 사이 동기화 지연

synchronized 블록 2개가 같은 lock 을 공유한다면 반드시 순서대로 수행

=== 선 발생 원칙

데이터 경합 발생 여부와 스레드 안전성을 확인하는 데 매우 유용한 수단

선 발생: 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계

아래는 동기화 장치의 지원 없이 이루어지는 선 발생 관계

* 프로그램 순서 규칙: 한 스레드 내에서는 순서대로 연산 발생
* monitor lock 규칙: 잠금 해제는 같은 lock 에 대한 잠금보다 선 발생
* volatile 변수 규칙: volatile 변수 쓰기는 읽기보다 선 발생
* thread start 규칙: Thread.start() 는 어떤 작업보다 선 발생
* thread termination 규칙: 모든 작업은 종료 감지보다 선 발생
* thread interruption 규칙: interrupt() 는 인터럽트 이벤트 발생 감지보다 선 발생
* finalize 규칙: 객체 초기화는 finalize() 보다 선 발생
* 전이성: A -> B, B -> C 이면 A -> C

시간 순서와 선 발생 원칙 사이에는 인과 관계가 없다. 선 발생 원칙에 기초해야 한다

== 자바와 스레드

=== 스레드 구현

* 스레드 각각은 프로세스 자원을 공유할 수 있고 독립적으로 스케줄링
* java.lang.Thread 는 핵심 메소드 모두가 네이티브 코드로 구현
** 실행 효율 + 플랫폼 독립적 수단만으로는 구현할 수 없어서

==== 커널 스레드 구현

* OS 커널에서 직접 지원하는 스레드. 각각은 커널의 복제본
* 프로그램은 커널 스레드를 직접 이용하지 않고, 고수준 인터페이스인 경량 프로세스 이용
* 경량 프로세스 각각은 독립된 단위로 스케줄링
* 한계
.. 생성, 소멸, 동기화 등 스레드 연산이 system call -> 실행 비용이 높음
.. 경량 프로세스는 일정량의 커널 자원 소모 - 개수 제한

==== 사용자 스레드 구현

* 좁은 의미: 온전히 사용자 공간에서 구현되는 스레드 라이브러리
** OS 커널은 사용자 스레드의 존재와 구현 방법을 모름
** 제대로 구현하면 커널 모드로 전환할 필요도 없음
** 스레드의 생성, 소멸, 동기화, 스케줄링 등 모든 것을 사용자 프로그램 자체에서 처리해야 함
*** '블로킹 처리', '멀티프로세서 시스템에서 스레드를 특정 프로세서에 매핑' 이 어려움

==== 하이브리드 구현

* 사용자 스레드와 경량 프로세스가 공존

==== 자바 스레드

* OS 기본 스레드 모델을 기반 - OS 기본 스레드에 매핑
** 핫스팟 자체는 스레드 스케줄링에 관여 없이 온전히 OS 가 처리
* OS 가 어떤 스레딩 모델을 제공하느냐가 JVM 스레드 매핑 방식에 영향을 준다

=== 자바 스레드 스케줄링

* 스레드 스케줄링: 시스템이 프로세서 사용 권한을 스레드에 할당
** 협력적 (cooperative), 선점형 (preemptive)
* 협력적 스케줄링: 스레드 실행 시간을 스레드가 스스로 제어
** 마치면 다른 스레드에 적극적으로 알려야 함
** 구현이 쉽고 동기화 문제가 일어나지 않음
** 스레드 실행 시간을 제어할 수 없음 - 다른 스레드로 전환이 안되면 프로그램이 멈춰짐
* 선점형 스케줄링: 각 스레드의 실행 시간을 시스템이 할당
** 전환 시점을 스스로 결정하지 못함
* 자바는 **선점형 스케줄링**
** 특정 스레드에 더 많거나 적은 실행 시간을 할당하도록 '권고'할 수는 있음
** 스레드 우선순위를 총 10단계로 지정 가능 (Thread.MIN_PRIORITY ~ Thread.MAX_PRIORITY)

=== 상태 전이

자바에서 스레드의 상태는 총 여섯 가지 +
특정 메소드를 호출하여 다른 상태로 변경 가능

* New: 생성 후 시작 전 상태
* Running: OS 스레드 상태 중 Running, Ready 에 해당
** 실행 중이거나 OS 가 실행 시간을 할당하기를 기다리는 중
* Waiting: 다른 스레드가 명시적으로 깨워 주기를 기다리는 중
** (타임아웃 없는) Object.wait(), (타임아웃 없는) Thread.join(), LockSupport.park() 등이 이 상태로 변경시키는 메소드
* Timed Waiting: 일정 시간이 지나면 시스템에 의해 자동으로 깨어남
** Thread.sleep(), Object.wait(long), Thread.join(long), LockSupport.parkNanos(), LockSupport.parkUntil() 등이 이 상태로 변경시키는 메소드
* Blocked: 배타적 lock 을 얻기를 기다리는 상태 - 다른 스레드가 해당 lock 을 해제할 때 얻을 수 있음
* Terminated: 실행 종료

== 자바와 가상 스레드

다양한 OS 스레드 모델 차이를 숨기는 통합된 스레드 인터페이스 제공

=== 커널 스레드의 한계

* MSA 와 어울리지 않음 - OS 스레드 매핑으로 인해 전환과 스케줄링 비용이 커지고, 시스템이 수용할 수 있는 스레드 수도 크게 제한
** 사용자 스레드 전환 부하로 인한 심각한 낭비
** 사용자 모드 <-> 커널 모드 전환 비용

=== 코루틴의 귀환

* 사용자 스레드는 원래 협력적 스케줄링 형태로 설계되었으므로 coroutine 이라는 별칭으로 불림
** stackful coroutine: 스택을 유지하는 (콜 스택을 완벽하게 보관하고 보관) 코루틴
* stackless coroutine: 유한 상태 머신. 상태는 closure 에 저장
** await, async, yield 키워드 이용
** 가볍다
** 호출 스택과 스케줄러 등 앱 수준에서 구현해야 한다
* 자바의 제약: 자바 호출 스택과 로컬 호출 스택이 함께 만들어짐
** 코루틴이 네이티브 메소드를 호출하면 해당 스레드 전체에 영향을 주지 않고 전환될 수 있는지?
** 스레드 동기화 메커니즘을 마주치면 어떻게 될지?

=== 가상 스레드: 자바의 해법

* Loom project: 자바 언어를 위한 새로운 동시성 프로그래밍 메커니즘
** stackful coroutine
** 사용자 스레드의 부활
* 가상:플랫폼 스레드 = N:1
** 가상 스레드 하나가 블록되면 플랫폼 스레드는 연결된 다른 가상 스레드 작업을 이어서 진행
** 커널 스레드는 문맥 전환 없이 코드를 실행
* 가상 스레드를 이용하는 코드: 실행 대상인 후속문 (continuation), 스케줄러
** 스케줄러: 실행될 코드의 순서를 정하는 역할
*** 개발자가 스케줄링 방식을 직접 제어할 수 있음