= 11. 백엔드 컴파일과 최적화

백엔드 컴파일: .class -> 개별 로컬에 맞는 네이티브 코드로 변환

== JIT 컴파일러

* 자바 프로그램 -> 인터프리터로 해석해 실행
* 자주 실행되는 메소드 or 코드 블록 -> 네이티브 코드로 컴파일, 최적화하여 실행 효율을 높임
** hotspot code or hot code
** 백엔드 컴파일러: JIT 컴파일러

=== 인터프리터와 컴파일러

* 인터프리터: 프로그램을 빠르게 시작해야 할 때 컴파일 없이 바로 실행
** 메모리가 부족한 경우 인터프리터 방식으로 메모리 절약
** 적극적 최적화의 가정이 무너지는 경우, 최적화를 취소하고 다시 인터프리터로 맡김
* 컴파일러: 시작된 후 시간이 흐를 수록 네이티브 코드로 컴파일하여 실행 효율을 높임
** 2개 or 3개 내장
** C1 (클라이언트), C2 (서버), Graal
* 계층형 컴파일 모드 전에는 C1, C2 중 하나의 컴파일러와 협력하여 동작
** 클라이언트 모드 or 서버 모드 only
* 혼합 모드: 자바 버전과 머신 하드웨어에 맞추어 자동으로 선택
** -Xint, -Xcomp 설정으로 고정 가능

네이티브로의 컴파일 시 시간이 많이 걸리고, 최적화 할수록 컴파일도 오래 걸림 +
인터프리터가 성능 모니터링 정보를 수집할 수 있으며 이것도 해석과 실행 단계 속도에 영향

==== 계층형 컴파일 기능

* 계층 0: 인터프리터가 순수 해석 실행
* 계층 1: C1 컴파일러. 바이트코드 -> 네이티브 코드 컴파일 실행
** 간단하고 안정적인 최적화
* 계층 2: C1 컴파일러. 몇 가지 성능 모니터링만 수행
* 계층 3: C1 컴파일러. 모든 성능 모니터링 정보 수집
* 계층 4: C2 컴파일러. 성능 모니터링 정보를 활용하여 더 오래 걸리는 최적화까지 수행
** 신뢰도가 낮은 공격적인 최적화를 수행하기도

**인터프리터, C1, C2 컴파일러가 협력해 동작하면서 hot code 가 여러 번 컴파일될 수 있다**

* C1: 빠르게 컴파일
* C2: 성능을 더 높여야 할 때
** 복잡한 최적화 알고리즘을 수행해야 할 때는 C1 으로 간단하게 최적화해두고, 최적화를 천천히 수행도 가능

=== 컴파일 대상과 촉발 조건

.조건
****
. 여러 번 호출되는 메소드
. 여러 번 실행되는 순환문의 본문
****

* 컴파일 대상 = 메소드 전체
* 온스택 치환: 메소드의 스택 프레임이 스택에 존재하는 상태에서 메소드가 치환

==== 코드 블록이 실행되는 횟수 계산? - 핫스팟 코드 탐지

* 샘플 기반: 각 스레드의 호출 스택 상단을 샘플링
** 특정 메소드 or 일부가 자주 발견되면 hot method 로 간주
** 구현은 쉽지만 정확하게 알기는 어렵고 탐지 방해 요소가 있음
* 카운터 기반: 각 메소드와 코드 블록에 대한 카운터 설정
** 실행 횟수가 특정값을 초과하면 hot method 로 간주
** 구현이 번거롭지만 정확하고 엄격한 결과를 얻을 수 있음

==== 메소드 호출 카운터에 의한 JIT 컴파일 촉발

p524, 그림 11-3

* client 모드에서 1500회, server 모드에서 10000회
. 메소드 호출 시 JIT 컴파일 버전이 이미 있는지 확인
. 없으면 호출 카운트 1 증가
** 단위 시간 (counter half life time) 당 호출 횟수
** counter decay method invocation: 단위 시간 동안 도달하지 못하면 카운터의 값을 절반으로 줄임
. 메소드 호출 카운터 + 백 에지 카운터 > 기준값 -> JIT 컴파일 요청
. 컴파일이 완료될 때까지는 인터프리터로 실행
. 컴파일이 완료되면 메소드 호출 진입점 주소가 자동으로 덮어씌워짐. 이후 호출에선 컴파일 버전 사용

==== 백 에지 카운터에 의한 JIT 컴파일 촉발

* 백 에지 카운터: 특정 순환문의 본문 코드가 실행되는 횟수
* client 모드: 메소드 호출 카운터 문턱값 (-XX:CompileThreshold) * OSR 비율 (-XX:OnStackReplacePercentage) / 100 == 기본값 13995
* server 모드: 메소드 호출 카운터 문턱값 * OSR 비율 - 인터프리터 모니터링 비율 / 100 == 기본값 10700
. 백 에지 명령어 발견 시 컴파일된 버전 확인
. 이후 동작은 동일
* 백 에지 카운터는 감쇠가 없고 절대 실행 횟수를 계산

=== 컴파일 과정

* 백그라운드에서 별도 스레드가 수행. 컴파일 완료 전까지는 인터프리터가 프로그램 실행

==== client 컴파일러의 컴파일 과정

p528, 그림 11-5

3단계, 지역 최적화에 집중

. 플랫폼 독립적 프론트엔드 - bytecode -> 타깃 중립적 중간 표현인 HIR 생성
** 코드 값을 정적 단일 할당 (SSA) 로 표현 -> 최적화를 쉽게 구현할 수 있도록 도와줌
** 메소드 인라인, 상수 전파 등 기본 최적화 수행
. 플랫폼 의존적 백엔드 - HIR -> LIR 생성
** LIR: Low Intermediate Representation
** HIR 대상으로 null 검사 제거, 범위 검사 제거 등의 최적화 수행
. 플랫폼 의존적 백엔드 - 선형 스캔 레지스터 할당 (linear scan register allocation)
** LIR 에 레지스터 할당, 핍홀 최적화 수행 -> 네이티브 코드 생성

==== server 컴파일러의 컴파일 과정

서버 측 성능을 극대화하도록 설정된 컴파일러. GNU C++ 컴파일러 수준

* 전통적인 최적화: dead code 제거, 순환문 언롤링, 순환문 표현식 호이스팅, 공통 하위 표현 제거, 상수 전파, 기본 블록 재정렬
* 자바 특화 최적화: 범위 검사, null 검사 제거 등
* 인터프리터 or client 컴파일러에서 제공한 성능 모니터링 정보를 토대로 guided inline, 분기 예측 등 예측 최적화 수행
* 전역 그래프 셰이더 할당기 사용 - 커다란 레지스터 집합의 이점 활용
* 생성한 네이티브 코드의 성능이 client 컴파일러의 것보다 훨씬 좋음
** JDK9 부터 기본 모드

=== 실전: JIT 컴파일 결과 확인 및 분석

일련번호 | 컴파일 아이디 (OSR, 일반) | 컴파일 계층 | 컴파일된 메소드 | (OSR BCI (bytecode index)) | 컴파일된 코드 크기

* 코드 인라인 수행 - 디스패치 부하가 없어진다
** (private method 분리해도 괜찮다)