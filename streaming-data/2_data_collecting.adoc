= 2장. 클라이언트에서 데이터 가져오기: 데이터 수집

수집 단계 (Collection tier) 에서 사용되는 패턴에 대해 이해 +
어떻게 확장할 것이며 신뢰도를 위한 어떤 fault-tolerance 기술을 적용할지 확인

== 2.1 일반적인 통신 패턴

=== Request/Response pattern

* 서버가 지연 없이 즉각적으로 응답하여 작업을 완료하는 것을 목표
* (클라이언트) 명령, 요청 -> (서버) 응답
* 단점: 서버에서 응답을 받기 위해 클라이언트는 기다려야 한다
* 단점을 해결하기 위한 3가지 전략
.. 클라이언트 단 요청 비동기 수행: 요청을 날리고 응답이 오기까지 다른 일을 수행 (half-async)
.. 서버 단 비동기 응답: 요청 처리를 수행하는 동안, 처리가 완료된 데이터를 응답으로 반환 (half-async)
*** https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-async.html
*** https://shortstories.gitbooks.io/studybook/content/async_controller.html
.. 완전 비동기 (full-async): 클라이언트와 서버 둘 다 완전 비동기로 동작

=== Request/Acknowledge pattern

* 서버에서 반환하는 응답이 필요하지 않은 경우, 서버가 요청을 정상적으로 받았는지 확인만 해야할 때
* 첫 요청 시 수집 단계 다음 요청에 사용할 데이터를 '확인응답'으로 넘겨준다
** 다음 요청부터 사용할 데이터 - 고유 식별자 -> 방문 패이지를 추적하는 데 사용

=== Publish/Subscribe pattern

* 메시지 전달/수신 (푸시/풀)
* 결합도를 낮춤

=== One-way pattern

* 응답이 필요하지 않을 때 & 서버가 응답을 다시 보내지 않아도 된다
* 클라이언트 리소스가 적거나 요청만 수행하는 경우
* 일부 데이터 유실 허용, 통신 단순화, 리소스 감소, 전송 속도 보장

=== Stream pattern

* 한 번의 요청에 데이터를 전달하지 않거나, 지속적으로 데이터를 응답으로 보내는 특징
* 수집 단계와 연결하여 지속적으로 원천 스트림 데이터를 가져갈 수 있다
* 스트림 데이터가 존재하는 단계에 연동하여 데이터를 지속적으로 처리할 수 있다

== 2.2 통신 패턴 확장하기

=== 요청/응답 파생 패턴

* stateless 서버이기 때문에 클라이언트, 서버 모두 확장 (신규 서버 투입) 이 쉽다

=== 스트림 패턴

두 가지 방법

. 스트림 데이터를 처리하는 수집 서버 확장
. 버퍼링 계층 도입
** 스트림 데이터 수집 시점에 로직이 없기 때문에 중간 계층이 들어와도 괜찮다
*** (버퍼링 계층의 확장은?)
** 이후 수집 단계의 서버가 데이터를 가져가서 비즈니스 로직을 수행

== 2.3 내결함성 Fault-tolerance

수집한 데이터를 유실하면 복구가 불가능할 수 있다 +
수집 단계 서버 장애가 발생하더라도 데이터를 유실하지 않는게 목적

데이터 유실을 방지하고 신속히 복구할 두 가지 방법

. Checkpointing
** 전역 스냅샷: 시스템 전역 상태에 대한 스냅샷을 정기적으로 특정 저장소에 저장
*** 유입되는 & 처리되는 모드는 데이터 캡처하여 저장소에 보관
** 데이터 유실 가능성: 가장 최근에 기록된 전역 상태까지 복구할 수 있도록
** 스트리밍 시스템이 여러 단계 + 다양한 기술로 구성 -> 전역 스냅샷을 일관성 있게 저장하는 것은 어려움
** 신규 버전의 HDFS, NoSQL 을 구축, 사용 시에는 기능을 도입하는 것이 좋다
. Logging
** 장애가 발생하기 전까지 수신된 마지막 메시지까지 복구하는 기능 제공
** 목표: 메시지를 재처리할 수 있다면, 시스템은 전역 스냅샷이 없어도 전 구간에서 일관된 상태에 도달할 수 있음
** 각 단계가 모든 메시지를 자체적으로 저장, 저장된 메시지를 재처리

=== RBML (Receiver-based message logging)

* 메시지를 저장소에 저장한 이후 로직 처리
** 메시지가 RBML logger 로 전달 -> 저장소로 전달
** 저장 완료 후 비즈니스 로직 처리 -> 다음 단계로 이동
* 저장소 성능이 충분히 따라주지 않으면 문제
* 간결성과 복구 가능성을 높임
* 장애 발생 시 메시지가 유입되지 않는다

=== SBML (Sender-based message logging)

* 메시지를 보내기 전에 저장소에 저장
* '서버가 처리한 데이터'를 다음 단계로 보내기 전에 로깅
* 복구: 다음 단계로 넘어간 데이터가 잘 처리되었는지 여부를 확인
** 확인응답을 받으면 영속 저장소에서 삭제 or 처리 완료 표시
** 확인응답을 받을 수 없는 환경이면 그냥 삭제

=== HBL (Hybrid message logging)

* RBML (비동기 쓰기) + SBML
* 복잡성은 증가할 수 있고, 멀티코어 사용 시 성능을 올릴 수 있다
** (비동기 쓰기 -> 처리 완료 -> 삭제할 때 복제가 안되어 있으면 어떻게 하지? 기다리나?)

== 2.4 상용환경 적용

* 요구사항을 파악하여 필수 구현 조건을 고려해야 한다