= 1. 카프카 개요

* 링크드인에서 시작
* 이벤트 스트리밍 플랫폼

== 잘란도와 트위터의 도입 사례
=== 잘란도

* 이벤트 드리븐 시스템으로의 전환을 결정
* 요구 사항
** inbound, outbound 데이터가 일치함을 검증
** 통신 방법 및 이벤트 변경 순서 보장
* 초기: API, PostgreSQL CRUD 타입 구성 - 업데이트 이후 outbound 이벤트 생성
** 한계
*** 여러 네트워크에서 모든 데이터 변경에 대한 올바른 전달 보장
*** 동일한 데이터를 동시에 수정하면서 정확하게 순서 보장, 수정된 이벤트들을 정확한 순서대로 전송
*** 빠른 전송을 위한 클라이언트 or 배치 전송을 위한 클라이언트 지원 어려움

==== 결과

* 더 나아가서 실시간 도메인 랭킹을 수행하는 데 Kafka Streams 를 이용 - MapReduce 스타일 연산

=== 트위터

* event bus 를 구축해 운영했지만 카프카로 전환

==== 카프카로 유턴

* 0.7 버전으로 처음 도입했으나 문제
** 많은 I/O operation 에서의 문제, 내구성, 리플리케이션 미구현 등
* inhouse message system (event bus) 구현
* 검토
** 비용 절감
*** event bus 에 비해 카프카의 응답 속도가 빠르다
*** 카프카는 하나의 프로세스 사용 + OS zero-copy 를 이용하여 event bus 에 비해 하드웨어를 덜 사용한다
** 강력한 커뮤니티
*** 트위터 내부의 8명보다 카프카 커뮤니티가 더 크다
** 다양한 사용처

== 주요 특징

=== 높은 처리량과 낮은 지연시간

* 처리량 = kafka > Pulsar > RabbitMQ
** (Pulsar: 야후에서 개발한 메시징 시스템, Bookeeper: 분산 스토리지 서비스)
* 응답속도 = RabbitMQ
* 처리량 + 응답속도 = Kafka

=== 높은 확장성 - 8장

=== 고가용성 - 4장

* replication

=== 내구성 - 4장

* `acks` 로 메시지 내구성 강화
* 기존: 메시지를 가져가면 저장소에서 메시지가 삭제
* kafka: 메시지가 일정 시간 or 크기만큼 디스크에 보관
* 여러 대의 브로커에 저장 - 다른 디스크에 저장된 내용으로 복구

=== 개발 편의성

* producer, consumer 로 분리되어있고 서로 영향이 없음 - 5, 6장
* Kafka Connect, Schema Registry - 8장

=== 운영 및 관리 편의성 - 7장

* 증설 작업이 쉽고 간단
* 버전 업그레이드 가능 및 단순
* 모니터링

== 카프카의 성장

* replication (2013/12) -> Schema Registry (2015/02) -> Kafka Connect (2015/11) -> Kafka Streams (2016/05) -> KSQL (2017/08) -> Zookeeper 탈출 (2021/04)