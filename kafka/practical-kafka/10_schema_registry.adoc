= 10. 스키마 레지스트리

== 개념과 유용성

* 정보를 구성하고 해석을 도와주는 프레임워크나 개념
* 카프카의 경우
** 사전에 정의하지 않은 형태의 데이터를 보내면 모든 시스템이 영향을 받음

== 스키마 레지스트리

=== 개요

* 별도의 애플리케이션
* 컨플루언트 커뮤니티 라이선스
** 비상업적인 용도에 한해 무료로 사용
* 클라이언트: 스키마 정보를 사용하기 위해 프로듀서, 컨슈머 <-> 스키마 레지스트리 간 직접 통신 필요
. 프로듀서: 스키마 레지스트리에 스키마 등록
. 스키마 레지스트리: 스키마 정보를 내부 토픽에 저장
. 프로듀서: 스키마 레지스트리에 등록된 스키마 ID 와 메시지를 카프카로 전송
. 컨슈머: 스키마 ID 메시지를 조합하여 읽음

=== Avro

* 시스템, 언어, 프레임워크 사이에서 데이터 교환을 도와주는 오픈소스 직렬화 시스템
* 바이너리 데이터 포맷을 지원, JSON 형태의 스키마 정의 가능
* 스키마 레지스트리: Avro, JSON, Protocol Buffer 포맷도 지원
** Avro 권장
*** JSON 과 매핑
*** 간결한 데이터 포맷
*** JSON 은 메시지마다 필드 네임이 포함되어 전송 -> 효율 떨어짐
*** 바이너리 형태이므로 매우 빠르다

.student.avro
[source,json]
----
{
    "namespace": "student.avro", // <1>
    "type": "record", // <2>
    "doc": "Example of Avro",
    "name": "Student", // <3>
    "fields": [ // <4>
        { "name": "name", "type": "string", "doc": "222" }, // <5>
        { "name": "class", "type": "int", "doc": "222" },
    ]
}
----
<1> 이름 식별
<2> record, enums, arrays, maps
<3> 이름을 나타네는 문자열, 필수
<4> JSON array, 필드 목록
<5> type (boolean, int, long, string), doc

* 데이터 필드마다 데이터 타입 정의 가능
* doc 으로 필드 의미 전달

=== 설치

생략

* 운영에서는 이중화 권장 (master/slave)
* http 기반 통신

=== 실습

==== 동작

. `KafkaAvroSerializer` 로 스키마 레지스트리의 스키마가 유효한지 확인 (없으면 등록하고 로컬 캐시)
. 스키마 레지스트리: 현 스키마가 저장소에 저장된 스키마가 동일한지, 진화한지 확인
** 내부에서 각 스키마에 대해 고유 ID 를 할당, 1씩 증가 -> 프로듀서에 고유 ID 응답
. 프로듀서: 스키마 ID 를 참고하여 메시지 전송
. `KafkaAvroDeserializer` 로 메시지 읽음

==== 의문점

. 보통 서버는 동시에 여러 대가 배포될 텐데, 여러 대에서 스키마 등록 작업을 하면 동일한거에 대해서는 동시성 문제가 없는가?
. 스키마 변경을 하더라도 컨슈머 단은 정적 언어인 경우에는 버전별로 클래스 분리가 필요할 것 같은데 그런건 어떻게 할지?

== 호환성

=== BACKWARD

* 진화된 스키마를 적용한 컨슈머가 진화 전의 스키마가 적용된 프로듀서가 보낸 메시지를 읽을 수 있게 허용
* 상위 버전을 컨슈머에 먼저 적용 -> 프로듀서에서 상위 버전을 적용
* 종류
** 동일 버전 + -1: BACKWARD
** 동일 버전 + 하위 전체: BACKWARD_TRANSITIVE
* 번경: 필드 삭제, 기본값이 지정된 필드 추가

=== FORWARD

* 진화된 스키마가 적용된 프로듀서가 보낸 메시지를 진화 전의 스키마가 적용된 컨슈머가 읽을 수 있게 함
* BACKWARD 의 반대
* 종류: FORWARD, FORWARD_TRANSITIVE
* 변경: 필드 추가, 기본값이 지정된 필드 삭제

=== FULL

* BACKWARD, FORWARD 를 모두 지원
* 종류: FULL, FULL_POSITIVE
* 변경: 기본값이 지정된 필드 추가/삭제
