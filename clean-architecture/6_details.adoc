= 6. 세부사항

== 30. 데이터베이스는 세부사항이다

애플리케이션은 데이터베이스에 저장되는 방식을 알아서는 안된다

많은 데이터 접근 프레임워크가 table, row 객체 형태로 시스템을 돌아다니도록 허용하는데 잘못된 설계다 +
유스케이스, 업무 규칙, UI 도 관계형 데이터 구조에 결합되어 버린다

=== DB 가 사용되는 이유?

디스크 떄문 -> 데이터 접근 및 관리 시스템이 필요 -> 파일 시스템, RDBMS

파일 시스템: 문서 기반 +
DBMS: 내용 기반

디스크가 없다면 더 편한 구조로 체계화 할 것이기 때문에, 이건 세부 사항으로 보는게 맞다

== 31. 웹은 세부사항이다

앞으로도 연산 능력을 어디에 둘지 알 수 없을 것. 중앙 집중 or 분산 방식 사이에서 계속 움직일 것

업무 규칙을 UI 에서 분리해야 한다

== 32. 프레임워크는 세부사항이다

프레임워크 제작자는 자신의 문제나 동료의 문제를 알고 있다. 우리의 문제는 아니다 +
우리의 문제가 많이 겹쳐서 인기가 높을 것

프레임워크 제작자는 (일방적으로) 프레임워크에 강하게 결합될 것을 원한다

=== 위험 요인

* 프레임워크 아키텍처가 깔끔하지 않은 경우가 많다
** 프레임워크 코드를 상속할 것을 요구 - 프레임워크가 가장 안 쪽 원과 결합되길 원한다
* 초기 기능엔 도움되지만, 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것 - 프레임워크와 계속 싸우게 됨
* 프레임워크가 도움이 되지 않는 방향으로 진화할 수도
* 더 나은 프레임워크가 등장해서 갈아타고 싶어질 수도

=== 해결책

프레임워크와 결합하지 않고

프록시 생성, 업무 규칙에 플러그인할 수 있는 컴포넌트에 프록시 위치 +
핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합, 의존성 규칙 준수

업무 객체에 `@Autowired` 가 산재해서는 안된다 +
업무 객체보다는 Main 에서 스프링을 사용해서 의존성을 주입하는 편이 낫다

=== 결론

가급적이면 프레임워크를 아키텍처 경계 너머에 두자