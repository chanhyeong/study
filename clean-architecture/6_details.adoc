= 6. 세부사항

== 30. 데이터베이스는 세부사항이다

애플리케이션은 데이터베이스에 저장되는 방식을 알아서는 안된다

많은 데이터 접근 프레임워크가 table, row 객체 형태로 시스템을 돌아다니도록 허용하는데 잘못된 설계다 +
유스케이스, 업무 규칙, UI 도 관계형 데이터 구조에 결합되어 버린다

=== DB 가 사용되는 이유?

디스크 떄문 -> 데이터 접근 및 관리 시스템이 필요 -> 파일 시스템, RDBMS

파일 시스템: 문서 기반 +
DBMS: 내용 기반

디스크가 없다면 더 편한 구조로 체계화 할 것이기 때문에, 이건 세부 사항으로 보는게 맞다

== 31. 웹은 세부사항이다

앞으로도 연산 능력을 어디에 둘지 알 수 없을 것. 중앙 집중 or 분산 방식 사이에서 계속 움직일 것

업무 규칙을 UI 에서 분리해야 한다

== 32. 프레임워크는 세부사항이다

프레임워크 제작자는 자신의 문제나 동료의 문제를 알고 있다. 우리의 문제는 아니다 +
우리의 문제가 많이 겹쳐서 인기가 높을 것

프레임워크 제작자는 (일방적으로) 프레임워크에 강하게 결합될 것을 원한다

=== 위험 요인

* 프레임워크 아키텍처가 깔끔하지 않은 경우가 많다
** 프레임워크 코드를 상속할 것을 요구 - 프레임워크가 가장 안 쪽 원과 결합되길 원한다
* 초기 기능엔 도움되지만, 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것 - 프레임워크와 계속 싸우게 됨
* 프레임워크가 도움이 되지 않는 방향으로 진화할 수도
* 더 나은 프레임워크가 등장해서 갈아타고 싶어질 수도

=== 해결책

프레임워크와 결합하지 않고

프록시 생성, 업무 규칙에 플러그인할 수 있는 컴포넌트에 프록시 위치 +
핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합, 의존성 규칙 준수

업무 객체에 `@Autowired` 가 산재해서는 안된다 +
업무 객체보다는 Main 에서 스프링을 사용해서 의존성을 주입하는 편이 낫다

=== 결론

가급적이면 프레임워크를 아키텍처 경계 너머에 두자

== 33. 사례 연구

== 34. 빠져 있는 장

악마는 항상 디테일 (구현 세부사항) 에 있는 법이며, 심사숙고 해야 한다

=== 계층 기반 패키지

기술적인 관점에서 코드가 하는 일에 기반하여 분할

처음 시작하기에는 좋으나, 커지고 복잡해지면 더 잘게 모듈화해야 할지를 고민하게 될 것이다

=== 기능 기반 패키지

서로 연관된 기능, 도메인 개념, 혹은 Aggregate Root 에 기반하여 수직의 얇은 조각으로 코드를 나누기

코드의 상위 수준 구조가 업무 도메인에 대해 알려준다 - 책 예시에는 주문과 관련한 무언가를 한다는 것을 알려줌

=== 포트와 어댑터

업무/도메인에 초점을 둔 코드가 세부 구현과 독립적이 분리된 아키텍처를 만들도록

'내부(도메인)' 와 '외부(인프라)' 로 구성

=== 컴포넌트 기반 패키지

큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는다 +
('업무 로직' 과 영속성 관련 코드를 하나로 묶음)

사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지

저자가 제안하는건 Component 인터페이스만 공개시키고, 나머지는 내부 인터페이스로 둔다

=== 구현 세부사항엔 항상 문제가 있다

public 을 아무 생각 없이 사용하는 경우 캡슐화 관련 이점을 활용하지 않는 것