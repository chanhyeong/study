SOLID: 벽돌을 배치하는 방법 +
컴포넌트: 빌딩에 방을 배치하는 방법

컴포넌트가 무엇인지 & 결합하여 시스템을 구성하는 방법에 대해

== 12. 컴포넌트

컴포넌트는 배포 단위다 - 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위

잘 설계된 컴포넌트라면 독립적으로 배포 가능한, 독립적으로 개발 가능한 능력

=== 간략한 역사

초기에는 메모리에서의 프로그램의 위치와 레이아웃을 프로그래머가 직접 제어

함수 라이브러리가 클 수록 컴파일이 오래 걸림 -> 함수 라이브러리의 소스 코드를 애플리케이션에서 분리, 개별적으로 컴파일하여 로드

애플리케이션이 커질수록 함수 할당에 문제 (그림 12.2)

=== 재배치성

메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정 +
로더가 재배치 코드가 자리할 위치 정보를 전달 받아서 플래그 삽입

==== 링킹 로더

재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성 +
함수 호출 = 라이브러리 함수 이름을 외부 참조 (external reference) 로 생성 +
라이브러리 함수 정의 프로그램? - 이름을 외부 정의 (external definition) 로 생성

외부 정의를 로드할 위치가 정해지면, 로더가 외부 참조를 외부 정의에 링크

=== 링커

링킹 로드의 등장 - 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 됨 +
(이거도 하드웨어의 한계로 느려짐)

결국 로드와 링크가 분리됨 - 프로그래머가 링크 과정 +
링커는 링크가 완료된 재배치 코드를 만들어 줌

로드 시간은 빨랐지만, 코드가 커지면서 컴파일-링크 시간이 병목 구간

[quote]
컴파일하고 링크하는 데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다

하드웨어의 발전으로 로드와 링크를 다시 동시에 할 수 있게 됨

=== 결론

소프트웨어 컴포넌트 - 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일

== 13. 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함?

* REP: Reuse/Release Equivalence Princinple
* CCP: Common Closure Principle
* CRP: Common Reuse Principle

=== REP: 재사용/릴리즈 등가 원칙

[quote]
재사용 단위는 릴리즈와 같다

릴리즈 번호 - 호환되는지 보증할 방법, 언제 출시되고 무엇이 변했는지 알 수 있음 +
릴리즈 - 공지와 문서가 포함되어야 한다 (개발자가 새 릴리즈를 통합할지, 언제 할지를 결정)

단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 한다 - 컴포넌트를 구성하는 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다

단순히 지켜야 한다는 건 이 원칙의 약점 - 다른 두 원칙으로 보완

=== CCP: 공통 폐쇄 원칙

[quote]
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

SRP 를 컴포넌트 관점에서 쓴 것

변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 된다

==== SRP 와의 유사성

SRP: 클래스 단위, CCP: 컴포넌트 단위

=== CRP: 공통 재사용 원칙

[quote]
컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다

의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 의존함을 인지해야 한다 +
= 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다

==== ISP 와의 관계

ISP: 미사용 메소드가 있는 클래스에 의존하지 말 것 +
CRP: 미사용 클래스를 가진 컴포넌트에 의존하지 말 것

=== 컴포넌트 응집도에 대한 균형 다이어그램

그림 13.1 에 나온 균형을 맞춰야 한다

=== 결론

재사용성과 개발 가능성이라는 상충하는 것을 반드시 고려해야 한다 +
균형을 잡는게 중요하다. 항상 유동적임

== 14. 컴포넌트 결합

컴포넌트 사이의 관계 설명

=== ADP: 의존성 비순환 원칙 (Acyclic Dependency Principle)

[quote]
컴포넌트 의존성 그래프에 순환이 있어서는 안 된다

망가진 부분 수정 작업이 반복된다 +
해결책으로 주 단위 빌드, 의존성 비순환 원칙

==== 주 단위 빌드 (Weekly Build)

금요일에는 통합하기. 하지만 규모가 커지면 금요일에 못 끝나게 될 수 있음

==== 순환 의존성 제거하기

개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하기 +
컴포넌트를 동작하게 만들고 -> 컴포넌트를 릴리즈하여 다른 이가 사용할 수 있게

그림 14.1 처럼 단방향 그래프로 유지하게 되면 관리하기가 쉽고 명확해진다

==== 순환이 컴포넌트 의존성 그래프에 미치는 영향

* 릴리즈 시 호환 문제 발생 -> 하나의 거대한 컴포넌트가 되어버림
* 테스트, 빌드 시 결합

==== 순환 끊기

그림 14.3, 14.4

. 의존성 역전 원칙 (DIP) 적용
. 둘 다가 의존하는 새로운 컴포넌트 생성

==== 흐트러짐 (Jitters)

애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 성장한다 (그림 14.4 처럼)

순환이 발생하는지 관찰 해야함

=== 하향식 (top-down) 설계

컴포넌트는 하향식으로 설계될 수 없다 +
= 가장 먼저 설계할 수 있는 대상이 아니며, 시스템이 성장하고 변경될 때 함께 진화한다

컴포넌트 의존성 다이어그램 = 빌드 가능성과 유지보수성을 보여주는 지도 +
컴포넌트 구조를 프로젝트 초기에 설계할 수 없다

초기에 모듈이 쌓이면 의존성 관리 요구가 늘어나고, 변경 범위가 작게 되길 원함 - SRP, CCP 에 관심

의존성 구조의 관심사 - 변동성 격리

애플리케이션 성장에 따라 +
재사용 가능한 요소 만들기 -> 컴포넌트 조합을 위해 공통 재사용 원칙 (CRP) -> 순환 발생 시 ADP 적용 -> 컴포넌트 의존성 그래프가 흐트러지고 성장

=== SDP: 안정된 의존성 원칙

[quote]
안정성의 방향으로 (더 안정된 쪽에) 의존하라.

변동성을 지니도록 설계한 컴포넌트는 언젠가 변경된다고 예상 +
변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다 +
(변동성이 큰 것도 결국은 변경이 어려워짐)

==== 안정성

다른 것에 의존하지 않고, 다른 것이 의존을 많이 하는 것이 안정된 컴포넌트 (그림 14.5)

==== 안정성 지표

* Fan-in: 컴포넌트 내부 클래스에 의존하는 외부 클래스의 개수
* Fan-out: 컴포넌트 외부 클래스에 의존하는 내부 클래스의 개수
* I (불안정성): I = Fan-out / (Fan-in + Fan-out), 0 이면 안정 1이면 불안정

==== 추상 컴포넌트

인터페이스만을 포함하는 컴포넌트를 생성하는 방식 (실행 가능한 코드가 없는)

안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상

(spi 같은게 이런 건가)

=== SAP: 안정된 추상화 원칙

[quote]
컴포넌트는 안정된 정도만큼만 추상화되어야 한다

==== 고수준 정책을 어디에 위치시켜야 하는가?

고수준 정책을 캡슐화하는 소프트웨어는 안정된 컴포넌트에 위치해야 한다

클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 유연하게 만들고 바람직한 방식 - 추상 클래스

==== 안정된 추상화 원칙

안정성과 추상화 정도 사이의 관계를 정의

안정된 컴포넌트는 추상 컴포넌트여야 하고, 안정성이 컴포넌트 확장을 방해해서는 안된다 +
불안정한 컴포넌트는 구체 컴포넌트 - 내부 구체적인 코드를 쉽게 변경할 수 있어야 한다

==== 추상화 정도 측정하기

* Nc: 컴포넌트 클래스의 개수
* Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
* A: 추상화 정도, A = Na / Nc

==== 주계열

안정성과 추상화 정도 사이의 관계

그림 14.13. 배제 구역 (Zone of Exclusion)

컴포넌트가 절대로 위치해서는 안 되는 영역

(archunit 이용하면 강제할 수 있긴 할 듯)

===== 고통의 구역 (pain)

추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 어렵다

DB 엔티티, 구체적인 유틸리티 라이브러리 등

변동성이 없는 컴포넌트는 여기 위치해도 해롭지 않다

===== 쓸모없는 구역 (uselessness)

추상적이지만 누구도 의존하지 않음 +
누구도 구현하지 않은 채 남겨진 추상 클래스인 경우

==== 배제 구역 벗어나기

Main Sequence (주계열)

너무 추상적이지도, 너무 불안정하지도 않은

주계열의 두 종점이 가장 바람직한 위치

==== 주계열과의 거리

* D: D = |A + I - 1|. 0 이면 주계열에 위치, 1이면 가장 멀리 위치

=== 결론

의존성 관리 지표는 설계의 의존성과 추상화 정도

지표는 임의로 결정된 표준을 기초로 한 측정값이므로 불완전하지만 유용한 걸 찾을 수 있을 것