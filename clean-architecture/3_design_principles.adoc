SOLID - 함수와 데이터 구조를 클래스로 배치하는 방법, 클래스 간 결합하는 방법

* 변경에 유연하다
* 이해하기 쉽다
* 컴포넌트의 기반

== 7. SRP: 단일 책임 원칙 (Single Responsibility Principle)

[quote]
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

[quote]
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

액터: 변경을 요청하는 한 명 이상의 사람들 +
모듈: 함수와 데이터 구조로 구성된 응집된 집합

원칙을 위반하는 징후들

* 징후 1: 우발적 (Accidential) 중복
** 서로 다른 액터가 의존하는 코드를 너무 가까이 배치
** SRP 에서는 분리하라고 한다
* 징후 2: 병합

=== 해결책

메소드를 각기 다른 클래스로 이동시키는 방식

그림 7.3 - 데이터 클래스 분리, 3개의 클래스가 그걸 공유하는 방식

단점? -> 세 가지 클래스를 인스턴스와하고 추적해야 함 +
해결? -> Facade 를 만들어서 생성, 요청된 메소드를 가지는 객체로 위임

=== 결론

SRP 는 메소드와 클래스 수준의 원칙

상위 수준에서도 다른 형태로 다시 나타난다 +
컴포넌트 수준: Common Closure Principle +
아키텍처 수준: Architectual Boundary 생성을 책임지는 변경의 축

== 8. OCP: 개방-폐쇄 원칙 (Open-Close Principle)

[quote]
소프트웨어 개체 (artifact) 는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다

기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화 +
-> 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호

방향성 제어, 정보 은닉

=== 결론

시스템을 확장하기 쉽게 + 시스템이 너무 많은 영향을 받지 않게

시스템을 컴포넌트 단위로 분리, 저수준 변경으로부터 고수준 컴포넌트를 보호할 수 있는 의존성 계층구조로

== 9. LSP: 리스코프 치환 원칙 (Liskov Substitution Princicple)

subtype

[quote]
S, T 가 있고 T 를 이용한 프로그램 P 에서 S 로 치환하더라도 P 의 행위가 변하지 않는다면, S 는 T 의 하위타입 (subtype) 이다

상속을 사용하도록

=== LSP 와 아키텍처

초기에는 상속 사용하도록 가이드하는 정도 -> 인터페이스와 구현체에도 적용되는 광범위한 설계 원칙으로

잘 정의된 인터페이스와 구현체끼리의 상호 치환성에 기댈 수 있다

=== LSP 위배 사례

(깨졌을 때 나타나는 일)

특정 조건을 위해 별도 분기 등

(이거는 많이 겪어봤는데..)

=== 결론

아키텍처 수준까지 확장할 수 있고, 반드시 확장해야 한다 - 치환 가능성

조금이라도 위배되면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있다

== 10. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)

=== 언어 측면

ISP 는 언어 타입에 의존

정적 타입 언어: 타입 선언문 사용 강제 -> 의존성 발생, 재컴파일 or 재배포 필요 +
동적 타입 언어: 선언문은 없으나 런타임 추론

=== 아키텍처 측면

특정 의존 관계를 위한 기능 때문에, 상위 레이어를 재배포해야 할 수 있다

=== 결론

불필요한 무언가에 의존하면 문제에 빠진다 (13장 컴포넌트 응집도에 공통 재사용 원칙에서 다룰 예정)

== 11. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)

유연성이 극대화된 시스템: 의존성이 추상 (abstraction) 에 의존하며, 구체 (concretion) 에는 의존하지 않는 시스템

변동성이 큰 (volatile) 구체적인 요소에서 중요함

=== 안정된 추상화

인터페이스는 구현체보다 변동성이 낮다 +
인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력

안정된 소프트웨어 아키텍처: 변동성이 큰 구현체에 의존하는 일은 지양, 안정된 추상 인터페이스를 선호

* 변동성이 큰 구체 클래스를 참조하지 말 것
** 객체 생성 방식을 Abstract Factory 를 사용하도록 강제
* 변동성이 큰 구체 클래스로부터 파생하지 말 것
* 구체 함수를 오버라이드 하지 말 것
* 구체적이며 변동성이 크다면 절대로 언급하지 말 것

=== Factory

변동성이 큰 구체적인 객체는 추상 팩토리에서 생성

추상 컴포넌트: 고수준의 업무 규칙 +
구체 컴포넌트: 필요한 세부 사항

제어 흐름이 소스 코드 의존성과는 반대 방향으로 곡선을 가로지른다 - 의존성 역전 (Dependency inversion)

=== 구체 컴포넌트

구체 컴포넌트에는 구체적인 의존성이 하나 있음 (FactoryImpl 이 ConcreteImpl 에 의존) +
위배되지만 일반적이고, 위배를 모두 없앨 수 없다