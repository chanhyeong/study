== 3. 패러다임 개요

패러다임 - 프로그래밍을 하는 방법, 언어 독립적

패러다임은 무엇을 해서는 안 되는지 말해준다 (goto, 함수 포인터, 할당문)

=== structured programming

무분별한 goto 보다는, if/then/else, do/while/until

[quote]
제어흐름의 직접적인 전환에 규칙을 부과한다

=== object-oriented programming

함수 포인터를 특정 규칙에 따라 사용 (이 과정에서 다형성 등장)

[quote]
제어흐름의 간접적인 전환에 대해 규칙을 부과한다

=== functional programming

[quote]
할당문에 규칙을 부과한다

== 4. Structured programming

=== 증명

프로그램 동작에 대한 문제 해결을 위해 증명을 적용 +
(유클리드 계층구조 - 공리, 정리, 따름정리, 보조정리)

if/else/then, do/while 등의 goto 문장 유형은 모듈을 분해하는데 문제가 되지 않음 +
(재귀적으로 세분화)

순차 실행과 결합했을 때 좋음

모든 프로그램은 sequence (순차), selection (분기), iteration (반복) 세 가지 구조만으로 표현할 수 있다

* sequential statement - 순차 구문의 입력을 출력까지 추적
* selection - 경로를 열거하고 적절한 결과를 만들어낸다면 증명을 신뢰할 수 있음
* iteration - 귀납법

=== 기능적 분해

structured analysis, structred design 등의 기법으로 발전 +
대규모 시스템을 모듈과 컴포넌트로 나눌 수 있게 됨

=== 테스트

[quote]
테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다

소프트웨어는 과학과 같다 (앞에서 수학은 참을 증명하고, 과학은 거짓을 증명한다는 얘기 함)

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요 +
테스트를 통해 거짓인지 증명하려고 시도

== 5. Object-Oriented programming

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발

캡슐화, 상속, 다형성 3가지 개념을 조합한 것이거나, 최소한 3가지 요소를 반드시 지원해야 한다고 주장하기도 함

=== 캡슐화 (encapsulation)

데이터와 함수가 응집력있게 된 선을 정의

C 에서는 헤더와 구현체를 분리하여 완벽한 캡슐화를 구현 +
(Java 에서도 인터페이스 개념으로 되지 않나?)

C++ 에서는 키워드를 통해 불완전환 캡슐화, Java 와 C# 에서는 헤더와 구현체를 분리하는 방식을 버려서 캡슐화 훼손

OO 언어가 캡슐화를 거의 강제하지 않는다

=== 상속 (inheritance)

C 에서는 강제로 명시하여 상속을 구현할 수는 있다 +
(흉내는 내지만, 다중 상속이나 암묵적인 업캐스팅은 불가)

OO 언어에서는 편리한 방식으로 제공

=== 다형성 (polymorphism)

unix os 는 모든 입출력 장치 드라이버가 5가지 표준 함수를 제공하도록 요구 (open/close/read/write/seek)

함수를 가리키는 포인터를 응용한 것 = 다형성

(p45 에서 STDIN 에 대한 write 를 호출하면 NotImplementedError 같은걸 호출하나?)

OO 언어는 함수 포인터에 대한 관례 (초기화, 포인터를 통한 함수 호출) 를 없애주어 실수할 위험이 없다

독립성을 지원하기 위해 만들어졌음 - plugin architecture

==== 의존성 역전 (dependency inversion)

소스 코드에서는 인터페이스를 호출했지만, 런타임에서는 인터페이스가 존재하지 않고 실제 함수가 호출 됨 +
(소스 코드 의존성이 제어 흐름과는 반대)

OO 언어는 소스 코드 의존성을 어디에서든 역전시킬 수 있다 +
소스 코드 의존성은 인터페이스를 추가함으로써 방향을 역전시킬 수 있다 +
-> 소스 코드 의존성 전부에 대해 방향을 결정할 수 있다 = 방향을 원하는 방향대로 설정할 수 있다

Business Rule 이 UI, DB 에 의존적이지 않게 할 수 있다 +
(UI, DB 가 플러그인이 된다)

Business Rule 을 UI, DB 와 독립적으로 배포할 수 있다. 배포 독립성, 개별 독립성

=== 결론

OO 는 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 잇는 능력

== 6. Functional programming

함수형 언어에서 변수는 변경되지 않는다 +
(사실 val 도 변수라고 부르는게 맞는가 개인적인 생각이 들긴 했는데, 변하지 않는데 변수라고 해야 하나?)

=== 불변성과 아키텍처

모든건 변할 수 있기 때문에 복잡해진다. 동시성 문제에 관심을 가져야 한다

불변성은 실현 가능한가? -> 타협하면 된다

=== 가변성의 분리

가변, 불변 컴포넌트로 분리해보자

변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다 - 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침 +

최대한 불변으로 두고, 최대한 가변에서는 빼야 함

=== 이벤트 소싱

상태가 아닌 트랜잭션을 저장, CRUD 에서 CR 만 수행

(예전에 다른 책에서 원장 (ledger) 이 이런 개념이었던거로 봤는데)