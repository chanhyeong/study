== 15. 아키텍처란?

시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 의사소통하는 방식에 따라 달라지는 +
시스템을 구축한 사람들이 만들어낸 시스템의 형태

시스템이 쉽개 **개발, 배치, 운영, 유지보수**되도록

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것

=== 개발

쉽게 개발할 수 있도록 뒷받침해야 한다

팀이 작으면 컴포넌트, 인터페이스가 없더라도 효율적으로 협력하여 개발 - 오히려 제약이 방해가 된다고 생각할 수도

사람이 많아지면 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 안흐면 개발이 진척되지 않음 +
시스템의 아키텍처가 각 팀마다 따로 발전될 가능성이 높다 - 최적일 가능성은 거의 없다

=== 배포

시스템을 단 번에 쉽게 배포할 수 있도록 만들어야 한다

=== 운영

좋은 아키텍처는 시스템을 운영하는 데 필요한 요구를 알려준다

유즈케이스, 기능, 시스템의 필수 행위를 first-class 엔티티로 격상시키고, 개발자에게 주요 목표로 인식되도록 해야 한다 +
시스템의 이해가 쉽고, 개발 및 유지보수에 도움

=== 유지보수

기능을 추가하거나 결함을 수정할 때 +
소프트웨어의 어디를 고치는게 최선인지, 어떤 전략을 쓰는게 최적일지 결정할 때 비용 발생 +
의도치 않은 결함이 발생할 가능성도 존재 - 위험부담 추가

시스템을 컴포넌트로 분리, 안정된 인터페이스를 두어 서로 격리

=== 선택사항 열어 두기

소프트웨어를 부드럽게 유지하는 방법 - 선택사항을 가능한 한 많이, 오랫동안 열어 두기 = 중요하지 않은 세부 사항

소프트웨어 시스템 두 가지 구성요소 - 정책 (모든 업무 규칙과 절차), 세부사항 (정책에 영향이 없는 i/o, db, web, server, framework, protocol)

결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기반으로 제대로 된 결정을 내릴 수 있다

다양한 실험을 시도해볼 수 있는 선택지도

[quote]
좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다

=== 장치 독립성

강결합이 아닌 추상화를 잘 해두어야 한다

=== 결론

세부사항을 정책으로부터 가려내고, 정책이 세부사항과 결합되지 않도록 분리

정책이 세부사항에 의존하지 않게

== 16. 독립성

좋은 아키텍처는 유스케이스, 운영, 개발, 배포를 지원해야 한다

=== 유스케이스

시스템의 의도를 지원해야 한다

행위를 명확히 하고 외부로 드러내며, 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게

=== 운영

유스케이스에 대한 운영 작업 (처리량, 응답시간 등) 을 허용할 수 있는 형태로 아키텍처를 구조화

=== 개발

[quote, 콘웨이 법칙]
시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다

독립적으로 행동하기 편한 아키텍처를 확보하여, 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다 +
잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다

=== 배포

시스템이 빌드된 후 즉각적인 배포를 목표로

그러기 위해 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다

master 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다

=== 선택사항 열어놓기

선택사항을 열어 두어 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록

=== 계층 결합 분리

UI 부분과 업무 규칙 부분을 분리

업무 규칙: 애플리케이션과 밀접한 관련 or 더 범용적 +
애플리케이션 관련 예 (유효성 검사), 업무 도메인 예 (이자 계산, 재고품 집계)

DB, 쿼리 언어, 스키마도 기술적인 세부 사항 - 업무 규칙이나 UI 와는 관련이 없음 +
시스템의 나머지 부분에서 분리하여 독립적으로 변경할 수 있도록 해야 한다

서로 결합되지 않은 수평적인 계층으로 분리 +
UI, 애플리케이션 특화 규칙, 애플리케이션 독립 규칙, DB

=== 유스케이스 결합 분리

결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다

(DB 까지 이게 되나?, 주석 그림 2)

=== 결합 분리 모드

관점이 분리되었다면 계층 간 실제 구동되는 서버도 분리 실행될 수 있다

==== 분리 수준

* 소스 수준: 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록
* 배포 수준: 배포 가능한 단위들 사이의 의존성 제어
* 서비스 수준: 네트워크 패킷을 통해서만 통신
** 기본 정책으로 잡기는 쉬우나, 개발 시간 및 시스템 자원 측면에서도 비용이 많이 든다

좋은 아키텍처는 모노리틱 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장 -> 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다 +
상황이 바뀌었을 때 다시 모노리틱으로 되돌릴 수도 있어야 한다

=== 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이 간섭은 줄어든다

=== 배포 독립성

결합을 제대로 분리했다면 계층과 유스케이스를 교체할 수 있다

=== 중복

중복에 대한 공포로부터 발생하는 함정

진짜 중복: 변경 시 모든 복사본에 적용 +
거짓된 or 우발적인 중복: 서로 다른 속도와 다른 이유로 변경된다면, 진짜 중복이 아니다

두 유스케이스에 대해 통합 코드를 만들지 않도록 유의해야 한다 - 다른 방향으로 발전될 가능성이 크고, 분리하느라 수고스러움

레코드와 동일한 view 모델을 만드는 것도 중요 - 계층 간 결합을 적절하게 분리

=== 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉽고, 아키텍트는 변경을 예측하여 반영할 수 있도록 해야 한다

== 17. 경계: 선 긋기

소프트웨어 요소를 서로 분리, 반대편 요소를 알지 못하게

아키텍트의 목표는 개발, 유지 인적 자원의 최소화 +
유스케이스와 관련이 없는, 너무 일찍 내려진 결정에 따른 결합으로 인해 인적 자원 효율이 떨어진다

=== 어떻게? 언제? 선 긋기

관련이 있는 것과 없는 것

DB | GUI, DB | 업무 규칙

업무 규칙은 스키마, 쿼리 언어, DB 와 관련된 세부사항에 대해 알아서는 안된다 +
데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 것만 알아야 한다

DB 의 화살표 방향이 업무 규칙을 향하도록 만들었으므로, 어떤 종류의 DB 도 사용할 수 있음을 알 수 있다

=== 입력? 출력?

입력과 출력은 중요하지 않다

=== 플러그인 아키텍처

사용자 인터페이스는 플러그인 형태로 고려되었기 때문에, 다양한 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다

=== 결론

경계선을 그리려면 시스템을 컴포넌트 단위로 분할해야 한다. +
일부 컴포넌트는 핵심 업무 규칙에 해당하고 나머지는 플러그인, 핵심 업무와 직접적인 관련은 없지만 필수 기능을 포함한다

컴포넌트 사이의 화살표가 핵심 업무를 향하도록 소스륿 배치한다