== 15. 아키텍처란?

시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 의사소통하는 방식에 따라 달라지는 +
시스템을 구축한 사람들이 만들어낸 시스템의 형태

시스템이 쉽개 **개발, 배치, 운영, 유지보수**되도록

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것

=== 개발

쉽게 개발할 수 있도록 뒷받침해야 한다

팀이 작으면 컴포넌트, 인터페이스가 없더라도 효율적으로 협력하여 개발 - 오히려 제약이 방해가 된다고 생각할 수도

사람이 많아지면 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 안흐면 개발이 진척되지 않음 +
시스템의 아키텍처가 각 팀마다 따로 발전될 가능성이 높다 - 최적일 가능성은 거의 없다

=== 배포

시스템을 단 번에 쉽게 배포할 수 있도록 만들어야 한다

=== 운영

좋은 아키텍처는 시스템을 운영하는 데 필요한 요구를 알려준다

유즈케이스, 기능, 시스템의 필수 행위를 first-class 엔티티로 격상시키고, 개발자에게 주요 목표로 인식되도록 해야 한다 +
시스템의 이해가 쉽고, 개발 및 유지보수에 도움

=== 유지보수

기능을 추가하거나 결함을 수정할 때 +
소프트웨어의 어디를 고치는게 최선인지, 어떤 전략을 쓰는게 최적일지 결정할 때 비용 발생 +
의도치 않은 결함이 발생할 가능성도 존재 - 위험부담 추가

시스템을 컴포넌트로 분리, 안정된 인터페이스를 두어 서로 격리

=== 선택사항 열어 두기

소프트웨어를 부드럽게 유지하는 방법 - 선택사항을 가능한 한 많이, 오랫동안 열어 두기 = 중요하지 않은 세부 사항

소프트웨어 시스템 두 가지 구성요소 - 정책 (모든 업무 규칙과 절차), 세부사항 (정책에 영향이 없는 i/o, db, web, server, framework, protocol)

결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기반으로 제대로 된 결정을 내릴 수 있다

다양한 실험을 시도해볼 수 있는 선택지도

[quote]
좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다

=== 장치 독립성

강결합이 아닌 추상화를 잘 해두어야 한다

=== 결론

세부사항을 정책으로부터 가려내고, 정책이 세부사항과 결합되지 않도록 분리

정책이 세부사항에 의존하지 않게

== 16. 독립성

좋은 아키텍처는 유스케이스, 운영, 개발, 배포를 지원해야 한다

=== 유스케이스

시스템의 의도를 지원해야 한다

행위를 명확히 하고 외부로 드러내며, 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게

=== 운영

유스케이스에 대한 운영 작업 (처리량, 응답시간 등) 을 허용할 수 있는 형태로 아키텍처를 구조화

=== 개발

[quote, 콘웨이 법칙]
시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다

독립적으로 행동하기 편한 아키텍처를 확보하여, 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다 +
잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다

=== 배포

시스템이 빌드된 후 즉각적인 배포를 목표로

그러기 위해 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다

master 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다

=== 선택사항 열어놓기

선택사항을 열어 두어 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록

=== 계층 결합 분리

UI 부분과 업무 규칙 부분을 분리

업무 규칙: 애플리케이션과 밀접한 관련 or 더 범용적 +
애플리케이션 관련 예 (유효성 검사), 업무 도메인 예 (이자 계산, 재고품 집계)

DB, 쿼리 언어, 스키마도 기술적인 세부 사항 - 업무 규칙이나 UI 와는 관련이 없음 +
시스템의 나머지 부분에서 분리하여 독립적으로 변경할 수 있도록 해야 한다

서로 결합되지 않은 수평적인 계층으로 분리 +
UI, 애플리케이션 특화 규칙, 애플리케이션 독립 규칙, DB

=== 유스케이스 결합 분리

결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다

(DB 까지 이게 되나?, 주석 그림 2)

=== 결합 분리 모드

관점이 분리되었다면 계층 간 실제 구동되는 서버도 분리 실행될 수 있다

==== 분리 수준

* 소스 수준: 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록
* 배포 수준: 배포 가능한 단위들 사이의 의존성 제어
* 서비스 수준: 네트워크 패킷을 통해서만 통신
** 기본 정책으로 잡기는 쉬우나, 개발 시간 및 시스템 자원 측면에서도 비용이 많이 든다

좋은 아키텍처는 모노리틱 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장 -> 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다 +
상황이 바뀌었을 때 다시 모노리틱으로 되돌릴 수도 있어야 한다

=== 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이 간섭은 줄어든다

=== 배포 독립성

결합을 제대로 분리했다면 계층과 유스케이스를 교체할 수 있다

=== 중복

중복에 대한 공포로부터 발생하는 함정

진짜 중복: 변경 시 모든 복사본에 적용 +
거짓된 or 우발적인 중복: 서로 다른 속도와 다른 이유로 변경된다면, 진짜 중복이 아니다

두 유스케이스에 대해 통합 코드를 만들지 않도록 유의해야 한다 - 다른 방향으로 발전될 가능성이 크고, 분리하느라 수고스러움

레코드와 동일한 view 모델을 만드는 것도 중요 - 계층 간 결합을 적절하게 분리

=== 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉽고, 아키텍트는 변경을 예측하여 반영할 수 있도록 해야 한다

== 17. 경계: 선 긋기

소프트웨어 요소를 서로 분리, 반대편 요소를 알지 못하게

아키텍트의 목표는 개발, 유지 인적 자원의 최소화 +
유스케이스와 관련이 없는, 너무 일찍 내려진 결정에 따른 결합으로 인해 인적 자원 효율이 떨어진다

=== 어떻게? 언제? 선 긋기

관련이 있는 것과 없는 것

DB | GUI, DB | 업무 규칙

업무 규칙은 스키마, 쿼리 언어, DB 와 관련된 세부사항에 대해 알아서는 안된다 +
데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 것만 알아야 한다

DB 의 화살표 방향이 업무 규칙을 향하도록 만들었으므로, 어떤 종류의 DB 도 사용할 수 있음을 알 수 있다

=== 입력? 출력?

입력과 출력은 중요하지 않다

=== 플러그인 아키텍처

사용자 인터페이스는 플러그인 형태로 고려되었기 때문에, 다양한 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다

=== 결론

경계선을 그리려면 시스템을 컴포넌트 단위로 분할해야 한다. +
일부 컴포넌트는 핵심 업무 규칙에 해당하고 나머지는 플러그인, 핵심 업무와 직접적인 관련은 없지만 필수 기능을 포함한다

컴포넌트 사이의 화살표가 핵심 업무를 향하도록 소스를 배치한다

== 18. 경계 해부학

시스템 아키텍처는 소프트웨어 컴포넌트, 컴포넌트를 분리하는 경계에 의해 정의 +
다양한 경계의 형태

* 경계 횡단: 한 쪽 경계 기능에서 다른 쪽 경계 기능을 호출하여 데이터 전달
** 적절한 위치에서 횡단 - 소스 코드 의존성 관리

=== 두려운 단일체

가장 단순, 물리적으로 엄격하게 구분되지 않는 형태

배포 관점에서는 단일 실행 파일, 경계가 드러나지 않지만 존재하지 않거나 무의미한건 아님

동적 다형성에 의존 (제네릭, 템플릿)

그림 18.1 에서는 저수준 (Client) 에서 고수준 (Service) 으로 제어흐름. Data 는 호출되는 쪽에 위치

그림 18.2 에서는 제어흐름과는 반대로 경계 횡단 (Impl 이 고수준에 있는 데이터를 보고 있음)

18.2 처럼 규칙적인 방식으로 구조를 분리하면, 컴포넌트를 독립적으로 작업할 수 있다

=== 배포형 컴포넌트

컴포넌트가 배포 가능한 형태로 전달된다

=== 스레드

실행 계획과 순서를 체계화

하나의 컴포넌트에 포함될 수도, 많은 컴포넌트에 걸쳐 분산될 수도

=== 로컬 프로세스

command line or 시스템 호출을 통해 생성. 독립된 주소 공간

분리 전략 - 항상 고수준 컴포넌트를 향하게 +
로컬 프로세스에서는 고수준에서 저수준 프로세스의 정보를 포함하면 안된다 +
-> 저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만드는 것이 목표

통신이 비싸므로 빈번하지 않도록 해야 한다

=== 서비스

command line or 시스템 호출을 통해 생성. 물리적 위치가 상관 없음

통신이 매우 느리므로 빈번한 통신을 피해야 한다 - 통신 지연 문제를 고수준에서 처리할 수 있어야 한다

저수준은 고수준에 플러그인 되어야 한다

== 19. 정책과 수준

하나의 정책을 여러 개의 정책으로 쪼갤 수 있다

정책을 신중하게 분리하고, 변경에 따라 재편성 +
동일 이유로 동일 시점에 변경되는 정책은 동일 수준에 위치, 동일 컴포넌트에 속해야 한다

아키텍처 개발은 비순환 방향 그래프로 구성하는 기술을 포함 +
node (정책을 포함하는 컴포넌트) + edge (컴포넌트 사이의 의존성)

=== 수준

입력과 출력까지의 거리 +
둘에서 멀어질 수록 정책의 수준은 높아진다

그림 19.1 에서 번역이 정책, 최고 수준의 컴포넌트

**데이터 흐름과 소스 코드 의존성은 항상 같은 방향이 아니다**

그림 19.2 처럼 분리하여, 입출력에 변화가 생기더라도 정책은 영향이 없어진다

정책을 컴포넌트로 묶는 기준 - 정책이 변경되는 방식에 달려 있다 +
SRP, CCP 에서 동일 이유로 동일 시점 변경되는 정책은 함꼐 묶임

=== 결론

SRP, OCP, CCP, DIP, SDP, SAP 를 모두 포함하므로 다시 읽어보며 어디서 어떻게 사용되었는지 봐야 한다

== 20. 업무 규칙

사업적으로 수익을 얻거나 비용을 줄일 수 있어야 하는, 규칙 또는 절차

Critical Business Rule (핵심 업무 규칙) +
(각종 계산기, 검증기가 따로 분리되는게 이런거일듯)

Critical Business Data (핵심 업무 데이터)

Entity = 핵심 규칙과 핵심 데이터가 결합된 객체

=== 엔티티

핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구체화

**DB, 사용자 인터페이스, 서드파티 프레임워크 들로 오염되어서는 안된다** +
& 시스템 표현 방식, 데이터 저장 방식, 배치되는 방식

(개인적으로는 엔티티가 DB 스키마를 담고 있는 보통의 JPA 를 사용하는 방식이 별로인 것 같다) +
(엔티티는 순수하게 규칙만을 담고, 엔티티가 어떻게 저장되는지는 repository 가 잘 알아서 나눠서 저장해야 하지 않을까)

=== 유스케이스

자동화된 시스템이 사용되는 방법을 설명 +
입력, 출력, 출력을 생성하기 위한 처리 단계를 기술 - 애플리케이션에 특화된 업무 규칙

데이터 입출력 형식 명시를 빼면, 사용자 인터페이스를 기술하지 않는다 +
사용자와 엔티티 사이의 상호작용 규정

유스케이스는 객체 - 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수 제공 +
입출력 데이터, 참조 데이터 포함

엔티티는 유스케이스를 모른다

=== 요청 및 응답 모델

유스케이스는 주고 받는 방식에 대해서는 몰라야 한다 (HTML, SQL 을 몰라야 한다)

요청 및 응답 모델이 독립적이어야 한다 - 목적이 다르다

== 21. 소리치는 아키텍처

디렉토리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때 이 아키텍처는 어떤 시스템이야? 어떤 프레임워크야?

=== 아키텍처의 테마

소프트웨어 아키텍처는 유스케이스를 지원하는 구조여야 한다 - 유스케이스 주도 접근법 +
프레임워크에 대한 것이 아니다

=== 아키텍처의 목적

유스케이스 충족

좋은 아키텍처는 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 한다

웹도 미룰 사항이다

=== 프레임워크는 도구일 뿐

프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발해야 한다

=== 테스트하기 쉬운 아키텍처

프레임워크가 없더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다

== 22. 클린 아키텍처

시스템 아키텍처와 관련된 아이디어들 - 공통의 목표로 관심사의 분리

* 육각형 아키텍처, DCI (Data, Context and Interaction), BCE (Boundary-Control-Entity)

프레임워크 독립성, 테스트 용이성, UI, DB, 외부 에이전시에 대한 독립성을 갖는 특징

=== 의존성 규칙

그림 22.1 에서 안으로 들어갈 수록 고수준의 소프트웨어, 바깥쪽은 메커니즘, 안은 정책

[quote]
소스 코드 의존성을 반드시 안쪽으로, 고수준의 정책을 향해야 한다

내부 요소는 외부를 모른다

==== 엔티티

핵심 업무 규칙을 캡슐화 - 메소드를 가진 객체 or 데이터 구조 & 합수의 집합의 형태

외부의 무언가가 변경되더라도 엔티티가 변경될 가능성은 낮다 +
애플리케이션에 변경이 필요하더라도 엔티티 계층에는 영향을 주어서는 안된다

==== 유스케이스

애플리케이션에 특화된 업무 규칙 포함 +
시스템의 모든 유스케이스를 캡슐화, 구현

==== 인터페이스 어댑터

데이터를 유스케이스와 엔티티에게 편리한 형식 -> 외부 에이전시에게 편리한 형식으로 변환

Presenter, View, Controller

영속성 프레임워크가 이용하기 편리한 형식으로 변환 - DB 에 대해서 알아서는 안됨 +
(여기 코드에서 DB 를 알면 안되지만, SQL 은 여기를 벗어나서는 안된다)

==== 프레임워크와 드라이버

==== 원이 꼭 네 개여야 하는건 아님

더 많이 필요할 수도 - 안쪽으로 이동할수록 추상화와 정책의 수준이 높아지고 +
바깥쪽은 저수준의 구체적인 세부사항

==== 경계 횡단하기

제어흐름과 의존성의 방향이 반대면 의존성 역전 원칙으로 해결

==== 경계를 횡단하는 데이터의 모습?

기본적인 구조체 or dto 등 원하는대로 고를 수 있다

데이터를 전달할 때 내부의 원에서 사용하기에 편리한 형태를 가져야만 한다

== 23. 프레젠터와 험블 객체

프레젠터는 험블 객체 패턴을 따른 형태. 아키텍처 경계를 식별하고 보호하는 데 도움

=== 험블 객체 패턴

테스트하기 어려운 행위와 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법

본질을 남기고 테스트하기 어려운 행위를 험블 객체로 옮기기

ex. GUI 를 프레젠터와 뷰로 나누기

=== 프레젠터와 뷰

뷰 = 험블 객체, 테스트하기 어려움. 가능한 간단하게 유지 +
프레젠터 = 애플리케이션에서 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것

=== 테스트와 아키텍처

테스트 용이성은 좋은 아키텍처가 지녀야 할 속성이다

험블 객체 - 분리로 아키텍처의 경계 정의 (프레젠터와 뷰)

=== 데이터베이스 게이트웨이

=== 데이터 매퍼

ORM, 데이터 매퍼는 DB 계층에 위치해야 한다

ORM 은 게이트웨이 인터페이스와 DB 사이에서 험블 객체 경계를 형성

=== 서비스 리스너

다른 서비스와 통신, 서비스를 제공해야 한다면 +
데이터를 간단한 데이터 구조 형태로 로드, 이 구조를 특정 모듈로 전달

수신하는 서비스 리스너는 서비스 인터페이스로부터 데이터를 수신, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경

