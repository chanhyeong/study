= 7. 가치 있는 단위 테스트를 위한 리팩토링

좋은 단위 테스트 스위트의 속성 - 개발 주기에 통합, 가장 중요한 코드베이스, 최소한의 유지비로 최대의 가치

가치 있는 테스트 - 회귀 방지, 리팩토링 내성, 빠른 피드백, 유지보수성

== 리팩토링할 코드 식별하기

=== 코드의 네 가지 유형

제품 코드의 2차원 뷴류

* 복잡도 (분기 지점 수) or 도메인 유의성 (문제 도메인에 대해 얼마나 의미 있는지)
* 협력자 수
** 협력자가 많으면 비용이 많이 든다
** 유형도 중요한데, 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안된다 - 복잡한 mock 으로 인한 유지비

이를 종합한 코드 유형

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/07fig02_alt.jpg[]

* 도메인 모델, 알고리즘
** 문제 도메인과 직접적인 관련이 없는 복잡한 알고리즘이 있을 수 있다
** 단위 테스트: 매우 가치 있고 저렴 - 회귀 방지 향상, 협력자가 거의 없어 유지비 적음
* 간단한 코드
** 매개변수가 없는 생성자, 한 줄 속성
** 단위 테스트: 테스트 가치가 0 이어서 필요가 없음
* 컨트롤러
** 도메인 클래스와 외부 애플리케이션 등의 다른 구성 요소의 작업 조정
** 단위 테스트: 통합 테스트의 일부로써 간단히 테스트
* 지나치게 복잡한 코드
** 협력자가 많으며 복잡하거나 중요
** 단위 테스트: 어려움, 테스트 커버리지가 없으면 너무 위험

코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다 +
*지나치게 복잡한 코드 -> 알고리즘 or 컨트롤러로 나누는* 것이 일반적이다

=== Humble Object 패턴을 사용해 지나치게 복잡한 코드 분할

xUnit 테스트 패턴에서 소개

테스트가 가능한 부분을 추출 +
humble wrapper: 테스트 가능한 부분을 둘러싼 코드

.humble object 패턴
image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/07fig04_alt.jpg[]

.함수형 아키텍처와 육각형 아키텍처의 예
image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/07fig05_alt.jpg[]

SRP (Single Responsibility principle): 클래스가 단일한 책임만 가져야 한다

.코드가 깊거나 넓을 수 있지만 둘 다 가능하지 않다 (비즈니스 로직과 오케스트레이션을 분리)
image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/07fig06.jpg[]

테스트 용이 + 코드 복잡도 해결 -> 프로젝트 성장에도 중요한 역할

==== 기타 다른 예시

MVP, MVC, DDD Aggregate

== 가치 있는 단위 테스트를 위한 리팩토링하기

User 클래스의 초기 구현 (p236 ~ 248) - 2가지 차원에서 모두 높은 점수이므로 지나치게 복잡한 코드

현재와 같은 패턴 = Active Record = 도메인 클래스가 스스로 DB 를 검색하고 다시 저장하는 방식

=== 암시적 의존성을 명시적으로 만들기

Database, MessageBus 에 대한 인터페이스를 두고 +
인터페이스를 User 에 주입한 후 테스트에서 mock 으로 처리

하지만 mock 을 위해 테스트 유지비가 증가 +
mock 을 DB 의존성에 사용하면 테스트 취약성을 야기할 수 있다 (다음장)

도메인 모델은 프로세스 외부 협력자에게 의존하지 않는 것이 좋다 +
도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.

=== 애플리케이션 서비스 계층 도입

외부 시스템과 통신은 humble controller 로 책임을 옮겨야 한다

예제 7.2 의 수정으로 User 는 테스트하기 쉬워졌으나 p240 의 단점들. 다음 단계에서 수정

=== 애플리케이션 서비스 복잡도 낮추기

(DB 에서 가져와서 클래스 인스턴스화 하는 로직 간소화하기) +
ORM 을 두어 매핑 or (ORM 을 사용할 수 없으면) 팩토리 클래스 (메소드) 작성

=== 새 Compnay 클래스

회사 관련 로직과 데이터를 함께 묶는 `Company` 클래스 생성 (+ `CompanyFactory`)

모든 부작용이 메모리에 남아있으므로 테스트하기 매우 쉬워졌다 +
외부 의존성 검사 & 통신 기반 테스트 의존 X +
출력 기반 테스트 & 상태 기반 테스트로 모든 검증 수행 가능

== 최적의 단위 테스트 커버리지 분석

비즈니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트 단위로 할지 쉽게 결정할 수 있다

=== 도메인 계층과 유틸리티 코드 테스트하기

코드 복잡도 or 도메인 유의성이 높음 (회귀 방지 뛰어남), 협력자가 적음 (유지비 적음) +
p249

=== 나머지

* 복잡도가 낮음, 협력자가 거의 없음: 단순해서 테스트할게 없다
* 복잡도가 낮음, 협력자가 많음: 다음장

=== Precondition 을 테스트해야 하는가?

일반적으로 *도메인 유의성이 있는 모든 전제 조건을 테스트* 하는 것을 권장

도메인 유의성이 없는건 필요 없다

== 컨트롤러에서 조건부 로직 처리

저장소에서 검색 -> 로직 실행 -> 다시 저장 시 위에서 봤던 분리가 효과적이다 +
하지만 아래 그림과 같이 중간 결과로 또 조회해서 할 수도 있다

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/07fig11_alt.jpg[]

이때는? 3가지 방법

* 모든 read/write 를 가장자리로 밀어낸다
** 구조를 유지하지만 성능이 저하된다 = 필요하지 않아도 프로세스 외부 의존성을 호출
** 성능 저하
** 성능이 매우 중요하므로 고려할 필요가 없다
* 도메인 모델에 프로세스 외부 의존성을 주입하고 비즈니스 로직이 호출할 시점을 직접 결정
** 도메인 모델의 테스트 유의성이 떨어짐
** 위에서 리팩토링하기 전으로 돌아가므로 피하는 것이 좋다
* 의사 결정 프로세스 단계를 더 세분화하여 각 단계별 컨트롤러를 실행
** 컨트롤러가 단순하지 않음
** 복잡해지지만 완하할 수 있는 방법이 있다 (CanExecute/Execute)

세 가지 특성의 균형을 맞추어야 하는데, 위에 3개는 2가지 특성만 갖는다 (상위 추가)

* 도메인 모델 테스트 유의성: 도메인 클래스의 협력자 수와 유형에 따른 함수
* 컨트롤러 단순성: 분기 지점의 여부에 따라 다름
* 성능: 프로세스 외부 의존성을 호출하는 수로 정의

=== CanExecute/Execute 패턴 사용

비즈니스 로직이 컨트롤러로 유출되는 것을 방지하는 것

p256 예시

* 이메일 변경 진행 여부 (컨트롤러)
* 변경 작업 (도메인 모델)

도메인 모델의 캡슐화가 떨어짐 (파편화) +
비즈니스 로직과 오케스트레이션 간 분리가 방해, 지나치게 복잡한 위험 영역에 더 가까워진다

패턴을 적용하면 (예제 7.10) 다음과 같은 이점

* 컨트롤러는 연산을 수행할 수 있는지 확인만 하면 된다. 관련 로직이 컨트롤러로부터 캡슐화
* 실제 실행 시 전제 조건을 다시 확인 -> 통과되지 않으면 실행이 불가능함을 보장

=== 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

도메인 이벤트: 애플리케이션 내에서 도메인 전문가에게 중요한 이벤트 +
시스템에서 발생하는 중요한 변경 사항을 외부 앱에 알리는데 사용

비즈니스 연산이 완료된 후 변경 사항을 프로세스 외부 의존성 호출로 변환

예시에는 현재 컨트롤러에서 메시지를 보내는 부분이 있음 +
CanExecute 에서는 오류를 반환하는데, 여기서는 오류를 반환하면 안된다

도메인 이벤트는 외부 시스템에 통보하는 데 필요한 데이터가 포함된 클래스 (p260) +
이미 일어난 일들을 나타내기 때문에 과저 시제로 명명해야 한다

로직에서 이벤트 컬렉션에 저장 -> 컨트롤러에서 꺼내서 발행 (별도의 이벤트 디스패처를 둘 수도..)

의사 결정 책임을 도메인 모델에 적용함으로써 외부 시스템과의 통신에 대한 단위 테스트를 간결하게 한다 +
mock 대체 대신 단위 테스트에서 직접 도메인 이벤트 생성을 테스트할 수 있다

https://enterprisecraftsmanship.com/posts/merging-domain-events-dispatching/[발송 전 도메인 이벤트 병합 (책에 나온 링크 대체)]

== 결론

비즈니스 연산이 끝날 때까지 부작용을 메모리에 두어 추상화

CanExecute/Execute 패턴을 항상 할 수는 없다 +
불가피한 예시) 컨트롤러 외부에서 이메일 고유성을 검증, 비즈니스 연산 과정을 변경해야 하는 프로세스 외부 의존성의 실패 +
이러한 경우는 컨트롤러에 넣고 통합 테스트로 처리해야 한다

협력자와 상호 작용을 검증하려고 mock 을 사용하지는 마라

식별할 수 있는 동작이 되려면 2가지 중 하나를 충족해야 한다

* 클라이언트 목표 중 하나에 직접적인 연관
* 외부 앱에서 볼 수 있는 프로세스 외부 의존성에서 부작용이 발생

식별할 수 있는 동작과 구현 세부 사항을 여러 겹으로 생각 -> 외부 계층의 관점에서 각 계층을 테스트, 내부가 어떻게 통신하는지는 무시