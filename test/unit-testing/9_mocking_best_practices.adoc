= 9. 목 처리에 대한 모범 사례

mock 에 대해 리팩토링 내성과 회귀 방지를 최대화하는 지침

일반적인 mock 사용법 & 단점 및 극복 방안

== mock 의 가치를 극대화하기

앞선 예제들에서는 "비관리 의존성에만 mock 을 사용하기" +
이제 mock 에 대해 테스트를 개선할 수 있는 다른 방법들

=== 시스템 끝에서 상호 작용 검증하기

TIP: 시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라

예제 9.3) `messageBusMock` 의 문제 - `IMessageBus` 인터페이스가 시스템 끝에 있지 않다

내부 자체 정의인 `IMessageBus` 대신 제일 마지막 고리인 `IBus` 를 mock 으로 처리 +
-> 회귀 방지가 좋아지고, 리팩토링 내성도 향상 (코드베이스와의 결합도가 낮기 때문)

TIP: 비관리 의존성이 애플리케이션을 떠나기 전 제일 마지막 단계를 선택해라

(그래서 wiremock 같은게 있는 듯)

=== mock 을 spy 로 대체하기

spy 는 수동, mock 은 mock framework

시스템 끝에 있는 클래스의 경우 spy > mock +
검증 단계에서 코드를 재사용해 테스트 크기를 줄이고 가독성 향상

예제 9.6 BusSpy +
-> fluent interface (method chaining 을 기반), 테스트에서 사용할 추가적인 메소드 구현

(Spy 라는게 기존 구현을 그대로 사용하고 특정 동작만 대체하는줄 알았는데, 아니었나보다)

테스트를 감시자로 생각하여 모든 것을 재확인하도록 한다 +
IMessageBus 를 mock 으로 처리하면 제품 코드에 의존하게 된다 (그만큼 IMessageBus 의 실제 구현이 아닌거로 대체된다?)

(더 윗 단에서 mock 처리가 필요하다면, 하나하나 다 채워서 넣어줘야 하는 공수가 들어갈 것 같다. 어떻게 할지? 이 경우에는 대체가 불가능할지? end-to-end 테스트를 해야할지?)

== mock 처리에 대한 모범 사례

=== 통합 테스트에서만 mock 을 사용

단위 테스트에서 mock 을 사용하면 안된다 - 비즈니스 로직과 오케스트레이션의 분리

도메인 모델 - 단위 테스트 +
컨트롤러 - 통합 테스트 (mock 은 비관리 의존성에만 해당)

=== 테스트 당 mock 이 하나일 필요는 없다

동작 단위 구현에 필요한 mock 의 수는 관계가 없다 +
mock 의 수는 운영에 참여하는 비관리 의존성 수에만 의존

=== 호출 횟수 검증하기

비관리 의존성과의 통신은 아래 2개를 모두 확인하는게 중요

* 예상하는 호출이 있는지? (외부 시스템이 예상하는 메시지를 생략하면 안된다)
* 예상치 못한 호출은 없는지? (예상치 못한 메시지도 생성하면 안된다)

=== 보유 타입만 mock 으로 처리하기

서드파티 라이브러리 위에 항상 어댑처 작성, 어댑터를 mock 으로 처리해야 한다

* 서드파티 코드의 작동 방식을 깊게 이해 못하는 경우가 많음
** -> 기본 라이브러리의 복잡성을 추상화
* 인터페이스를 제공하더라도 mock 으로 처리한 동작이 실제 외부 라이브러리와 일치하는지 확인해야 하므로, 그대로 사용하는건 위험하다
** (???) 어댑터의 동작까지 확인해야 한다는 의미?
** -> 라이브러리에서 필요한 기능만 노출
* 서드파티의 기술 세부 사항까지는 필요하지 않으니 어댑터는 추상화, 애플리케이션 관점에서 라이브러리와의 관계 정의
** -> 프로젝트 도메인 언어를 사용해 수행할 수 있음

라이브러리가 깔끔한 인터페이스를 제공하더라도 고유의 wrapper 를 그 위에 두는 것이 좋다 +
(사실 이건 구현할 때는 좋은데 나중에 누가 관리할 때는 별로인 것 같다, 하나의 계층이 더 생기는 느낌)

프로세스 내부 의존성에는 적용되지 않는다