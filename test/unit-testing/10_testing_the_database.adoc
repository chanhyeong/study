= 10. 데이터베이스 테스트

DB 테스트를 위한 준비 단계를 볼 예정 +
상태 기반보다 마이그레이션 기반을 선택해야 하는 이유

트랜잭션을 관리하는 방법, 남은 데이터를 정리하는 방법, ...

== 전제 조건

=== 데이터베이스를 형상 관리 시스템에 유지

schema 를 일반 코드로 취급

p333 그림처럼 모델 DB 를 사용하는 것은 좋지 못한 방법 +
-> 변경 내역 부재: 과거로 돌릴 수 없음, 운영에서 버그 재현 시 중요
-> 복수의 원천 정보: 개발 상태에 대한 원천 정보를 두고 경합. Git - Model DB 로 두면 부담 가중

*형상 관리 시스템에 두면 원천 정보를 하나로 할 수 있고, 변경을 추적할 수 있다*

=== 참조 데이터도 데이터베이스 스키마다

schema: table, view, index, stored procedure, ...

참조 데이터 (reference data): 애플리케이션이 제대로 작동하도록 미리 채워야 하는, 수정할 수 없는 데이터 +
(일반 데이터: 애플리케이션이 수정할 수 있는 데이터)

참조 데이터도 다른 스키마와 마찬가지로 SQL INSERT 형식으로 형상 관리 시스템에 저장해야 한다

=== 모든 개발자를 위한 별도의 데이터베이스 인스턴스

테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스 사용

(테스트 컨테이너를 띄우는게 도움이 되는거일수도)

=== 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포

==== 상태 기반

* 유지보수하는 모델 DB 가 있음
* 배포 중 비교 도구가 스크립트를 생성하여 운영 DB 를 최신 상태로 유지
** 스크립트는 형상 관리에 저장
* 비교 도구가 모든 어려운 작업 수행
** 불필요한 테이블 삭제, 새 테이블 생성, 컬럼명 변경 등 동기화에 필요한 모든 작업

==== 마이그레이션 기반

* 다음 버전으로 전환하는 명시적인 마이그레이션
* 자동으로 동기화를 위한 도구 사용 X, 스크립트 직접 작성
* 마이그레이션 SQL 스크립트 (or DSL) 를 형상 관리에 저장
** p336

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/10fig02_alt.jpg[]

==== 차이

* 상태 기반: 상태를 명시하고 비교 도구가 마이그레이션을 암묵적으로 제어
* 마이그레이션 기반: 마이그레이션을 명시하고 상태를 암묵적으로 둠

DB 상태가 명확하면 *병합 충돌* 을 처리하기 수월, 명시적 마이그레이션은 *데이터 모션* (새로운 스키마를 준수하도록 기존 데이터 형태를 변경하는 과정) 문제를 해결하는데 도움

* Name -> FirstName, LastName
** 상태 변경에서는 쉽지 않다

마이그레이션이 커밋된 후에는 수정하지 말고 +
마이그레이션을 수정하는 대신 새 마이그레이션 생성

== 트랜잭션 관리

=== 제품 코드에서 데이터베이스 트랜잭션 관리하기

데이터 변경이 포함되는 연산이 포함된 모든 업데이트는 atomic 해야한다

결정 유형을 두 가지로 나눠야 한다

* 업데이트할 데이터 - repository (DB 의 데이터 접근과 수정을 가능하게 함)
* 업데이트 유지 또는 롤백 여부 - transaction (데이터 업데이트를 완전히 커밋하거나 롤백)

.트랜잭션이 컨트롤러 - 데이터베이스 간 상호 작용 조정, 원자적 데이터 수정
image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/10fig05_alt.jpg[]

commit 은 의사 결정이 필요 -> 컨트롤러가 함 +
dispose 는 의사 결정이 필요하지 않음 -> 인프라 계층에 메소드 호출 위임할 수 있음

repository 는 항상 transaction 위에서 작동하며, 스스로 DB 를 호출할 수 없다

.Transaction 클래스를 작업 단위 (unit of work) 로 업그레이드 - ORM 에서 제공
image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/10fig06_alt.jpg[]

.비관계형 DB 에서의 데이터 모든
****

한 번에 둘 이상의 document 를 수정하는 비즈니스 연산이 없더록 설계해야 한다 +
(document 가 row 보다 유연하므로)
****

=== 통합 테스트에서 데이터베이스 트랜잭션 관리하기

테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말 것

p348 코드 - arrange, act, assert 세 구절에 동일한 context 를 재사용 +
-> 컨트롤러가 운영 환경에서 하는 것과 다른 환경을 만드는 문제

통합 테스트에서는 개별 transaction or 작업 단위를 사용해야 한다

== 테스트 데이터 생명 주기

공유 DB 사용 = 통합 테스트를 서로 분리할 수 없는 문제 +
문제를 해결하려면

* 통합 테스트를 순차적으로 실행
* 테스트 실행 간에 남은 데이터 제거

테스트는 DB 상태에 따라 달라지면 안된다

=== 병렬 테스트 실행, 순차적 테스트 실행

병렬 - 모든 테스트 데이터가 고유한지 확인해야 DB 제약 조건을 위반하지 않고, 다른 테스트에 영향도 없음

통합 테스트는 병렬 처리 비활성화, 단위 테스트만 병렬 처리 활성화

컨테이너를 사용해 병렬 처리할 수도 - 모델 DB 를 이미지로 만들어서 컨테이너 인스턴스화 +
다만 단점은

* 도커 이미지 유지 보수, 테스트마다 컨테이너 인스턴스 존재 여부 확인
* 통합 테스트 일괄 처리, 사용한 컨테이너 폐기

통합 테스트의 실행 시간을 최소화가 아니라면 컨테이너를 사용하지 않는 것이 좋음

=== 테스트 실행 간 데이터 정리

* 각 테스트 전 DB 백업 복원: 느림
* 테스트 종료 시점에 데이터 정리: 정리 단계를 건너뛰기 쉬움 - 테스트 도중 서버 중단, 디버거에서 테스트 종료 등
* DB 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기: 추가 트랜잭션으로 인해 운영 호나경과 다른 설정 생성되는 문제
* 테스트 시작 시점에 데이터 정리: 가장 좋음 - 빠르게 작동, 일관성, 정리를 건너뛰지 않음

*별도의 종료는 필요 없고 준비 단계에서 구현*

*통합 테스트의 기초 클래스를 두고, 기초 클래스에 삭제 스크립트를 작성*

=== 인메모리 데이터베이스 피하기

일반 DB 와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다

== 테스트 구절에서 코드 재사용

통합 테스트는 가능한 짧게, 서로 결합하거나 가독성에 영향을 주지 않는 것이 중요

비즈니스와 관련이 없는 기술적인 부분을 *비공개 메소드나 헬퍼 클래스* 로 추출

=== 준비 구절에서 코드 재사용

p356 부터 예제들 - Object Mother +
테스트 픽스처를 만드는데 도움이 되는 클래스, 메소드

테스트 데이터 빌더 - 위와 유사하지만 fluent interface 를 제공 +
가독성을 향상시키지만 상용구가 너무 많이 필요

기본적으로 팩토리 메소드를 동일한 클래스에 두고, 문제가 될 경우에만 별도의 헬퍼 클래스로 이동 +
(통합 테스트) 기초 클래스는 넣지 말아야 한다

=== 실행 구절에서 코드 재사용

컨트롤러 기능을 호출해야 하는지 정보를 갖는 delegate 를 받는 메소드 도입 - 예제 10.11

=== 검증 구절에서 코드 재사용

* 준비에서와 유사한 헬퍼 메소드를 두기
* 데이터 검증을 위한 fluent interface 두기

=== 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?

트랜잭션 수가 증가하는 것은 어쩔 수 없다 +
빠른 피드백과 유지 보수성 간의 절충

DB 가 개발자 머신에 있는 경우 성능 저하가 더 크지 않을 것

== 데이터베이스 테스트에 대한 일반적인 질문

=== Read 테스트 필요?

write 는 위험성이 높기 때문에 중요 +
read 는 이에 해당되지 않음

가장 복잡하거나 중요한 읽기 작업만 테스트하고, 나머지는 무시

읽기는 도메인 모델이 필요 없고, 추상화 계층이 거의 없어서 단위 테스트가 소요이 없다

=== Repository 테스트 필요?

다른 통합 테스트와는 독립적으로 테스트해야 하는가? +
repository 가 도메인 객체를 DB 에 매핑하는 기능을 테스트 - 실수가 있을 여지 +
유지비가 높고 휘귀 방지가 떨어짐

repository 는 그렇게 복잡하지 않음, 회귀 방지에서 일반적인 통합 테스트의 이점과 겹침 - 추가적인 가치 없음

repository 가 갖고 있는 알고리즘을 추출하고 해당 알고리즘 전용 테스트 작성 +
ORM 을 사용하면 분리가 불가능한데 -> 직접 테스트하지 말고 포괄적인 통합 테스트의 일부로 취급하라

