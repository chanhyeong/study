= 2. 단위 테스트란 무엇인가

== '단위 테스트'의 정의

3가지 속성

* 작은 코드 조각을 검증
* 빠르게 수행
* 격리된 방식으로 처리하는 자동화된 테스트
** 고전파 (classical school) 와 런던파 (London school) 를 구분

=== 격리 문제에 대한 런던파의 접근

격리된 방식으로 검증한다는 무엇인가? +
-> 런던파에서는 테스트 대상 시스템을 협력자 (collaborator) 에게서 격리하는 것을 의미

하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 모든 의존성을 테스트 대역 (test double) 로 대체 +
-> 동작을 외부 영향과 분리. 테스트 대상 클래스에만 집중할 수 있다

장점

* 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다
* 객체 그래프 (object graph) 를 분할할 수 있다
** test double 을 사용하면 객체 그래프를 다시 만들지 않아도 된다
** 직접적인 의존성을 대체할 수 있고, 의존성의 의존성을 다룰 필요 없다
* 한 번에 한 클래스만 테스트 -> 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다 (그림 2.2)

==== AAA 패턴 (Arrange, Act, Assert (준비, 실행, 검증))

. Arrange
** 의존성과 테스트 대상 시스템 (SUT, System Under Test) 을 준비
. Act
** 검증하고자 하는 동작 수행
. Assert
** 동작이 예상 결과로 이어지는지 확인

MUT (Method Under Test) 는 테스트에서 호출한 SUT 의 메소드

==== 고전, 런던 예시 (p55 ~ 58)

* 고전에서는 Store 를 실제 그대로 사용
* 런던에서는 Mock 으로 교체
** Mock = 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역
** JAVA 기준 Mockito, JMock, EasyMock
** 예시에서는 인터페이스를 mock 으로 만듦

test double 과 mock 의 관계 (기술적 차이는 5장에서)

* test double 은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어
* mock 은 그 중 하나일 뿐

8장에서는 인터페이스 작업에 대해 설명 +
concrete class 도 mock 으로 만들 수 있지만 안티패턴, 11장에서 나옴 +

=== 격리 문제에 대한 고전파의 접근

고전적인 방법에서 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다. +
대신 단위 테스트는 서로 격리해서 실행해야 한다. -> 테스트를 어떤 순서로든 가장 적합한 방식으로 실행할 수 있으며, 서로의 결과에 영향을 미치지 않는다

.공유 의존성, 비공개 의존성, 프로세스 외부 의존성
****

shared dependency: 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성 +
static mutable field, DB 등

private dependency: 공유하지 않는 의존성

out-of-process dependency: 애플리케이션 실행 프로세스 외부에서 실행되는 의존성, 아직 메모리에 없는 데이터에 대한 proxy

****

mock 과 test double 을 적당히 쓰려는 견해가 있다 +
test double 을 사용할 수 있지만 공유 상태를 일으키는 의존성에 대해서만 사용

공유 의존성은 테스트 대상 클래스가 아니라 단위 테스트 간 공유 +
-> singleton 은 각 테스트에서 새 인스턴스를 만들 수 있기만 하면 공유되지 않는다

ex) configuration class 는 일반적으로 한개, 모든 코드에서 인스턴스 재사용 +
생성자 등으로 다른 모든 의존성이 SUT 에 주입되면 각 테스트에서 새 인스턴스를 만들 수 있음

새 파일 시스템이나 DB 를 만들 수는 없으며, 테스트 간에 공유되거나 test double 로 대체되어야 한다

.공유 의존성과 휘발성 의존성
****

volatile dependency 는

. 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성 요구 (DB, API service 등)
. 비결정적 동작 (nondeterministic behavior) 포함
** 난수 생성기 or 현재 날짜와 시간을 반환하는 클래스 등

파일 시스템은 휘발성이 아님 +
난수 생성기는 공유 의존성이 아님

****

공유 의존성을 대체하는 또 다른 이유 = 테스트 실행 속도를 높이기

단위 (작은 코드 조각) 를 구성하는 것에 대한 다른 견해 +
-> 단위가 반드시 클래스에 국한될 피룡는 없다. 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수도 있다

== 단위 테스트의 런던파와 고전파

런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 봄, 고전파는 단위 테스트끼리 격리하는 것으로 봄

.런던파 고전파의 차이
[cols="1,1,2,2"]
|===
| |격리 주체 |단위의 크기 |test double 사용 대상

|런던파 |단위 |단일 클래스 |불변 의존성 외 모든 의존성

|고전파 |단위 테스트 |단일 클래스 또는 클래스 세트 |공유 의존성
|===

=== 고전파와 런던파가 의존성을 다루는 방법

런던파: 테스트에서 일부 의존성을 그대로 사용할 수 있도록 함 (예시에서는 enum Product) +
-> 불변 객체 = value object or value = 각각의 정체성이 없고 내용에 의해서만 식별

고전파에서는 공유 의존성을 test double 로 +
런던파에서는 변경 가능한 한 비공개 의존성도 test double 로 교체 가능

.협력자 vs 의존성
****

collaborator: 공유하거나 변경 가능한 의존성

Product, 숫자 5는 의존성이지만 협력자는 아님. value or value object

collaborator: Store, dependency: Product.Shampoo, 5

****

공유 의존성은 대부분 프로세스 외부에 있지만, 그 반대는 그렇지 않다 +
(하지만 실제 프로젝트에서는 반대가 그런 경우는 거의 없다)

변경하는 기능을 노출하지 않는 한 공유 의존성이 아니다 +
프로세스 외부 의존성이 충분히 빠르고 연결이 안정적이면 테스트에서 그대로 사용하는 것도 괜찮다 +
(배송이 이런 케이스인듯)

== 고전파와 런던파의 비교

런던파 장점

* 입자성 (granularity) 가 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인
* 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다
* 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다

(아래는 런던파의 장점에 대해 반박하는? 느낌으로 쓴 듯)

=== 한 번에 한 클래스만 테스트

TIP: 테스트는 코드 단위를 검증하는게 아니라 동작의 단위로 검증해야 한다 +
동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다 - 단위가 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 아주 작은 메소드가 될 수 있음

=== 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 이러한 클래스 그래프를 갖지 않는데 집중해야 한다. - 코드 설계 문제의 결과

mock 을 사용하는건 문제를 감추기만 할 뿐 원인 해결을 못한다 - 2부에서 설계 문제 해결 방법 예정

=== 버그 위치 정확히 찾아내기

런던 스타일은 SUT 에 버그가 포함된 테스트만 실패, 고전은 오작동하는 클래스를 참조하는 다른 테스트도 실패

테스트 스위트에 걸쳐 계단식으로 실패하는 데 가치가 있다 = 전체 시스템이 그것에 의존한다 = 코드 작업 시 명심해야 할 유용한 정보

=== 고전파와 런던파 사이의 다른 차이점

* 테스트 주도 개발을 통한 시스템 설계 방식
* 과도만 명세 문제

==== 런던파

하향식 TDD, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작 +
mock 을 사용해 협력자 지정 +
모든 협력자를 차단해 해당 협력자의 구현을 나중으롬 ㅣ룰 수 있음

==== 고전파

상향식, 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 위에 더 둔다

가장 큰 차이는 과도한 명세 문제 = 테스트가 SUT 의 구현 세부 사항에 결합되는 것 +
런던파가 더 자주 결합되는 편

== 두 분파의 통합 테스트

런던파: 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주

고전파의 관점에서 단위 테스트는

* 단일 동작 단위를 검증
* 빠르게 수행
* 다른 테스트와 별도로 처리

통합 테스트는 이 기준 중 하나를 충족하지 않는 테스트

둘 이상의 동작 단위를 검증할 때의 테스트 = 느린 테스트가 2개 있을 때 하나로 합치는 등 (테스트 2개보다 하나가 더 빠를 때)

=== 통합 테스트의 일부인 엔드 투 엔드 테스트

통합테스트 = 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트

end-to-end test: 통합 테스트의 일부, 일반적으로 의존성을 더 많이 포함한다

일반적으로 통합 테스트는 프로세스 외부 의존성을 한두 개만 갖고 작동 +
end-to-end 는 전부 or 대다수 갖고 작동 = 모든 외부 애플리케이션을 포함 해 시스템을 최종 사용자의 관점에서 검증하는 것 +
비슷하게 UI test, GUI test, functional test 같은 용어도 사용

end-to-end test 는 유지 보수 측면에서 가장 비용이 많이 들기 때문에, 모든 단위 테스트와 통합 테스트를 통과 한 후 빌드 프로세스 후반에 실행하는 것이 좋다

