= 4. 좋은 단위 테스트의 4대 요소

앞서는 좋은 단위 테스트 스위트의 특성을 살펴봤다

* 개발 주기에 통합. 실제로 사용하는 테스트에만 가치가 있음
* 코드베이스의 가장 중요한 부분만 대상
* 최소한의 유지비로 최대 가치를 끌어냄
** 가치 있는 테스트 식별
** 가치 있는 테스트 작성

== 좋은 단위 테스트의 4대 요소 자세히 살펴보기

=== 첫 번째 요소: 회귀 방지 (Protection against regressions)

회귀: 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우

회귀에 대해 효과적인 보호를 개발하는 것이 중요하다

* 테스트 중에 실행되는 코드의 양
** 실행되는 코드가 많을수록 회귀가 나타날 가능성이 높다
* 코드 복잡도
* 코드의 도메인 유의성
** 복잡한 비즈니스 로직을 나타내는 코드가 유틸성 코드 (boilerplate code) 보다 중요하다

최상의 보호를 위해서는 테스트가 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 +
의존성에 대해 검증이 올바른지 확인한다

TIP: 회귀 방지 지표를 극대화하려면 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야한다

=== 두 번째 요소: 리팩토링 내성 (Resistance of refactoring)

테스트를 실패로 바꾸지 않고 기본 애플리케이션 코드를 리팩토링할 수 있는지에 대한 척도

false positive: 실제로는 의도한 대로 작동하지만 (문제 없지만) 실패로 판별되는 (양성으로 나오는) 경우 +
전체 테스트 스위트에 치명적인 영향을 줄 수 있다

* 테스트가 이유 없이 실패하면 코드 문제에 대응하는 능력과 의지가 희석된다
** 실패에 익숙해지고 신경을 쓰지 않는다 -> 타당한 실패도 무시하여 기능이 고장나도 운영에 들어감
* 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 못 믿게 되고 인식이 나빠진다
** 신뢰가 부족해지만 리팩토링이 줄어든다

올바른 대응은 테스트 스위트를 다시 살펴보고 안전성을 높이는 것 - 7장에서 다룰 예정

=== 무엇이 거짓 양성의 원인인가?

*테스트와 테스트 대상 시스템의 구현 세부 사항이 많이 결합할수록* false positive 가 많이 생긴다 +
구현 세부 사항에서 테스트를 분리하는게 좋다

테스트는 최종 사용자의 관점에서 SUT 를 검증해야 하고, 최종 사용자에 의미 있는 결과만 확인해야 한다

=== 구현 세부 사항 대신 최종 결과를 목표로 하기

클래스에서 얻을 수 있는 관찰 가능한 결과를 검증

예제 4.2 (p121) 에서는 만든 클래스에 대한 구성 요소를 직접 꺼내서 검증 +
예제 4.4 (p124) 에서는 만든 클래스 (블랙박스) 의 메소드 수행 결과를 검증

(결과를 db 에서 읽어와서 하는 방식은 잘못된건가)

== 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

=== 테스트 정확도 극대화

[cols="1,2,2"]
|===
|구분 |기능 작동| 기능 고장
|테스트 통과 |올바른 추론| 2종 오류 +
false negative +
회귀 방지에서 보호

|테스트 실패 |1종 오류 +
false positive +
리팩토링 내성에서 보호
| 올바른 추론
|===

테스트 스위트의 정확도를 극대화하는 것을 목표, 정확도 지표

. 테스트가 버그 있음을 얼마나 잘 나타내는가 (false negative)
. 테스트가 버그 없음을 얼마나 잘 나타내는가 (false positive)

----
테스트 정확도 = 신호 (발견된 버그 수) / 소음 (허위 경보 발생 수)
----

=== 거짓 양성과 거짓 음성의 중요성: 역학 관계

초기에는 false positive 가 중요하지 않다 - 리팩토링은 시간이 지나면서 중요해지기 때문

p128 그림

false positive, false negative 둘 다 똑같이 중요하게 다뤄야 한다

== 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

* 빠른 피드백 (Fast feedback)
** 빠른 테스트: 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있음
** 결함이 생기자마자 버그에 대해 경고, 피드백 루프를 줄여서 비용 줄이기
* 유지 보수성 (maintainability)
** 테스트가 얼마나 이해하기 어려운가: 테스트는 코드 라인이 적을수록 더 읽기 쉽다
** 테스트가 얼마나 실행하기 어려운가: 테스트가 외부 종속성으로 작동하면, 의존성을 상시 운영하는데 시간

== 이상적인 테스트를 찾아서

앞서 4가지를 곱하면 테스트의 가치가 결정, 어떤 특성이라도 0 이면 전체가 0

[quote]
가치 추정치  = [0..1] * [0..1] * [0..1] * [0..1]

임계치를 높게 설정하고 충족하는 테스트만 테스트 스위트에 남겨라

=== 이상적인 테스트를 만들 수 있는가?

회귀 방지, 리팩토링 내성, 빠른 피드백 첫 3개는 상호 배타적이어서 하나를 희생해야 나머지 2개를 최대로 할 수 있다 (왜? - 아래 예시로)

다음 3개는 하나를 거의 포기하여 0 으로 만든 예시

=== 극단1: 엔드 투 엔드 테스트

최종 사용자의 관점에서 시스템을 살펴본다 - UI, DB, 외부 애플리케이션을 포함한 모든 시스템 구성요소

많은 코드를 테스트하므로 회귀 방지 높음 +
false positive 에 먼역이 돼 리팩토링 내성도 우수

느린 속도

=== 극단2: 간단한 테스트

빠른 피드백 +
false positive 가능성이 낮아 리팩토링 내성도 우수

기반 코드에 실수할 여지가 많지 않아 회귀를 나타내지 않을 것

항상 통과하거나 검증이 무의미하기 때문에 어떤 것도 테스트한다고 할 수 없다

=== 극단3: 깨지기 쉬운 테스트 (brittle test)

리팩토링을 견디지 못하고, 기능 고장 여부와 상관없이 빨간색으로 바뀜

테스트가 SUT 의 내부 구현 사항에 결합되는 예

(최근에 있는 상태를 가진 타 의존성이 이런 문제..)

=== 이상적인 테스트를 찾아서: 결론

세 가지 특성 모두 완벽하게 만족하는 이상적인 테스트는 불가능

어떤 특성도 0이 되지 않는 식으로 절충, 전략적으로 희생 +
실제로는 리팩토링 내성은 포기할 수 없다 - 최대한 많이 갖는 것을 목표로

회귀 방지와 빠른 피드백 사이의 선택으로 절충

테스트 스위트를 탄탄하게 만드려면 테스트의 불안정성 (false positive) 을 제거하는 것이 최우선 과제다

== 대중적인 테스트 자동화 개념 살펴보기

=== 테스트 피라미드 분해

테스트 피라미드: 테스트 스위트에서 테스트 유형 간의 일정한 비율

단위 테스트 -> 통합 테스트 -> 엔드 투 엔드 테스트 (갈 수록 적어짐, 덜 보편적) (p140)

피라미드 상단은 회귀 방지, 하단은 실행 속도를 강조

엔드 투 엔드 테스트는 가장 중요한 기능에 적용할 때와, 단위/통합 테스트와 동일한 수준으로 보호할 때만 적용 +
(빠른 피드백에 대한 점수가 낮고 외부 의존성으로 인한 유지 보수성 결여)

==== 예외

모든 애플리케이션이 기본적인 CRUD 작업이라면, 단위 테스트 = 통합 테스트 수가 없고 엔드 투 엔드 테스트는 없는 직사각형처럼 보일 것

알고리즘이나 비즈니스 복잡도가 없는 환경에서는 통합 테스트가 더 많아질 수 있다 (다른 하위 시스템과 통합돼 잘 작동하는지 확인이 중요)

프로젝트 외부 의존성 하나만 연결하는 API 는 엔드 투 엔드 테스트를 더 많이 두는 것이 적합한 옵션 - 사용자 인터페이스가 없으므로

=== 블랙박스 테스트와 화이트박스 테스트 간의 선택

* black-box testing: 내부 구조를 몰라도 검사할 수 있는 테스트 방법
** 어떻게가 아니라 무엇을 해야하는지 중심으로
* white-box testing: 내부 작업을 검증
** 테스트가 요구 사항이나 명세가 아닌 소스 코드에서 파생
** 장점: 소스 코드를 분석하면 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다
** 단점: 특정 구현과 결합되어 깨지기 쉽고 false positive 많이 내고 리팩토링 내성이 부족
** 비즈니스 담당자에게 의미가 있는 동작으로 유추할 수 없음

white-box 보다는 black-box 를 기본으로 선택 (리팩토링 내성은 포기할 수 없다)

테스트를 작성할 때는 black-box 가 바람직하지만, 테스트를 분석할 때는 white-box 방법을 사용할 수 있다 +
코드 커버리지 도구로 어떤 코드를 실행하지 않았는지 확인 = white-box + black-box 조합