= 5. mock 과 테스트 취약성

mock 으로 인해 취약한 테스트 (= 내성이 부족한 테스트를 초래) 를 살펴볼 예정 +
하지만 mock 을 적용할 수 있는 경우 & 바람직한 경우도 있다

* 런던파: immutable 의존성을 제외한 모든 의존성에 test double
* 고전파: 테스트 간 공유하는 의존성에 대해서만 test double

mock 과 테스트 취약성은 깊고 불가피한 관련이 있다 +
+ 리팩토링 내성 저하 없이 mock 을 사용하는 방법을 살펴볼 예정

== mock, stub 구분

=== test double 유형

test double: *모든 유형의 비운영용 가짜 의존성* 을 설명하는 포괄적인 용어, 테스트를 편리하게 하는 용도 +
(영화의 stunt double 에서 유래)

SUT 로 실제 의존성 대신 전달되므로 설정이나 유지보수가 어려울 수 있다

두 가지로 나눌 수 있다

==== mock (mock, spy)

* 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움
* SUT 가 상태를 변경하기 위한 의존성 호출
* ex) SMTP 서버로 이메일 발송

mock: mock 프레임워크의 도움을 받아 생성 +
spy: 수동으로 작성 (handwritten mock)

==== stub (stub, dummy, fake)

* 내부로 들어오는 상호 작용을 모방하는 데 도움
* SUT 가 입력 데이터를 얻기 위한 의존성 호출
* ex) DB 에서 데이터 검색 (부작용을 일으키지 않음)

dummy: 단순하고 하드코딩된 값 +
stub: 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성 +
fake: stub 과 비슷하나 아직 존재하지 않는 의존성을 대체하고자 구현

mock 은 SUT 와 관련 의존성 간의 상호 작용을 모방하고 검사 +
stub 은 모방만 한다

=== mock (도구) vs mock (test double)

mocking library 의 클래스도 mock 으로 참고할 수 있다 = *실제 mock 을 만드는 데 도움이 되지만 그 자체로는 mock 이 아니다*

mocking library 로 만들어진 인스턴스는 test double 로써의 mock 이다

(p151 5.2) Mock 클래스를 사용하지만 인스턴스는 mock 이 아니라 stub 이다 (DB)

=== stub 으로 상호 작용을 검증하지 말라

*stub 과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 안티 패턴이다*

false positive 를 피하고 리팩토링 내성을 향상시키려면 - 구현 세부 사항이 아니라 최종 결과를 검증하기

예제 5.3 은 깨지기 쉬운 테스트에 해당한다 - overspecification +
구현 세부 사항을 검증하고 있음 (stub 으로 지정한 값을 검증하고, 횟수까지 검증)

=== mock, stub 함께 쓰기

(p154 5.3) 준비된 응답을 반환하고, SUT 에서 수행한 메소드 호출을 검증

test double 은 mock & stub 이지만 mock 이라고 부른다 +
-> mock 이라는 사실이 stub 이라는 사실보다 더 중요하다

(junit 에서는 RemoveInventory 에 대한 동작을 지정하지 않았으므로 그 전에 오류가 발견될 것 같긴 하다)

=== mock, stub 은 command, query 에 어떻게 관련돼 있는가?

CQS (Command Query Separation) 원칙과 관련이 있다 +
-> 모든 메소드는 명령 or 조회여야 하며, 혼용해서는 안된다

* command: 부작용 (상태 변경) 을 일으키고 어떤 값도 반환하지 않는 (void) 메소드
* query: 부작용이 없고 값을 반환

원칙대로 명확하게 분리하면 코드를 읽기 쉽다 +
구현 세부 사항에 대해 시그니처만 봐도 메소드가 무엇을 하는지 알 수 있다

command - mock, query - stub

불가피한 경우도 있다 (stack.pop()) +
(CrudRepository 의 save 는 어떤거로 봐야할지?)

== 식별할 수 있는 동작과 구현 세부 사항

취약성을 일으키는 원인

false positive, 리팩토링 내성에 실패하는 주요 이유 - 구현 세부 사항과 결합돼 있어서 +
테스트는 '어떻게'가 아니라 '무엇'에 중점을 둬야 한다

구현 세부 사항은 무엇이고 동작과 어떻게 다른가?

=== 식별할 수 있는 동작은 공개 API 와 다르다

제품 코드는 'Public API or Private API', '식별할 수 있는 동작 or 구현 세부 사항' 의 2차원으로 분류할 수 있다

==== 식별할 수 있는 동작 vs 구현 세부 사항

식별할 수 있는 동작이려면 +
클라이언트가 목표를 달성하는 데 도움이 되는 operation 이나 state 를 노출해야 한다 (하나만)

구현 세부 사항은 위 두 가지 중 아무것도 하지 않는다

식별할 수 있는 동작인지 여부는 클라이언트가 누구인지, 목표가 무엇인지에 달려 있다 +
코드가 목표 중 하나에라도 직접적인 관계가 있어야 한다

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/05fig04_alt.jpg[]

시스템의 Public API 는 식별할 수 있는 동작과 일치해야 하고, 구현 세부 사항은 클라이언트의 눈에 보이지 않아야 한다 (5.4)

(그러면 '식별할 수 있는 동작은 공개 API 와 다르다' 는 말은 무엇인지?)

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/05fig05_alt.jpg[]
하지만 종종 구현 세부 사항을 노출한다 (5.5)

=== 구현 세부 사항 유출: operation

==== 기존

. NormalizeName
** operation 이지만 클라이언트의 목표에 직결되지 않는다
. set name

==== 변경

. set name
** 이 시점에 실제 property 로 저장 시 NormalizeName 수행

식별할 수 있는 동작만 공개, 구현 세부 사항은 비공개

(근데 예제 5.6 에서는 여전히 public 으로 메소드가 열려 있긴 하다. p160에서 메소드를 숨긴다고 했는데)

==== 유용한 규칙

단일한 목표를 달성하는데 호출해야 하는 operation 의 수가 1보다 크면 구현 세부 사항을 유출할 가능성이 있다

=== 잘 설계된 API 와 캡슐화

켑슐화: (항상 참이어야 하는) 불변성 위반이라는 모순을 방지하는 조치

불변성 위반 -> 구현 세부 사항을 노출 -> 불변성 위반 (?, p162) +
이전 예시에서 기존 코드는 불변성을 우회해서 정규화하지 않고 새로운 이름을 할당할 수 있었다

코드베이스 유지 보수에서는 캡슐화가 중요하다 - 복잡도 때문 +
캡슐화를 올바르게 유지해 코드베이스에서 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것

구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 코드 캡슐화를 달성하기 위한 수단

=== 구현 세부 사항 유츌: state

SubRenderers 가 공개 +
-> 식별할 수 있는 동작인가? = X +
-> 구현 세부 사항 노출이다

TIP: API 를 잘 설계하면 단위 테스트도 자동으로 좋아진다

operation, state 를 최소한으로 노출해야 한다 +
= 클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개, 다른 것들은 Private 으로 숨겨야

==== 정리

식별할 수 있는 동작은 공개여야 좋고 +
구현 세부 사항은 비공개여야 좋다