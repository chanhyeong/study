= 6. 단위 테스트 스타일

== 단위 테스트의 세 가지 스타일

출력 (output) 기반, 상태 (state) 기반, 통신 (communication) 기반

하나의 테스트에서 복수개를 함께 사용할 수 있다

=== 출력 기반 스타일

SUT 에 입력을 넣고 생성되는 출력을 점검

함수형이라고도 함 - 부작용 없는 코드 선호를 강조하는 프로그래밍 방식

=== 상태 기반 스타일

작업이 완료된 후 시스템 상태를 확인 +
시스템: SUT, 협력자 중 하나 or DB, 파일 시스템 등의 프로세스 외부 의존성

=== 통신 기반 스타일

mock 을 사용해 SUT 와 협력자 간의 통신을 검증

.스타일과 테스트 분파
****
고전파 - 상태 기반 > 통신 기반 +
런던파 - 위와 반대

둘 다 출력 기반 테스트 사용
****

== 단위 테스트 스타일 비교

좋은 단위 테스트의 4대 요소로 서로 비교할 예정 +
(회귀 방지, 리팩토링 내성, 빠른 피드백, 유지 보수성)

=== 회귀 방지, 피드백 속도로 스타일 비교

==== 회귀 방지

* 테스트 중에 실행되는 코드의 양
* 코드 복잡도
* 도메인 유의성

특별히 관계는 없으나 +
통신 기반 스타일에는 작은 부분만 검증하고 나머지는 전부 mock 처리하는 피상적인 테스트가 될 수 있다

==== 피드백 속도

특별히 상관관계가 없다

=== 리팩토링 내성

리팩토링 내성 - 리팩토링 중에 발생하는 거짓 양성 수에 대한 척도 (구현 세부 사항에 결합)

* 출력 기반 테스트: 테스트가 테스트 대상 메소드에만 결합 - 우수
* 상태 기반 테스트: 테스트 대상 메소드 외에 클래스 상태와 함께 동작 - 결합도가 높아 구현 세부 사항에 테스트가 얽매일 가능성
* 통신 기반 테스트: test double 로 상호 작용을 확인하는 테스트 - 대부분 깨지기 쉽다

캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다 + (통신 기반 테스트에서도?)

=== 유지 보수성

단위 테스트의 유지비를 측정, 2가지 특성으로 정의 +
테스트를 이해 (크기), 실행 (외부 의존성 개수) 하기 얼마나 어려운가?

* 출력 기반 테스트: 가장 유지 보수하기 용이
** 짧고 간결, 상태 변경 없음 (프로세스 외부 의존성을 다루지 않음)
* 상태 기반 테스트: 출력 기반보단 쉽지 않다 - 더 많은 공간 차지
** 크기 문제 완화를 위한 선택지들
... 코드를 숨기는 헬퍼 메소드 - 여러 테스트에서 재사용할 때 명분이 있음
... 검증 대상 클래스의 동등 멤버 정의 (값 객체로 클래스 변환하기) - 검증문에서 fluent 한 라이브러리와 같이 사용
**** 클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적 - 그렇지 않으면 코드 오염으로 이어짐
* 통신 기반 테스트: 유지 보수성이 낮다
** test double 과 상호 작용 검증 설정 -> 공간을 많이 차지한다
** mock chain 형태일 때는 더 커지고 유지 보수가 어렵다

=== 스타일 비교: 결론

회귀 방지와 피드백 속도 지표에서는 점수가 같다

[cols="4,1,1,1"]
|===
| |출력 기반 |상태 기반 |통신 기반

|리팩토링 내성을 지키기 위해 필요한 노력 |낮음 |중간 |중간

|유지비 |낮음 |중간 |높음
|===

* 출력 기반: 구현 세부 사항과 거의 결합되지 않고, 외부 의존성이 없어 유지 보수가 쉽다
* 상태 기반: 구현 세부 사항에 결합할 가능서잉 높고, 크기가 커서 유지비가 많이 든다

출력 기반 스타일은 함수형으로 작성된 코드에만 적용할 수 있다

== 함수형 아키텍처 이해

=== 함수형 프로그래밍이란?

수학적 함수를 사용한 프로그래밍

.수학적 함수?
****
숨은 입출력이 없는 함수 +
모든 입출력은 메소드 이름, 인수, 반환 타입으로 구성된 메소드 시그니처에 명시해야 한다 +
호출 횟수에 상관 없이 주어진 입력에 대해 동일한 출력을 생성
****

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/06fig05_alt.jpg[]

테스트가 짧고 간결, 이해하고 유지 보수가 쉬움 -> 테스트하기 매우 쉽다

.숨은 입출력의 유형
****
* 부작용: 메소드 시그니처에 표시되지 않은 출력 - 상태 변경, 디스크 업데이트 등
* 예외: 메소드 시그니처에 설정된 계약을 우회하는 경로를 만듦. 메소드 시그니처가 전달하지 않는 출력 추가
* 내외부 상태에 대한 참조: 현재 시간, DB query 등 메소드 시그니처에 없는 실행 흐름에 대한 입력
****

=== 함수형 아키텍처란?

비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것이 목적 +
부작용을 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 부작용과 분리

NOTE: 함수형 아키텍처는 부작용을 다루는 코드를 최소화하면서, 순수 함수 (immutable) 방식의 코드 양을 극대화 - 객체 상태를 바꿀 수 없음

다음 두 가지 코드 유형을 구분하여 비즈니스 로직과 부작용을 분리할 수 있음

* 결정을 내리는 코드 (functional (immutable) core): 부작용이 필요 없어 수학적 함수를 사용해 작성 가능
* 결정에 따라 작용하는 코드 (mutable shell): 결정을 DB 변경과 같은 가시적인 부분으로 변환
** 가능한 아무 말도 하지 않아야 한다

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/06fig09.jpg[]

. mutable shell 이 모든 입력 수집
. function core 가 결정 생성
. shell 이 결정을 부작용으로 변환

목표: 출력 기반 테스트로 함수형 코어, 가변 셸을 통합 테스트에 맡기는 것

[quote]
객체지향 프로그래밍은 작동 부분을 *캡슐화해* 코드를 이해, 함수형 프로그래밍은 작동 부분을 *최소화해* 코드를 이해

=== 함수형 아키텍처와 육각형 아키텍처 비교

==== 비슷한 점

* 관심사 분리 (도메인 - 애플리케이션 서비스, 결정 - 실행)
* 의존성 간 단방향 흐름 (도메인 게층 내 클래스끼리 의존, 불번 코어는 가변 셸에 의존하지 않음)

==== 차이점

부작용에 대한 처리

* 함수형: 모든 부작용을 가변 셸이 처리 (이건 계층을 넘는거도 가능)
* 육각형: 도메인 계층에서 제한하면 도메인 계층으로 인한 부작용도 문제 없음 (계층을 넘어가면 안됨)

함수형은 육각형의 하위 집합이다

== 함수형 아키텍처와 출력 기반 테스트로의 전환

두 가지 리팩토링 단계

. 프로세스 외부 의존성 -> mock
. mock -> 함수형 아키텍처

=== 기존 코드

* 테스트 전에 파일을 올바른 위치에 배치
* 테스트가 끝나면 파일을 읽고 내용 확인 후 삭제

테스트 병렬 처리가 어렵다

[cols="1,1"]
|===
| |초기 버전

|회귀 방지 |좋음
|리팩토링 내성 |좋음
|빠른 피드백 |나쁨
|유지보수성 |나쁨
|===

파일 시스템에 직접 작동하는 테스트는 단위 테스트의 정의에 맞지 않는다 (빠르게 수행 X, 다른 테스트와 별도로 처리 X)

=== mock 사용으로 파일 시스템에서 분리

[cols="1,1,1"]
|===
| |초기 버전 |mock 사용

|회귀 방지 |좋음 |좋음
|리팩토링 내성 |좋음 |좋음
|빠른 피드백 |나쁨| 좋음
|유지보수성 |나쁨| 중간
|===

* 파일 시스템에 의존하지 않음 -> 빠른 속도, 유지비 절감
* 테스트에서 복잡한 설정을 포함 -> 이상적인 유지비는 아님 (개선 포인트)

=== 함수형 아키텍처로 리팩토링하기

부작용을 클래스 외부로 완전히 이동하기

파일 시스템 접근을 위한 Persister

image::https://drek4537l1klr.cloudfront.net/khorikov/Figures/06fig14.jpg[]

* 직접적인 디렉토리 경로 -> `FileContent[]` 를 입력으로
* 디렉토리 파일 변경 -> `FileUpdate` 명령을 반환

변경한 AuditManager 와 Persister 를 붙이려면 별도의 애플리케이션 서비스 클래스가 필요

(지금하는 프로젝트에서 spring context 를 안띄우고 바로 mock 으로 넣어버릴 수도 있겠다. 어차피 DB 접근이 인터페이스니까)

[cols="1,1,1,1"]
|===
| |초기 버전 |mock 사용 |출력 기반

|회귀 방지 |좋음 |좋음 |좋음
|리팩토링 내성 |좋음 |좋음 |좋음
|빠른 피드백 |나쁨| 좋음 |좋음
|유지보수성 |나쁨| 중간 |좋음
|===

== 함수형 아키텍처의 단점 이해하기

코드베이스가 커지고 성능 영향 -> 유지 보수성 이점 상쇄가 된다

=== 함수형 아키텍처 적용 가능성

의사 결정 절차의 중간 결과에 따라 추가 데이터를 질의할 수 있음

p220 추가 스펙에 대한 두 가지 해결책

* 애플리케이션 서비스 전면에서 디렉토리 내용 + 방문자 접근 레벨 수집할 수 있게 (?)
** 성능 저하
* AuditManager 에서 '접근 권한 체크 필요 여부' 와 같은 새로운 메소드 추가
** 분리가 완화됨 - DB 호출 결정이 애플리케이션으로 넘어간다 (이건 캡슐화 위반인가?)

도메인 모델을 DB 에 의존하는 것은 좋은 생각이 아니다

NOTE: 함수형 코어의 클래스는 협력자로 작동하지 않고 작업의 결과인 값으로 작동해야 한다.

=== 성능 단점

프로세스 외부 의존성을 더 많이 호출 -> 성능이 떨어짐 (read-decide-act 를 위해 디렉토리의 모든 파일을 읽음)

함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 간의 절충이다 +
성능 영향이 적다면 적용하여 유지 보수성을 높이고, 아니면 반대로 할 수도 있다

=== 코드베이스 크기 증가

함수형 코어와 가변 셸 사이를 명확하게 분리해야 한다 = 초기에 코딩이 더 필요하다

너무 단순하거나 비즈니스 상 중요하지 않은건 초기 투자 대비 성과를 내지 못함 -> 의미가 없다

함수형 방식에서 순수성에 많은 비용이 들면 순수성을 따르지 말 것 +
여기서의 목표는 가능한 많은 테스트를 출력 기반으로 전환하도록 하는 것, 전부가 아님

(이건 룰이 잘 정의해두고 계속 봐야할 것 같다. 어디는 출력 기반이고 어디는 상태 기반이면 헷갈릴 듯) +
(비슷하게 다른 책에서 AAA 가 불변의 규칙이 아니라던데 통일성 측면에서 동의하지 않음)