= 3. 단위 테스트 구조

== 단위 테스트를 구성하는 방법

=== AAA 패턴 사용

준비 (Arrange), 실행 (Act), 검증 (Assert) (3A 패턴)

모든 테스트가 +
-> 단순하고 균일한 구조를 갖는데 도움 (일관성) +
-> 쉽게 읽을 수 있고 이해할 수 있다 +
-> 유지 보수 비용이 줄어든다

* Arrange: SUT 와 해당 의존성을 원하는 상태로 설정
* Act: SUT 에서 메소드 호출, 준비된 의존성 전달 & 반환 값 캡처
* Assert: 결과 검증
** 반환 값 or SUT 와 협력자의 최종 상태 or SUT 가 협력자에 호출한 메소드 등

.Given-When-Then
****
차이는 없고, 프로그래머가 아닌 사람에게 더 읽기 쉬운 구조 +
비기술자들과 공유하는 테스트에 적합
****

* 자연스러움: Arrange 부터 -> 다른 두 개
* Assert 로 시작하는 것도 가능 -> TDD: 기능이 어떻게 동작할지 모르므로 기대하는 동작으로 윤곽을 잡음

=== 여러 개의 준비, 실행, 검증 구절 피하기

Assert 구절이 구분된 여러 개의 Act 구절: 여러 개의 동작 단위를 검증하는 테스트 +
-> 이거는 통합테스트다

일련의 Act, Assert 가 포함된 테스트가 있다면 리팩토링 (= 각 동작을 고유의 테스트로 도출)

통합 테스트에서 실행 속도를 높이는 방법? +
-> 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶음

=== 테스트 내 if 문 피하기

테스트는 분기가 없는 간단한 일련의 단계여야 한다

안티 패턴이다 +
-> 테스트가 한 번에 너무 많은 것을 검증한다는 표시: 나눠야 한다
-> 테스트를 읽고 이해하는 것을 어렵게 함

=== 각 구절은 얼마나 커야 하는가?

==== Arrange

일반적으로 Arrange 구절이 세 구절 중 가장 크다

Act + Assert 만큼 클 수 있음, 하지만 이보다 크면 private or factory 클래스로 도출하는 것이 좋음 (Object Mother, Test Data Builder 2가지 패턴)

==== Act

보통 한 줄 +
두 줄 이상인 경우 SUT 의 공개 API 에 문제가 있을 수 있다 +
(한 줄로 하는 지침은 utility 나 infra 코드는 덜 적용)

85p 예시: 단일 작업을 수행하는 데 2개의 메소드 호출이 필요하다 +
-> API 에 문제가 있으며, 클라이언트에게 메소드 호출을 더 가용해서는 안 된다 +
-> 두 가지 결과는 같이 만들어야 하고, 단일한 메소드가 있어야 한다

* invariant violation (불변 위반): 다음 동작을 하지 않을 때 모순이 생기는 경우
** 해결책: 코드 캡슐화를 항상 지켜야 한다
* encapsulation (캡슐화): 잠재적인 모순으로부터 코드를 보호하는 행위

(구절이 얼마나 커야하는지 얘기하다가 갑자기 다른 길로 간 것 같다)

=== Assert 구절에는 Assert 문이 얼마나 있어야 하는가

단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 모든 결과를 평가하는 것이 좋다

검증 구절이 너무 크다 = 추상화가 누락됐을 수 있다 +
ex) 모든 속성을 검증하는 대신 적절한 equality member 를 정의하는 것이 좋다 +
(assertj using recursive comparison 이 있긴 함)

=== 종료 단계는 어떤가

(다른 책에서는 After 라고 하긴 함)

테스트에 의해 작성된 파일을 지우거나, DB 연결 종료 등

일반적으로 별도의 메소드로 호출되므로 모든 테스트에서 재사용

대부분 단위 테스트는 종료 구절이 필요 없다 +
-> 프로세스 외부에 종속적이지 않으므로 처리해야 할 부작용을 남기지 않는다 +
-> 종료는 통합 테스트의 영역 (이래서 SpringBootTest 를 통합 테스트라고 하는건가)

=== 테스트 대상 시스템 구별하기

SUT: 호출하고자 하는 동작에 대한 진입점 제공

동작은 여러 클래스에 걸쳐 클 수도 있고, 작을 수도 있다 +
진입점은 오직 하나만 존재할 수 있다

SUT 를 의존성과 구분하는 것이 좋다 - *테스트 내 SUT 이름을 sut 로 하라*

=== Arrange, Act, Assert 주석 제거하기

주석을 달기 or 빈 줄로 분리하기

AAA 패턴을 따르고 각 단게에 빈 줄을 추가하지 않아도 되는 테스트 -> 주석 제거

== xUnit 테스트 프레임워크 살펴보기

(다 .NET 인데 xUnit, NUnit 의 차이는 뭐지? https://kayuse88.github.io/dotnet-testframework/)

(xUnit 부터 시작해서 JUnit 으로 간줄 알았더니 그게 아닌가?)

xUnit 에서는 (TestFixture, setUp, TearDown 같은게) convention 과 내장 언어 구조에 의존

* `[Fact]` (Test 가 아닌 Fact 라고 표현)
** 각 테스트는 이야기가 있어야 한다는 것을 강조
** 문제 영역에 대한 개별적이고 atomic 한 사실이나 시나리오. 통과한다? -> 실제 사실이다
** 실패하면 이야기가 유효하지 않아 다시 작성 or 시스템 자체를 수정
** 이러한 사고방식을 갖는게 좋다 (기능을 무조건 나열하면 안된다)

== 테스트 간 테스트 픽스처 재사용

Arrange 에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법

.Test Fixture
****

. 테스트 실행 대상 객체, SUT 로 전달되는 argument (이 정의를 사용)
** 테스트 실행 전에 알려진 고정 상태로 유지 = 동일한 결과를 생성
. NUnit 테스트에서 유래 - 테스트가 포함된 클래스를 표시하는 특성

****

안좋은 예시: 테스트 contructor (setup 단계) 에서 fixture 를 초기화하는 것

* 테스트 간 결합도가 높아진다
* 테스트 가독성이 떨어진다

=== 테스트 간 높은 결합도는 안티 패턴이다

테스트 준비 로직을 수정하면 클래스의 모든 테스트에 영향 +
테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다

테스트 클래스에 공유 상태를 두지 말아야 한다

(전에 코멘트 받은거로는 JUnit 에서는 매 테스트 메소드마다 테스트 인스턴스를 새로 생성한다고 들음)

=== 테스트 가독성을 떨어뜨리는 생성자 사용

*테스트 메소드를 이해햐려면 클래스의 다른 부분도 봐야 한다*

=== 더 나은 테스트 픽스처 재사용법

private factory method 를 두기

테스트 코드를 짧게 하면서, 진행 상황에 대한 전체 맥락을 유지할 수 있다

거의 대부분의 테스트에 사용되는 경우 생성자에 픽스처를 인스턴스화할 수도 있음 +
DB 예시 - 96p

== 단위 테스트 명명법

표현력있는, 올바른 이름 붙이기 - 테스트가 검증하는 내용과 기본 시스템의 동작을 이해하는데 도움

.안좋은 예시
----
[테스트 대상 메소드]_[시나리오]_[예상 결과]
----

* 테스트 대상 메소드: 테스트 중인 메소드 이름
* 시나리오: 메소드를 테스트하는 조건
* 예상 결과: 현재 시나리오에서 테스트 대상 메소드에 기대하는 것
* 동작 대신 구현 세부 사항에 집중하게 하기 때문에 도움이 되지 않는다

(이렇게들 많이 쓰지만, 다른 회사 혹은 해외에서 만약에 이렇게 안쓴다면 이 책에서 나온 내용이라고 볼 수 있을 듯) +
(JUnit5 와서는 DisplayName 이 있어서 상관 없긴 한듯)

수수계기 같은 이름은 모두가 이해하는 데 부담이 된다 -> 유지비가 천천히 늘어난다

=== 단위 테스트 명명 지침

* 엄격한 명명 정책을 따르지 않는다. 복잡한 동작에 대한 설명을 욱여넣을 수 없다. 표현의 자유를 허용하자.
* 비개발자들에게 시나리오를 설명하는 것처럼 짓자
* 단어를 underscore 로 구분. 가독성 향상

테스트 클래스 이름 지정시 `[클래스명]Tests` 를 사용하지만, 테스트가 해당 클래스만 검증하는 것으로 제한하는건 아니다 +
단위 테스트에서 단위는 동작의 단위이며, 클래스 단위가 아니다 +
[클래스] 는 동작 단위로 검증할 수 있는 진입점 or API

.테스트명 내 테스트 대상 메소드 (MUT)
****
테스트 이름에 SUT 의 메소드 이름을 포함하지 말 것.

코드를 테스트 X -> 애플리케이션 동작을 테스트 O: 메소드명이 중요하지 않다

원래 쓰던대로라면, 메소드명 변경? -> 테스트 대상 메소드 이름도 변경해야 한다 +
결합도가 높아지고, 테스트 스위트 유지 보수성에 부정적
****

_should be_ 는 안티 패턴 -> _is_ 로 변경

== 매개변수화된 테스트 리팩토링하기

동작이 복잡하면 테스트 수가 증가할 수 있으며 관리하기 어려워질 수 있다 +
-> parameterized test 제공

NOTE: 103p 에서 `[Fact]` 대신 `[Theory]` 특성 이용. xUnit

parameterize 하면 코드 양을 줄일 수 있지만 테스트가 나타내는 사실을 파악하기가 어렵다 +
+ 매개변수가 많을 수록 더 어렵다

절충안: 긍정 케이스는 unique 하게, 부정 케이스만 모아서

매개변수만으로 판단이 가능하면 하나로 두고 그렇지 않으면 긍정을 도출

동작이 너무 복잡하면 parameterized 는 사용하지 말기 +
각각 고유의 테스트 메소드로 나타내기

=== parameterized test 를 위한 데이터 생성

C# 기반이라 패스

== 검증문 라이브러리를 사용한 테스트 가독성 향상

이야기 형태 (주어, 행동, 목적어) 로 정보를 흡수

java 에서는 assertj 로 대응할 수 있을 듯