= 11. 단위 테스트 안티 패턴

적절한 것처럼 보이지만 큰 문제로 이어지는 반복적인 문제에 대한 일반적인 해결책

시간 다루는 방법, private method, 코드 오염, 구체 클래스 mock, ...

== 비공개 메소드 단위 테스트

=== 테스트 취약성

5장의 *식별할 수 있는 동작만 테스트* 하는 것을 위반 +
구현 세부 사항과 결합 -> 리팩토링 내성이 떨어진다

직접 테스트 X, 포괄적인 식별할 수 있는 동작으로서 간접적으로 O

=== 불필요한 커버리지

비공개 메소드가 너무 복잡해서 커버리지를 얻을 수 없는 경우

이미 합리적인 커버리지가 있다고 가정하면, 두 가지 문제일 수 있음

* 죽은 코드: 삭제 필요
* 추상화 누락: 너무 복잡하면 별도의 클래스로 도출해야 한다는 신호

=== 테스트가 타당한 경우

p375 Inquiry 의 예시 +
private constructor 에 있는 로직 테스트

테스트하기 위해 private -> public 으로 변환 +
(생성자를 공개한다고 해서 테스트가 쉽게 깨지지는 않는다)

아니면 공개하지 않고 reflection 을 이용하여 테스트할 수 있다

== 비공개 상태 노출

비공개 상태를 업데이트하는 공개 메소드의 수행 결과 검증 (예제 11.4 Promote) +
내부 비공개 필드를 공개하는건 안티 패턴

제품 코드가 상태를 신경쓰지 않으면 필드를 공개할 수 있다 (상태 사용 중 아닌가?) +
제품 코드가 상태를 사용하기 시작하면 SUT 의 식별할 수 있는 동작이 되기 때문에 테스트에서 결합할 수 있음

NOTE: 테스트 유의성을 위해 공개 API 노출 영역을 넓히는 것은 좋지 않다

== 테스트로 유출된 도메인 지식

복잡한 알고리즘을 다루는 테스트에서 보통 일어나는 안티패턴 +
(로직을 제품-테스트 간 복붙한 수준인 경우)

테스트 작성 시 특정 구현을 암시하지 말기 - 복제 대신 하드 코딩 (알고리즘이 복잡한 경우에만)

== 코드 오염

테스트에서만 필요한 제품 코드를 추가하는 것

테스트 코드와 제품 코드가 혼재되어 유지비 증가

== 구체 클래스를 mock 으로 처리하기

p385 예제 11.13 처럼 mock 으로 기존 클래스를 그대로 사용하고, 특정 메소드만 재정의 -> 안티 패턴

NOTE: 일부 기능을 지키려고 구체 클래스를 mock 처리 = 단일 책임 원칙을 위반하는 결과

mock 으로 처리하는 대신 해당 구현을 인터페이스로 분리

== 시간 처리하기

안정화하는 3가지 방법

=== ambient context

내장 코드 대신 별도 클래스 정의 -> 안티 패턴

=== 명시적 의존성

* 시간을 서비스로 주입
** 서비스로 시간으로 주입한 다음, 나머지 연산에서 값으로 전달 (예제 11.17)
* 시간을 일반 값으로 주입
** 제품 코드에서 작업하는게 더 쉽고, 테스트에서 stub 처리도 더 쉬움

