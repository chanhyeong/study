= 13. 까다로운 테스트

설계 다시하기 + stub, mock 을 사용하여 의존성 끊기로 thread, persistence 테스트

== 멀티스레드 코드 테스트

동시성 처리 테스트는 통합 테스트로 분류하는 것이 나으나 +
애플리케이션 고유 로직 중 일부는 동시적으로 실행될 수 있음을 고려하여 통합적으로 검증

thread 를 사용하는 코드는 느린 경향 +
동시성엔 문제가 없다는걸 보장 & 실행  시간의 범위를 확장

=== 단순하고 똑똑하게 유지

* *thread 통제와 애플리케이션 코드 사이의 중첩을 최소화*
** thread 없이 단위 테스트 할 수 있도록 설계 변경
* *다른 사람의 작업을 믿기*
** JAVA 5 에서 훌륭한 동시성 제공, BlockingQueue 클래스 사용

이제 thread 와 애플리케이션 로직을 구별하면서 코드 재설계하는 예시

테스트 메소드를 하나씩 분리 -> executor 도 메소드로 받아서 테스트 코드 레벨에서 `isTerminated()` 호출

== 데이터베이스 테스트

=== 데이터 문제

persistence 모든 상호 작용을 시스템의 한 곳으로 고립시킬 수 있다면 통합 테스트의 대상은 소규모로 줄어들 것

(H2 를 쓰면 인메모리와 프로덕션 RDBMS 의 미묘한 차이로 인한 문제가 될수도 있다)

머신 DB -> 매 테스트는 자기가 쓸 데이터를 추가하거나 그것으로 작업 -> 테스트 간 의존성 문제를 최소화 +
공유 DB -> 트랜잭션을 지원한다면 테스트마다 트랜잭션 초기화, 끝나면 롤백

TIP: 통합 테스트는 설계 및 유지보수가 어려우니 단위 테스트에서 최대한 검증하여 통합 테스트의 개수와 복잡도를 최소화해라

=== 클린 룸 DB 테스트

매 테스트 메소드 전후에 DB 를 비움

=== controller 를 mock 처리

mock 으로 처리한 것인 무엇이고, 쿼리에 어떻게 반응하고 어떤 부작용을 발생시키는지 충분히 알고 있어야 한다

mockito 는 테스트에서 mock 의 활용을 단순하고 선언적으로 유지하게 한다 +
테스트를 읽고 빠르게 의도를 파악할 수 있다