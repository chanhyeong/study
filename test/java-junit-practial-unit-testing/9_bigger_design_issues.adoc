= 9. 더 큰 설계 문제

== Profile 클래스와 SRP

책 예시인 Profile 클래스의 문제점

객체 지향 설계의 단일 책임 원칙 (SRP) 위반 - 클래스를 변경할 때는 단 한 가지 이유만 있어야 함

단일 책임을 강조하면 변경으로 인한 리스크가 줄어듦 +
더 작고 집중화된 클래스 - 재활용이라는 가치 제공 가능

.SOLID 클래스 설계 원칙
****

* 단일 책임 (SRP): 상위 설명
* 개방 폐쇄 (OCP): 클래스는 확장에 열려 있고 변경에는 닫혀 있어야 함
** 기존 클래스의 변경을 최소화 해야 함
* 리스코프 치환 (LSP): 하위 타입은 반드시 상위 타입을 대체할 수 있어야 함
* 인터페이스 분리 (ISP): 클라이언트는 필요하지 않는 메소드에 의존하면 안 됨
* 의존성 역전 원칙 (DIP): 고수준 모듈은 저수준 모듈을 의존해서는 안됨, 둘 다 상외 클래스에 의존해야 함

****

(책에서 갑자기 https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99[나무위키를..])

== 새로운 클래스 추출

책임 2개를 분리하여 각 클래스로 할당

분리하지 않고 유지한다면, 클래스가 커지고 복잡해지며 재사용을 최소화하고 각 클래스의 동작을 이해하기 어렵고, 수정할 때마다 관련 없는 항목이 깨지기 쉬움

== Command-Query Seperation

side effect 를 발생시키는 메소드는 분리

== 단위 테스트 유지 보수 비용

리팩토링은 코드 동작을 변경하지 않고 코드 구현을 바꾸는 활동이지만 +
현실에서는 클래스 동작을 변경하고 있다

변경으로 인해 실패하는 테스트의 정도를 부정적인 설계 지표로 인식하는 것도 생각해보자 +
많이 깨질 수록 많은 설계 문제

=== 자신을 보호하는 방법

단위 테스트를 설정하는 데 코드가 많이 필요하면 시스템 설계에 문제가 있는 것이다

설계를 개선하여 단위 테스트를 쉽게 만들어라

(p196 에서 Before 를 잘 쓰는데, 단위 테스트 책에서는 저런게 코드 흐름을 이해하는데 좋지 않다고 말함)

== 다른 설계에 관한 생각들

생성자에서 실제적인 작업을 피하기

기능의 산재 (shotgun surgery): 클래스의 구현 상태가 흩어져 있을 때의 코드 스멜

