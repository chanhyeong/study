= 4. 테스트 조직

== AAA 로 테스트 일관성 유지

* Arrange: 실행 전 시스템이 적절한 상태인지 확인. 객체 생성 or API 호출
* Act: 테스트 코드 실행. 단일 메소드 호출
* Assert: 코드가 기대한 대로 동작하는지 확인
* (After): 실행 시 할당했다면, 잘 정리되었는지 확인
** 때에 따라 추가 단계

== 동작 vs 메소드 테스트

클래스의 동작에 집중해야 하며, 개별 메소드를 테스트한다고 생각하면 안 됨

예시

* 기존: 잔고만 검증하는 메소드 (단일 계좌 생성, 다수 계좌 생성)
* 추가: 출금의 다양한 예시 (단일 출금 건, 다수 출금 건, 초과 출금 시도)

단위 테스트를 작성할 때는 전체적인 시각에서 시작해야 한다 +
개별 메소드를 테스트하는 것이 아니라 클래스의 종합적인 동작을 테스트해야 한다

(앞에서는 코드 실행 시 단일 메소드 호출이라고 했는데, 이렇게 되면 여러개가 호출되지 않나?) +
(이거는 통합테스트가 아닌가?)

== 테스트와 프로덕션 코드의 관계

테스트는 프로덕션 코드와 분리해야 한다 +
테스트는 프로그래머만 하는 활동, 다른 역할군은 결과를 보거나 실행만

테스트 코드는 프로덕션 코드에 의존, 그 반대는 해당하지 않음

=== 테스트와 프로덕션 코드 분리

테스트를 프로덕션 소스와 같은 프로젝트에 넣을지 결정하는 세 가지 선택지

. 테스트를 프로덕션 코드와 같은 디렉토리 및 패키지에 넣기 - 아무도 이렇게 안함
. 테스트를 별도 디렉토리로 분리하지만 프로덕션 코드와 같은 패키지에 넣기 - 대부분 이렇게
** `src/` , `test/`
. 테스트를 별도의 디렉토리와 유사한 패키지에 유지하기
** public interface 만 활용하여 테스트 코드 작성

=== 내부 데이터 노출 vs 내부 동작 노출

내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는 것

보이지 않는 수맣은 흥미로운 행동은 단일 책임 원칙 (SRP, Single Responsibility Principle) 을 어기게 된다 +
= 클래스는 작고 단일 목적을 가져야 함 +
private 메소드를 추출하여 다른 클래스로 이동 +
(powermock 은 잘못된 패턴인건가?)

== 집중적인 단일 목적 테스트의 가치

TIP: 다수의 케이스를 별도의 JUnit 테스트로 분리. 각각 검증하는 동작을 표현하는 이름을 붙이기

테스트를 분리하면

* assertion 이 실패했을 때 실패한 테스트 이름 표시 -> 어느 동작에서 문제가 있는지 빠르게 파악
* 실패한 테스트 해독 시간 감소, 다른 테스트의 영향 제거. JUnit 은 각 테스트를 별도의 인스턴스로 실행하기 때문
* 모든 케이서그 실행되었음을 보장. assertion 이 실패하면 현재 메소드 중단

== 문서로서의 테스트

단위 테스트는 만드는 클래스에 대한 지속적이고 믿을 수 있는 문서 역할 +
테스트는 자체로 쉽게 설명할 수 없는 가능성을 알려줌 +
주석으로 적을 내용을 보충

=== 일관성 있는 이름으로 테스트 문서화

행동을 호출했을 때 어떤 결과가 나오는지 명시

`doingSomeOperationGeneratesSomeResult` +
`someResultOccursUnderSomeCondition`

BDD 에서 말하는 given-when-then 을 사용할 수도 있음 +
given 을 제거하기도 함

`givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs`

일관성을 유지하는 것이 중요

(보통은 대상 메소드명_ 로 많이 했던듯) +

=== 테스트를 의미 있게 만들기

테스트 이름 개선, 로컬 변수 명 개선, 의미 있는 상수 도입, hamcrest assertion tkdyd, 테스트 나누기, `@Before` 로 이동

=== `@Before`, `@After` (공통 초기화와 정리)

==== `@Before`

* setup 메소드
* 여러 개로 분할할 수 있음 - 순서 보장은 안됨

==== `@After`

* 테스트 후 실행, 실패하더라도 실행
* 발생하는 부산물을 정리하는 역할

==== `@BeforeClass`, `@AfterClass`

테스트 클래스 리벨의 초기화, 정리

== 녹색이 좋다: 테스트를 의미있게 유지

실패하는 테스트가 있다면 더 늘리지 말고 바로 고쳐라

=== 테스트를 더 빠르게

단위 테스트는 매우 빨라야 한다 +
빠른 피드백을 얻을 수 있는 단위 테스트

TIP: 견딜 수 있는 만큼 많은 테스트 실행

=== 테스트 제외

`@Ignored`