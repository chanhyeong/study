= 6. Right-BICEP: 무엇을 테스트할 것인가?

어떤 종류의 JUnit 테스트를 작성해야 하는가?

무엇을 테스트해야 하는가?

== [Right]-BICEP: 결과가 올바른가?

happy path test 가 답변하는 질문

[quote]
코드가 정상적으로 동작한다면, 그것을 알 수 있을까?

happy path test 를 할 수 없다면 내용을 완전히 이해하지 못한 것 -> 질문에 대답할 수 있을 때까지 추가 개발 보류

최선의 판단을 하고 나중에 답변이 명확해졌을 때 개선해라

단위 테스트는 선택을 문서화 한다: 변경이 발생하면 적어도 현재까지 코드가 어떻게 동작했는지는 알게 된다

== Right-[B]ICEP: 경계 조건 (Boundary condition) 은 맞는가?

수많은 결함은 corner case 에서 발생하므로 이것들을 처리

클라이언트를 믿을 수 없다면 나쁜 데이터에 대한 보호 필요 +
보호절을 제거한다면 코드 주석으로 경고할 수도 있음 +
더 좋은 건 코드 제한 사항을 문서화하는 테스트 추가

== 경계 조건에서는 CORRECT

잠재적인 경계 조건을 기억하는 데 도움을 주는 항목들

* Conformance: 값이 기대한 양식을 *준수* 하는지?
* Ordering: 값의 집합이 적절하게 *정렬* ? or not
* Range: 이성적인 값의 *범위* 에 있는지?
* Reference: 통제할 수 없는 외부 *참조* 를 포함하는지?
* Existence: 값이 *존재* (non-null, nonzero, include) ?
* Cardinality: 정확히 충분한 값들이 있는가?
* Time: 모든 것이 순서대로 일어나는가?

== Right-B[I]CEP: 역 (inverse) 관계를 검사할 수 있는가?

논리적인 역 관계를 적용하여 행동 검사

곱셈 나눗셈, 뺄셈 덧셈 등

== Right-BI[C]EP: 다른 수단을 활용하여 교차 검사 (Cross-check) 할 수 있는가?

문제 해결 시 선택한 1등 해법 외에 다른 '패배자' 해법으로 1등 해법을 교차 검사

== Right-BIC[E]P: 오류 조건 (Error Condition) 을 강제로 일어나게 할 수 있는가?

unhappy path 에 대한 오류들을 강제로 발생 +
204 페이지에서 다룰 예정

----
memory/disk full, 시간 문제, 네트워크 가용성과 오류, 시스템 로드, ...
----

(예상하지 못한 곳에서 나오는 끔직한 결함)

== Right-BICE[P]: 성능 조건 (Performance characteristics) 은 기준에 부합하는가?

추측으로 성능 문제에 바로 대응하기 보다는, 단위 테스트를 설계하여 문제를 발견하고 변경 사항으로 어떤 차이가 생겼는지 파악

주의 사항

* 코드 덩어리를 충분한 횟수만큼 실행 - 타이밍, CPU clock cycle 이슈 제거
* 반복 코드를 JVM 이 최적화하지 못하는지 확인해야 함 (어떻게?)
* 최적화되지 않은 테스트는 매우 느림 - 느린 테스트들은 빠른 것과 분리
* 동일한 머신이라도 시스템 로드처럼 잡다한 요소에 따라 달라질 수 있음

단위 성능 측정을 잘 사용하는 방법은 변경 사항을 만들 때 기준점 (baseline) 으로 활용하는 것 +
(lambda 가 최적화되지 않는다? -> 성능 향상을 위해 전통적인 방법으로 교체할 때)

* 최적화 하기 전에 기준점으로 현재 경과 시간 (elapsed time) 을 측정하는 성능 테스트를 작성
* 몇 번 실행해보고 평균 계산
* 성능이 핵심이면 JMeter 같은 도구를 사용할 수도
* 단위 수준 성능 측정에 관심이 많다면 JUnitPerf 와 같은 서드파티