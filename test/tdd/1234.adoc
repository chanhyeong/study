== 1. 다중 통화를 지원하는 Money 객체

(multi currency money)

(새로운 보고서 생성 예시)

어떤 테스트들이 있어야 (테스트들이 모두 통과했을 때) 제대로 된 기능을 하는 코드가 완성됐다는 걸 확신할 수 있나?

테스트를 작성할 때는 오퍼레이션의 완한 인터페이스에 대해 상상해보는 것이 좋다 (외부에서 어떻게 보일지)

작은 단계부터 시작 (문제가 많더라도)

[source,java]
----
public void multiplication() {
    Dollar five = new Dollar(5); // numeric
    five.times(2); // unexpected side effect
    assertEquals(10, five.amount); // public field
}
----

Red 단계 - 실패에 대한 구체적인 척도를 갖게 된다, 완벽한 해법이 아닌 테스트를 통과시키게 한다

주기를 만들어야 한다

. 적은 테스트 추가
. 테스트 실행 후 테스트 실패 확인
. 코드를 조금 수정
. 테스트 실행하여 전부 성공하는지 확인
. 리팩토링으로 중복 제거

.의존성과 중복
****
테스트와 코드 사이에 존재하는 의존성 - 코드나 테스트 중 한 쪽을 수정하면 다른 쪽도 수정해야 한다

의존성은 핵심적인 문제이다 +
의존성은 문제 그 자체 - 중복은 문제의 징후

프로그램에서는 중복만 제거해 주면 의존성도 제거된다 (?)

다음 테스트로 진행하기 전 중복 제거 - 오직 한 가지의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성 최대화
****

=== 여기까지 한 것

* 알고 있어야 할 테스트 목록 생성
* 오퍼레이션을 코드로 표현
* JUnit 상세 무시, stub 구현으로 테스트 컴파일, 끔찍한 방향으로 테스트 통과
* 코드에서 상수 -> 변수로 변경하여 점진적 일반화
* 새로운 할일을 한 번에 처리하지 않고 todo list 에 추가하고 넘어감 (p51 박스)

== 2. 타락한 객체

(degenerate objects)

일반적인 TDD 주기

. 테스트 작성
** 원하는 인터페이스 만들기. 필요한 이야기의 모든 요소 포함
. 실행 가능하게 만듦
** 깔끔하고 단순하게 하는 방법이 바로 보이면 적용
** 그게 아니면 일단 적어 놓고 green 으로 만들자
. 올바르게 만듦
** 이전에 했던 죄악을 수습, 중복을 제거하고 green 으로 만들기

*목적: 작동하는 깔끔한 코드를 얻는 것* +
작동 -> 깔끔으로 나누어서 해결해보자

.부작용을 제거하기 위한 인터페이스 수정
[source,java]
----
public void multiplication() {
    Dollar five = new Dollar(5);
    Dollar product = five.times(2);
    assertEquals(10, five.amount);
    product = five.times(3);
    assertEquals(15, five.amount);
}
----

최대한 빨리 Green 을 보기 위한 전략 2개

* 가짜 구현: 상수로 구현 -> 변수로 변경해나가기
* 명백한 구현 사용: 실제 구현 입력

=== 여기까지 한 것

* 설계상 결함을 실패하는 테스트로 변환
* stub 구현으로 빠르게 컴파일 통과
* 실제 구현 코드 입력 후 테스트 통과

== 3. 모두를 위한 평등

(equality for all)

직전의 Dollar 같이 객체를 값처럼 사용 - value object pattern +
객체의 인스턴스 변수가 생성자를 통해서 설정된 후에는 결코 변하지 않는다

value object 는 `equals()` 를 구현해야 한다, 해시 테이블의 키로 쓸 생각이면 `hashCode()` 를 구현해야 한다

삼각측량 (triangulation) - 수신국 사이의 거리가 알려져 있고, 각 수신국이 신호의 방향을 알고 있다면 신호의 거리와 방위를 알 수 있다 +
예제가 2개 이상 있어야만 코드를 일반화할 수 있다 (중복은 임시 무시) +
두 번째 예가 좀더 일반적인 결과값을 필요로 할 때만 일반화

저자는 어떻게 리팩토링해야 하는지 전혀 감이 안 올 때 삼각측량을 사용

=== 여기까지 한 것

* 디자인 패턴 (value object) 이 또 다른 오퍼레이션을 암시한다는 것을 앎
* 해당 오퍼레이션을 테스트, 간단히 구현
* 바로 리팩토링 대신 테스트를 좀 더 함
* 두 경우를 모두 수용할 수 있도록 리팩토링

== 4. 프라이버시

(privacy)

times 는 연산 값을 갖는 객체를 반환해야 한다 - 현재 테스트에서는 그걸 말하지 않음

.value object 반환 테스트
[source,java]
----
public void multiplication() {
    Dollar five = new Dollar(5);
    assertEquals(new Dollar(10), five.times(2));
    assertEquals(new Dollar(15), five.times(3));
}
----

equality 테스트가 정확히 작동하는 것을 검증하는 데 실패하면, times 도 정확한 작동 검증에 실패한다

=== 여기까지 한 것

* 오직 테스트를 향상시키기 위해서만 개발된 기능 사용
* 두 테스트가 동시에 실패하면 망한다는 점을 인식
* 위험 요소가 있음에도 계속 진행
* 테스트와 코드 간 결합을 찾추기 위해, 테스트하는 객체의 새 기능 사용