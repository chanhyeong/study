== 28. 초록 막대 패턴

**깨진 테스트 (빨간 막대) 가 있다면 빨리 고쳐야 한다**

=== 가짜로 구현하기 (진짜로 만들기 전까지만)

일단 상수를 반환하게 만들어서 테스트를 통과시킨다

가짜로 구현하기를 강력하게 만드는 두 가지 효과

. 심리학 - 막대가 초록색일 때 확신을 갖고 리팩토링해갈 수 있다
. 범위 (scope) 조절 - 테스트 케이스를 구현할 때, 이전 테스트의 작동이 보장되므로 다음 테스트 케이스에 집중할 수 있다

=== 삼각측량

**오로지 예시가 두 개 이상일 때만 추상화를 하기**

=== 명백한 구현

**단순한 연산은 그냥 구현해 버리기**

해결 순서: 제대로 동작하는 -> 깨끗한 코드

=== 하나에서 여럿으로

**일단은 컬렉션 없이 구현하고 그 다음에 컬렉션을 사용하게 한다**

== 29. xUnit 패턴

=== 단언 assertion

**boolean 수식을 작성해서 자동으로 코드가 동작하는지에 대한 판단을 수행하기**

=== 픽스처

**공통 사용? - 각 테스트에 있는 지역 변수를 인스턴스 변수로 바꾸고 setUp 에서 재정의, 인스턴스 변수들을 초기화하기**

(테스트 간 의존 관계가 생겨서 별로이지 않은가? private method 로 만들어도 의존 문제는 똑같긴 하겠지만 코드 파악 면에서는 더 나을 듯)

=== 외부 픽스처

**픽스처 중 외부 자원이 있을 경우 tearDown 을 재정의하여 자원을 해제한다**

=== 테스트 메소드

**테스트 케이스 하나는 'test' 로 시작하는 이름의 메소드로 나타내기**

(JUnit 에서는 어노테이션으로 된 듯)

테스트 메소드는 일기 쉽게 최대한 짧아야 한다

=== 예외 테스트

**예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에만 테스트가 실패하게 만들기**

=== 전체 테스트

**한 번에 실행하기 위해 모든 테스트 suite 에 대한 모음을 작성**

=== 30. 디자인 패턴

디자인 패턴의 성공은 객체 프로그래머들이 보는 공통성이며, 패턴들을 표현하는 다양성을 모두 억압

.사용 단계에 따른 디자인 패턴 분류 (X 가 사용)
[cols="2,1,1,4"]
|===

|패턴 |테스트 작성 |리팩토링 |설명

|커맨드 |X | |계산 작업에 대한 호출을 객체로 표현

|값 객체 |X | |객체가 생성된 이후 불변하게 하여 별칭 문제 없게

|널 객체 | |X |계산 작업의 기본 사례를 객체로 표현

|템플릿 메소드 | |X |변하지 않는 계산 작업 순서를 추상 메소드로 표현

|플러거블 객체 | |X |둘 이상의 객체 호출 - 다양성 표현

|플러거블 셀렉터 | |X |메소드를 동적으로 호출 - 필요 없는 하위 클래스 생성 방지

|팩토리 메소드 |X |X |생성자 대신 메소드 호출하여 객체 생성

|임포스터 |X |X |프로토콜을 갖는 다른 구현 추가 - 시스템에 변이 도입

|컴포지트 |X |X |하나의 객체로 여러 객체 행위 조합 표현

|===

=== 커맨드

복잡한 형태 - **계산 작업에 대한 객체 생성하여 호출**

=== 값 객체

**객체가 생성될 때 상태를 설정하여 절대 변할 수 없게, 관련 연산은 새로운 객체를 반환하게**

모든 값 객체는 동등성을 구현해야 한다 (+ 해싱)

==== 별칭 문제를 해결하는 몇 가지 방법

* 현재 의존하는 객체에 대한 참조를 외부로 알리지 않고 복사본 제공
** 시공간 측면에서 비싸다, 상태 변화를 공유하고 싶을 때는 사용할 수 없다
* 옵저버 패턴 - 상태가 변하면 통지
** 제어 흐름을 이해하기 어렵게 만들 수 있고, 의존성 설정/제거 로직이 복잡할 수 있다
* 객체를 덜 객체답게 취급 - '시간의 흐름에 따라 변하는 상태'를 제거

=== 널 객체

**객체의 특별항 상황을 표현하는 새로은 객체를 생성**

=== 템플릿 메소드

작업 순서를 변하지 않지만, 작업 단위에 대한 미래의 개선 가능성을 열어두기 위해 +
**다른 메소드를 호출하는 내용으로만 이루어진 메소드를 만들기**

setUp, tearDown 등

초기 설계보다는 경험에 의해 발견되는 것이 좋다

=== 플러거블 객체

변이 표현 - 명시적인 조건문이 아닌 **개별 객체를 도입, 개별 객체가 동일한 인터페이스를 구현**

=== 플러거블 셀렉터

메소드가 동적으로 호출되게 하려면, **메소드 이름을 저장하고 있다가 그 이름에 해당되는 메소드를 동적으로 호출**

리플렉션을 이용하여 동적으로 메소드 호출

=== 팩토리 메소드

새 객체 생성 시 **유연성을 원하는 경우 - 일반 메소드에서 객체 생성**

=== 사칭 사기꾼 (임포스터)

기존 코드에 새로운 변이를 도입하려면? 객체와 같은 프로토콜을 갖지만 구현은 다른 새로운 객체 추가

==== 리팩토링 중에 나타나는 두 가지 임포스터

. 널 객체 - 데이터가 없는 상태를 있는 상태와 동일하게 취급
. 컴포지트 - 객체 집합을 단일 객체처럼 취급

=== 컴포지트

하나의 객체가 다른 객체 목록을 조합한 것처럼 행동하려면
**객체 집합을 나타나는 객체를 단일 객체에 대한 임포스터로 구현**

=== 수집 매개 변수

여러 객체에 존재하는 오퍼레이션의 결과를 수집하려면 - 결과가 수집될 객체를 매개 변수로 추가

`java.io.Externalizable#ObjectOutput`

=== 싱글톤

전역 변수를 제공하지 않는 언어에서는 사용하지 마라