= Test Driven Development: By Example

== Preface

TDD 에서는 단순한 두 규칙만 따른다

* 자동화된 테스트가 실패할 경우에만 새로운 코드 작성
* 중복 제거

위의 단순함 때문에 다음의 복잡한 행동패턴이 만들어진다

* 매 결정사항에 대한 피드백을 제공하는 실행 가능한 코드를 기반으로 하는 유기적인 설계를 해야 함
* 자동화된 테스트를 직접 작성해야 한다
* 개발 환경은 작은 변화에도 빠르게 반응할 수 있어야 함
* 응집도가 높고 결합도는 낮는 컴포넌트들로 구성되게 끔 설게해야 한다

두 규칙에 의한 프로그래밍 순서

. Red - 실패하는 작은 테스트 작성
. Green - 빨리 테스트가 통과하게끔 만든다
. Refatoring - 테스트를 통과하게 만든 와중에 생겨난 중복 제거

이렇게 되면

* 결함 밀도를 충분히 감소시킬 수 있다면, QA 를 수동적 -> 능동적인 작업으로 전환 가능
* 예외 상황 수를 줄이면, 프로젝트 매니저가 정확히 추정 -> 매일의 개발 과정에 참여
* 기술적 대화의 주제가 분명해질수 있다면, 일일/주 단위 -> 분 단위 협력
* 결함 밀도가 충분히 낮아지면, 새 기능의 배포 가능한 소프트웨어를 매일 가짐 -> 고객과 새로운 비즈니스 관계에 이를 수 있음

=== 용기

TDD 는 프로그래밍 간 (시작의) 두려움을 관리하는 방법

망설이고, 커뮤니케이션을 덜 하고, 피드백 받는 것을 피하고, 까다롭게 만드는 원인

XP 는 절대적이지만 +
TDD 는 결정과 결정에 대한 피드백 사이의 간격을 인지, 간격을 통제할 수 있게 해주는 기술을 말한다

단순하게 시작, 자동화된 테스트, 새로운 설계 결정을 도입하기 위한 리팩토링을 할 준비

...

== 1부 - 화폐 예제

1장 ~ 17장

테스트에 의해 주도되는 전형적 모델 코드 개발 - TDD 의 리듬을 보도록

. 빠르게 테스트 추가
. 테스트 실행 후 새로 추가한 것이 실패하는지 확인
. 코드를 조금 수정
. 모든 테스트 실행하여 전부 성공하는지 확인
. 리팩토링으로 중복 제거

다음을 알게 될 것

* 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지
* 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지
* 얼마나 자주 테스트를 실행하는지
* 얼마나 수 없이 작은 단계를 통해 리팩토링이 되어가는지

== 2부 - xUnit 예시

18장 ~ 24장

파이썬으로 작성

== 3부 - 테스트 주도 개발의 패턴

25장 ~ 32장