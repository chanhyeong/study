== 31. 리팩토링

리팩토링은 프로그램의 의미를 변경해서는 안되지만 +
TDD 에서는 꼭 그렇지 않다 (상수 -> 변수로 바꾸기 등)

=== 차이점 일치시키기

**비슷한 두 코드 조각을 합치려면 두 코드를 단계적으로 비슷하게 수정 -> 동일해지만 합침**

가끔은 반대로, 최종 모양새를 먼저 생각한 다음 단계적으로 수정하기도

=== 변화 격리하기

**객체, 메소드의 일부만 바꾸려면, 바꿔야 할 부분을 격리**

바꿀 부분을 격리하고 바꾸면 되돌리기도 쉽다

메소드 추출하기, 객체 추출하기, 메소드 객체 등의 방법

=== 데이터 이주시키기

**표현법을 변경하려면 일시적으로 데이터를 중복**

보통의 마이그레이션 방법..

=== 생략

메소드 추출하기, 메소드 인라인, 인터페이스 추출하기, 메소드 옮기기, 매개 변수 추가, ...

=== 메소드 객체

**여러 개의 파라미터와 로컬 변수를 갖는 복잡한 메소드 -> 메소드를 꺼내서 객체로 만든다**

. 같은 파라미터를 갖는 객체 생성
. 메소드 로컬 변수를 객체 로컬 변수로
. 원래 메소드와 동일한 내용을 갖는 run() 메소드 생성
. 원래 메소드에서는 클래스 인스턴스 생성, run() 호출

시스템에 완전히 새로운 로직을 추가할 때 유용하다 +
메소드 추출하기를 적용할 수 없는 코드를 간결하게 만들기 위해서도 적합

=== 메소드 파라미터를 생성자 매개 변수로 바꾸기

동일한 파라미터를 개별 메소드에서 각각 받는다면 한 번만 전달하게 단순화

== 32. TDD 마스터하기

TDD 를 습관화하기 위한 몇 가지 질문들

=== 단계가 얼마나 커야 하나?

두 가지 질문을 의미

* 각 테스트가 다뤄야 할 범위가 얼마나 넓은지
* 리팩토링을 하면서 얼마나 많은 중간 단계를 거치는지

크게, 작게 둘 다 할 수 있어야 하지만 +
단계는 작아져야 한다

=== 테스트할 필요가 없는 것은 무엇인가?

자신이 작성한 거만 테스트하고, 다른 사람이 만든 코드를 테스트하지 마라

=== 좋은 테스트를 갖췄는지 여부를 어떻게 알 수 있는가?

설계 문제가 있음을 알려주는 테스트의 속성

* 긴 setup: 수백 줄의 객체 생성 코드는 문제가 있다 (객체가 너무 크다)
* 중복 setup: 공통의 setup 을 담아둘 곳이 없다 (밀접하게 엉킨 객체가 너무 많다)
* 오래 걸리는 테스트
* 깨지기 쉬운 테스트

=== TDD 로 프레임워크를 만드려면 어떻게 해야 하나?

현재에 맞게 설계하고 구현 -> 발생하지 않은 변주는 잘 표현하지 못하도, 발생하는 것들은 잘 표현할 수 있는 프레임워크가 되도록 도와준다

=== 피드백이 얼마나 필요한가?

테스트를 얼마나 작성해야 하는가

실패 간 평균 시간 (MTBF) 을 고려 - 실패할 때 실패하는 시점 간의 편균 시간차 +
(특정 케이스를 넣을지 말지 고민할 때, 그 케이스가 어느 정도로 들어올지를 미리 예측해서 필요 없으면 안 만들기)

=== 테스트를 지워야 할 때는 언제인가?

* 테스트를 삭제할 경우 자신감이 줄어들 것 같으면 말아야 한다
* 동일 코드를 실행하더라도 서로 다른 시나리오를 말하면 그대로 남겨야 한다

=== 프로그래밍 언어나 환경이 TDD 에 영향을 주는가?

TDD 주기 (테스트/컴파일/실행/리팩토링) 를 수행하기 힘든 언어나 환경에서는 단계가 커진다

(책에서는 정답을 알려주진 않았지만, 느려질 것 같다)

=== 거대한 시스템을 개발할 때에도 TDD 를 할 수 있는가?

어떤 새로운 테스트를 만들고, 새로운 리팩토링이 필요한지

기능의 양은 TDD 의 효율에 영향을 거의 미치지 않는다 +
중복 제거 -> 작은 객체 -> 독립적인 테스트

=== 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?

기술적으로 fixture 생성에 문제가 있다

테스트와 피드백 사이의 간격도 문제가 된다 (오래 걸려서)

(통합 테스트 레벨에서는 안하는게 좋을 것 같다)

=== 프로젝트 중반에 TDD 를 도입하려면 어떻게 해야 할까?

테스트를 염두에 두지 않은 코드는 테스트 하기가 쉽지 않다

. 변경의 범위를 제한
. 테스트와 리팩토링 deadlock 해결
** 피드백을 얻기 - 조심스럽게, 파트너와, ...

=== TDD 는 누구를 위한 것인가?

더 나은 코드를 작성하면 좀 더 성공할 것이다 - 해커적인 가정

깔끔한 설게를 하고, 설계를 더 개선할 수 있도록, 적절한 때 적절한 문제에 집중할 수 있게

시간이 흐를수록 코드에 대한 자신감을 쌓아줌

=== TDD 는 초기 조건에 민감한가?

특정 순서로 하면 매우 매끄럽게 넘어가는 것으로 보이는데 +
다른 순서로 하면 진행 방법이 없는 것으로 보이기도 한다

왜? 구현 기술이 부족해서? 특정 순서를 알려주는 무언가가 테스트 속에 있나? 작은 차원에서 초기 조건에 민감하다면, 큰 차원에서는 예측 가능한가?

=== TDD 와 패턴의 관계는?

반복적 행동을 규칙으로 내고, 그걸 적용하는건 기계적이며 단순 암기가 된다 +
처음 구해내는 것보다는 빠르고, 시간과 에너지 절약

패턴 주도 설계에 대한 구현 방법으로써 TDD = 설계를 미리 잡고 구현 +
-> 이거보단 무슨 일을 할지 생각하고 나중에 설계가 정해지도록 하는게 낫다

=== 어째서 TDD 가 잘 작동하는가?

결함 감소에서 비롯된다 +
(테스트를 자주 하면서) 설계 결정에 대한 피드백 고리를 단축시킨다

=== 이름을 테스트 주도 개발이라고 한 이유는?

* 개발: 분석, 논리/물리적 설계, 구현, 테스팅, 검토, 통합, 배포
* 주도: 개발을 테스트로 주도하지 않는다면 무엇으로 주도하는가?
* 테스트: 자동화 & 구체적 & 명확한 테스트

=== TDD 와 XP 의 실천법 사이에 어떤 관련이 있는가?

XP 의 나머지 부분이 TDD 를 + TDD 가 XP 의 나머지를 어떻게 향상시키는지

* 짝 프로그래밍
** TDD 의 테스트는 뛰어난 의사소통 수단이 된다
** TDD 의 리듬 때문에 완전히 몰입할 수 있다
* 활기차게 일하기: 테스트를 통과시킬 방법을 모르겠다면 잠깐 쉰다
* 지속적인 통합: 테스트는 좀 더 자주 통합할 수 있게 해준다
* 단순 설계: 테스트를 통과할 만큼만 코딩하고 중복 제거
** 요구 사항에 맞는 설계 & 다음 사용자 스토리에 대해서도 준비된 상태
* 리팩토링: 테스트가 있다면 리팩토링을 수행할 때 자신감
* 지속적인 전달: MTBF 를 개선한다면 혼란 없이 더 자주 코드를 출시할 수 있다

=== 다락의 도전

다락 에네스가 테스트할 수 없다고 정의해버린 것들

TDD 가 가능할지? (통합 테스트의 영역으로 가면, 불가능하다고 본다)
