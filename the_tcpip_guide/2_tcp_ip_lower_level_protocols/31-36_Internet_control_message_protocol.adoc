= IP 지원 프로토콜

== 31장. ICMP 개념과 일반 동작

=== ICMP 개요, 역사, 버전, 표준

* 네트워킹 동작을 지시해줄 정보를 교환해야하고, 테스트와 진단을 수행할 필요가 있다
** ICMP 를 통해 제공하고, ICMP 메시지를 통해 지원한다
* Internet Control Message Protocol (RFC 792)
** 모든 IP 모듈에 구현되어야 하는 IP 의 필수 요소
* 확장 가능한 범용 메시징 시스템을 정의한다
** 기타 프로토콜도 ICMP 에서 사용할 수 있는 메시지 유형을 정의할 수 있다
** (주소 마스크 요청, 경로 추적, 라우터 광고 등)

=== ICMP 일반 동작

==== ICMP 메시지 전달 서비스

* ICMP 자체는 서로 다른 ICMP 메시지가 어떻게 쓰이는지 정의하지 않음
* 메시지의 실제 용도는 메시지를 이용하는 프로토콜에 의해 정의
* 일반적으로 **소프트웨어의 특정 구성 요소가 ICMP 메시지를 생성할 필요가 있는지 상황을 탐지하는 방식으로 동작**
* 라우터와 일반 호스트 모두에서 송신할 수 있다

==== ICMP 에러 보고는 데이터그램 원본으로만 송신 가능

* 에러 발생 시 최초 출발지로만 알릴 수 있다
** 메시지에는 최초 출발지만 있기 때문
** 중간 라우터에서 문제가 생겨도 해당 라우터로 보낼 수 없다
* 출발지에서는 경로를 바꾸거나 에러 보고서를 생성할 수 있다

=== ICMP 메시지 클래스, 유형 코드

==== 메시지 클래스

* 오류 메시지: 에러가 발생했다는 것을 출발지 장비에게 알릴 때
* 정보 제공(요청) 메시지: 정보 교환, 기능 구현, 테스트 수행에 사용
** 애플리케이션에서 생성 or 정보 제공을 위해 주기적으로 생성

==== 메시지 유형

* 고유한 메시지 유형값을 갖는다, 8비트
* ICMPv4 에서는 유형값만 가지고 메시지의 클래스를 알 수 없다

==== 메시지 코드

* 메시지 유형: 일반적인 목적. 메시지 코드: 세부적으로 메시지 분류

==== 요약

p513 ~ p514 표

=== ICMP 메시지 생성과 처리 관습, 규칙

* ICMP 메시지는 사용자 데이터를 담지 않아서 대역폭 낭비는 극히 일부이다
* 필요한 경우에만 ICMP 메시지를 보내고, 생성되는 상황을 신중하게 제어하려고 한다
* 여러 RFC 에서 ICMP 메시지 생성과 처리법을 설명한 관습, 규칙 모음이 존재한다

==== ICMP 메시지 응답의 한계

문제는 주로 오류 메시지에서 일어난다 +
생성 루프가 발생할 수도 있다

오류 메시지는 다음에 대한 응답으로 생성되면 안된다

* ICMP 오류 메시지
* 브로드캐스트 or 멀티캐스트 데이터그램
** ICMPv6 패킷 크기 초과 메시지는 멀티캐스트 주소로 송신될 수 있음
* 데이터그램 단편
* 유니캐스트가 아닌 출발지 주소를 가지고 있는 데이터그램

==== ICMP 메시지 처리 관습

* IPv6 에서는 메시지 클래스를 유형값을 통해 파악할 수 있다
** 알려지지 않은 유형 값의 오류 메시지는 상위 계층으로 전달되어야 한다
** 알려지지 않은 유형 값의 정보 메시지는 버려진다
* 메시지 유형 처리 방향을 지시하기 위한 구체적인 규칙이 존재한다
* ICMP 메시지를 수신 장비가 반드시 처리해야 하는 것은 아니다
** 광고 같은건 예외

=== ICMP 일반 메시지 포맷과 데이터 캡슐화

메시지 유형에 따라 담고 있는 정보의 유형도 다르지만, 일부분은 동일하다

==== ICMP 일반 메시지 포맷

모든 ICMP 메시지에서 동일한 크기와 의미를 가지는 3개의 필드로 구성 (v4, v6 동일)

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |메시지 유형 식별

|코드 |1 |하위 유형 식별

|체크섬 |2 |IP 헤더 체크섬과 유사한 방법으로 계산. 에러 탐지 기능 제공

|본문 |가변 |

|===

==== ICMP 오류 메시지에 포함된 원본 데이터그램

오류 메시지 본문에는 원본 데이터그램의 일부분을 포함한다

각 오류 메시지는 버전에 따라 아래와 같음

* ICMPv4: IP 헤더 전체 + 페이로드의 처음 8바이트 (캡슐화된 상위 계층 헤더)
* ICMPv6: 최소 IPv6 MTU 인 1,280 바이트를 초과하지 않는 범위에서 가능한 많은 양의 데이터그램 포함

==== ICMP 데이터 캡슐화

* IP 데이터그램으로 캡슐화

== 32장. ICMPv4 오류 메시지 유형과 포맷

=== ICMPv4 목적지 접근 불가 메시지

* 데이터그램이 목적지까지 도착한다는 보장이 없고, 도달 못할 수 있다 -> 이에 맞추어 설계되었다
* 목적지 접근 불가 메시지: 부적절한 일이 일어났고, 왜 일어났는지 출발지에 알려줄 수 있는 피드백 방법

==== ICMPv4 목적지 접근 불가 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |3

|코드 |1 |네트워크, 호스트, 프로토콜 접근 불가 등 (p523 ~ p524 표)

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 목적지 접근 불가 메시지 해석

* 이 메시지도 최선 노력 메시지다 (도달하지 않을 수 있다)
* 라우터는 데이터그램 전달 실패를 감지해도 ICMP 메시지를 보내지 않을 수 있다
** 상위 계층 처리 방법이 중요한 이유

=== ICMPv4 송신 속도 낮춤 (Source Quench) 메시지

* 각 장비는 데이터그램이 자신의 처리 속도보다 빠르게 들어올 경우를 대비하여 제한된 버퍼를 가진다
* 버퍼 공간이 남아있지 않은 장비는 데이터그램을 버릴 수 밖에 없다 -> 혼잡 상황
* 송신 속도 낮춤 메시지: 자신이 과부하가 걸리고 있다는 사실을 알리는 피드백 제공

==== ICMPv4 송신 속도 낮춤 메시지

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |4

|코드 |1 |0 으로 고정

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 송신 속도 낮춤 메시지 문제점

* 상황에 대한 구체적인 정보가 없음
* 혼잡 상태가 해제됐다는 사실도 알려주지 않음
* 사용되지 않고 49장 TCP 레벨의 흐름 제어을 더 많이 사용

=== ICMPv4 시간 초과 메시지

* TTL 필드 포함: 데이터그램이 한 장비에서 다른 장비로 전달될 수 있는 횟수
* TTL 만료로 버린 장비는 출발지에게 시간 초과 메시지를 송신
** 출발지 장비에서는 라우팅 문제 발생 or TTL 을 너무 낮게 설정했다고 인지
* 단편 메시지에서도 사용
** 목적지 장비가 첫 단편이 왔을 때 켜고, 수신하기 전에 만료되면 포기하고 시간 초과 메시지 송신

==== ICMPv4 시간 초과 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |11

|코드 |1 |0 이면 TTL 필드 만료, 1이면 단편 재조합 시간 초과

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 시간 초과 메시지 응용

* traceroute (tracecert): 데이터그램의 출발지 ~ 목적지 사이의 경로 순서를 보여줌
* TTL 필드를 1씩 증가시켜서 각 홉에서 오는 ICMP 초과 메시지를 받아서 분석

=== ICMPv4 리다이렉트 메시지

* 라우터가 경로를 결정하고 라우팅 정보를 관리, 호스트는 경로 정보를 전부 라우터에 의존
* 어떤 목적지에 어떤 라우터를 사용할지 자동으로 학습하는 방법
* 특정 네트워크로 보낼 때 다른 라우터를 사용하라고 알려주는 메시지

==== ICMPv4 리다이렉트 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |5

|코드 |1 |바로 다음 설명으로 나옴

|체크섬 |2 |

|인터넷 주소 |4 |다음번 전송에 사용하기를 원하는 라우터 주소

|본문 |가변 |

|===

==== 리다이렉트 메시지 해석 코드

* 송신 장비가 나중에 어떤 주소로 리다이렉트 될지 알 수 있다
* 호스트에 대한 리다이렉트 (1) 만 많이 쓰임

==== 리다이렉트 메시지 한계

* 호스트에게 경로 정보를 제공하지만, 라우터 간 경로 정보를 교환하는 데는 쓰이지 않는다
* 라우터 간 비효율 문제는 라우팅 프로토콜로 해결해야 한다

=== ICMPv4 인자 문제 메시지

* 헤더 인자에서 잘못된 필드를 발견한 경우
* 어떤 필드가 문제를 일으켰는지 나타내는 특수 포인터 포함
* 호스트와 라우터 모두 생성할 수 있음

==== ICMPv4 인자 문제 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |12

|코드 |1 |0: 포인터 에러를 가리킴, 1: 필요 옵션의 부재, 2: 잘못된 길이

|체크섬 |2 |

|포인터 |1 |문제 바이트 위치

|미사용 |3 |

|본문 |가변 |

|===

== 33장. ICMPv4 정보 제공 메시지 유형과 포맷

=== ICMPv4 에코 요청/응답 메시지

* 서로 데이터그램을 송신할 수 있는 지 확인
* 에코 요청 메시지 송신, 에코 응답 메시지 반환
* 하나 이상의 에코 메시지를 하나 이상의 목적지로 보내고, 받을 수 있음
* ping: 호스트 접근성을 테스트하는 데 쓰이는 유틸리티

=== ICMPv4 타임스탬프 메시지

* 두 장비간 시간 동기화에 사용되나, 현재는 NTP 를 더 많이 사용하여 생략

=== ICMPv4 라우터 광고, 라우터 정보 요청 메시지

호스트에 라우터 정보 제공

==== 라우터 발견 절차

* 라우터 발견: 호스트가 자동으로 로컬 라우터를 식별하고 정보를 얻을 수 있는 방법
* 라우터는 라우터 광고 메시지를 송신할 책임이 있다
** 존재한다는 사실, 라우터의 주소, 얼마나 오래 정보를 가지고 있어야 하는지
** 송신 간격을 조절할 수 있다
* 광고 메시지를 기다리는 대신 라우터 정보 요청 메시지를 송신할 수 있다

=== ICMPv4 주소 마스크 요청/응답 메시지

생략

=== ICMPv4 경로 추적 메시지

* 첫 구현은 출발지 장비가 경로 상의 각 라우터마다 테스트 메시지를 보내도록 요구
** + 경로가 중간에 바뀔 수 있다는걸 고려하지 않음
* Traceroute IP 옵션을 포함한 **하나의** 데이터그램을 송신
** 각 라우터가 이 옵션을 보고 경로 추적 메시지 송신

==== 경로 추적 메시지 이용

* 호스트와 라우터가 새 IP 옵션과 경로 추적 ICMP 메시지를 이해하는 경우에만 사용 가능
* 그래서 대부분은 옛날 구현 방식을 사용

== 34장. ICMPv6 오류 메시지 유형과 포맷

=== ICMPv6 목적지 접근 불가 메시지

* IPv4 에서 나타나는 대부분의 문제가 IPv6 에서는 일어나지 않기 때문에 ICMPv6 코드값이 간소화됨

=== ICMPv6 패킷 크기 초과 메시지

* IPv6 는 라우터가 데이터그램을 단편화하지 못함
* 각 호스트가 데이터그램이 전송 경로에서 허용하는 크기인지 확인해야 한다
* 보내지 못한 라우터가 처음 전송한 장비에 데이터그램을 버렸다고 보고

==== 응용

* 경로 MTU 발견을 구현할 때 사용
* 검사용 메시지를 여러 번 전송하여 패킷 크기 초과 메시지가 돌아오지 않는 크기를 찾음

=== ICMPv6 시간 초과 메시지

* TTL (IPv4) -> Hop Limit (IPv6)
* IPv4 와 동일하게 단편화 재조합이 실패했을 때도 발생

==== 응용

* IPv6 용 traceroute6 커맨드도 있음

=== ICMPv6 인자 문제 메시지

* 포인터 필드를 32비트로 확장
* 포인터 필드를 모든 코드에서 같이 사용, 발생한 문제의 일반적인 특성을 알림

== 35장. ICMPv6 정보 제공 메시지 유형과 포맷

=== ICMPv6 에코 요청/응답 메시지

=== ICMPv6 라우터 광고, 라우터 정보 요청 메시지

=== ICMPv6 주변 정보 광고와 주변 정보 요청 메시지

* 같은 네트워크 내 호스트끼리 정보를 교환할 수 있도록 도움
** 호스트 간 통신 or 발견 기능
* 파라미터 교환과 주변 호스트의 존재를 결정하는 방법을 정형화
* 주소 결정 방식 & 다음 홉 결정 과정 & 주변 노드 도착 불가능 검사까지 정의
* 주변 노드의 존재와 도착가능 여부 확인하고 주소 결정을 시작할 수 있음

=== ICMPv6 리다이렉트 메시지

* 라우터가 데이터그램을 받았을 때 다른 라우터에게 보내는게 더 효율적이란 것을 알았을 때
* ICMPv4 와 다르게 정보 제공 메시지
* 일반 IP 메시지에 반응하기 때문에 오류 메시지처럼 원 데이터그램의 복사본을 포함

=== ICMPv6 라우터 재번호부여 (Renumbering) 메시지

* 큰 네트워크를 이전시키거나 합하여 더 간단하게 만들 수 있음
* 라우터가 새로 주어진 prefix (네트워크 ID) 를 사용하여 자동으로 재번호부여를 할 수 있는 방법
* 순서
.. 관리자: 재번호부여 명령
.. 라우터: 명령의 prefix 가 사용하던 주소의 prefix 가 같으면, 메시지의 새 prefix 로 변경
*** 필요 시 재번호부여 결과 메시지를 보낼 수 있음

=== ICMPv6 정보 제공 메시지 선택사항

* 정보 제공 메시지는 하나 이상의 선택사항을 삽입할 수 있는 선택사항 필드를 가짐
** 유형, 길이, 값
* 종류
** 출발지 링크 계층 주소 (Source Link-Layer Address)
** 목적지 링크 계층 주소
** 접두사 정보
** 리다이렉트 헤더
** MTU

== 36장. IPv6 주변 발견 (ND) 프로토콜

=== IPv6 ND 개요

* ICMP 는 계획이 아니라 필요에 따라 만들어 졌고, 다양한 인터넷 표준에서 정의했다
** 로컬 장비 기능이 구현되는 방식에 한계가 있었다

==== 로컬 네트워크 기능의 정형화: 주변 발견

* IPv6 주변 발견 (Neighbor Discovery) 는 로컬 장비 간 통신과 관련된 기능과 작업들을 통합할 기회
* 두 장비가 '주변에 있다' = 같은 로컬 네트워크에 있어 직접 정보를 전달할 수 있다
* ND 프로토콜은 로컬 장비가 서로의 존재를 발견하는 것과 관련이 깊다

=== IPv6 ND 의 기능 개요

* IPv6 환경에서 일반 호스트와 라우터가 네트워크 기능을 적절히 실행하기 위해 ND 를 사용하여 정보 교환
* ICMP 와 유사한 부분이 많다
* 프로토콜이 수행하는 기능을 9가지로 정의, 3가지의 기능 그룹으로 나눔 (p578 그림)
** 호스트 라우터 발견 기능, 호스트 간 통신 기능, 리다이렉트 기능

==== 호스트 라우터 발견 기능

* 라우터 발견 (RD): 호스트가 로컬 네트워크 내 라우터를 발견하는 ㅂ아법
* 접두사 발견: 네트워크 식별자, 자신이 속한 네트워크를 알아내어 데이터그램을 직접/간접 전송 결정
* 인자 발견: 라우터에 관한 중요 인자 습득 (MTU 등)
* 주소 자동 구성

==== 호스트 간 통신 기능

* 주소 결정: 다른 장비의 2계층 주소를 3계층 주소를 통해 알아내려 할 때 (IPv4 에서는 ARP)
* 다음 홉 결정: 목적지 주소를 보고 어디로 보내야 할지 결정
* 주변 노드 접근 불가능 검사
* 중복 주소 검사

==== 리다이렉트 기능

* 목적지로 보낼 때 사용할 수 있는 더 좋은 다음 홉을 알리는 기능

==== ND 가 사용하는 ICMPv6 메시지

* ND 는 ICMPv6 메시지를 사용하여 자신의 기능 구현
* 라우터 광고/요청 메시지
* 주변 정보 광고/요청 메시지
* 리다이렉트 메시지

=== IPv4 기능과 동일한 IPv6 기능

* ICMPv4 의
** 라우터 발견
** 주소 결정 프로토콜: ARP 와 유사하지만 ND 의 주소 결정 능력이 더 낫다
** 리다이렉트
* ND 에서 이루어진 중요 개선 사항
** 라우터 발견의 정형화: 이전에는 상황에 따라 바뀌지만, 여기서는 정형화. TCP/IP 프로토콜 수트의 일부로 만들었다
** 주소 결정의 정형화: 3계층 기능으로 IP 와 밀접히 연관 (ARP 는 계층이 모호했는데, 필요 없음)
** 보안 기능 강화, 자동 구성, 동적 라우터 선택, 멀티캐스트 기반 주소 결정, 더 나은 리다이렉트

=== IPv6 ND 호스트 라우터 발견 기능

* 발견: 호스트와 라우터 간의 ND 통신
** 라우터를 발견하는 것 + 중요한 인자를 교환하는 것
** 대부분은 라우터 -> 호스트로 흘러간다
* 보내는 장비의 2계층 주소를 선택사항으로 포함할 수 있다
** 주소 결정 캐시 갱신 가능

==== 라우터가 수행하는 호스트 라우터 발견 기능

* 라우터 광고
* 인자 관리: 기본 홉 한계 필드값, 기본 MTU, 네트워크 접두사 등
* 요청 처리: 라우터 요청 메시지를 받으면 바로 라우터 광고 메시지 전송

==== 호스트가 수행하는 호스트 라우터 발견 기능

* 광고 처리
* 요청 생성: 호스트가 처음 켰을 때, 다음 라우터 광고가 올 때까지 기다릴 수 없을 경우
* 자동 구성

=== IPv6 호스트 간 통신 기능

==== 다음 홉 결정

* 데이터그램을 보내려고 할 때 맨 처음엔 다음 홉 결정
** 목적지 주소를 보고 어떤 전송 방식을 사용해야 하는지 결정
* 로컬 라우터에서 습득한 접두사와 비교
* 모든 데이터그램에 대해서 다음 홉 결정을 하진 않음
** 목적지 캐시를 두어 최근 데이터그램을 보낸 장비의 다음 홉이 어디인지 기억

==== 주소 결정

* 주소 결정: 3계층 주소로 2계층 주소를 알아내는 문제
* 목적지 2계층 주소를 알고 싶다? -> 목적지 장비의 IP 주소를 주변 정보 요청 메시지에 실어 전송
* -> 장비가 응답으로 주변 정보 광고 메시지 전송
** 목적지 장비의 요청 노드 주소라는 특별한 멀티캐스트 주소를 사용하여 전송 (13장, 25장)

==== 주변 정보 광고 메시지를 통해 주변 정보 갱신

* 하드웨어 장애 등으로 NIC 를 바꾸었다면 2계층 주소가 바뀜 -> 주변 노드에 광고, 새 MAC 주소로 변경하도록 함

==== 주변 노드 접근 불가능 검사와 주변 노드 캐시

* 각 노드는 자신의 주변 노드에 대한 정보를 유지, 네트워크 상태가 바뀔 때마다 동적으로 갱신
* 접근할 수 없는 호스트가 생기면? -> 새로운 라우터를 찾아야 함
* 호스트: 주변 노드 캐시 관리 (임시 정보), 타이머 만료 시 접근 불가능으로 간주

==== 중복 주소 검사

. 호스트가 자신이 사용하길 원하는 주소로 주변 정보 요청 메시지를 보냄
. 광고 메시지가 돌아오면? -> 이미 사용중

=== IPv6 ND 리다이렉트 기능

* 리다이렉트 메시지는 라우터만 전송
* 받은 호스트는 다음부터는 라우터가 지정한 첫 번째 홉으로 전송
* 리다이렉트할 목적지의 데이터 링크 계층 주소도 같이 전송할 수 있음