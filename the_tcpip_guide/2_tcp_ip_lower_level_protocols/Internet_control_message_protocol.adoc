= IP 지원 프로토콜

== 31장. ICMP 개념과 일반 동작

=== ICMP 개요, 역사, 버전, 표준

* 네트워킹 동작을 지시해줄 정보를 교환해야하고, 테스트와 진단을 수행할 필요가 있다
** ICMP 를 통해 제공하고, ICMP 메시지를 통해 지원한다
* Internet Control Message Protocol (RFC 792)
** 모든 IP 모듈에 구현되어야 하는 IP 의 필수 요소
* 확장 가능한 범용 메시징 시스템을 정의한다
** 기타 프로토콜도 ICMP 에서 사용할 수 있는 메시지 유형을 정의할 수 있다
** (주소 마스크 요청, 경로 추적, 라우터 광고 등)

=== ICMP 일반 동작

==== ICMP 메시지 전달 서비스

* ICMP 자체는 서로 다른 ICMP 메시지가 어떻게 쓰이는지 정의하지 않음
* 메시지의 실제 용도는 메시지를 이용하는 프로토콜에 의해 정의
* 일반적으로 **소프트웨어의 특정 구성 요소가 ICMP 메시지를 생성할 필요가 있는지 상황을 탐지하는 방식으로 동작**
* 라우터와 일반 호스트 모두에서 송신할 수 있다

==== ICMP 에러 보고는 데이터그램 원본으로만 송신 가능

* 에러 발생 시 최초 출발지로만 알릴 수 있다
** 메시지에는 최초 출발지만 있기 때문
** 중간 라우터에서 문제가 생겨도 해당 라우터로 보낼 수 없다
* 출발지에서는 경로를 바꾸거나 에러 보고서를 생성할 수 있다

=== ICMP 메시지 클래스, 유형 코드

==== 메시지 클래스

* 오류 메시지: 에러가 발생했다는 것을 출발지 장비에게 알릴 때
* 정보 제공(요청) 메시지: 정보 교환, 기능 구현, 테스트 수행에 사용
** 애플리케이션에서 생성 or 정보 제공을 위해 주기적으로 생성

==== 메시지 유형

* 고유한 메시지 유형값을 갖는다, 8비트
* ICMPv4 에서는 유형값만 가지고 메시지의 클래스를 알 수 없다

==== 메시지 코드

* 메시지 유형: 일반적인 목적. 메시지 코드: 세부적으로 메시지 분류

==== 요약

p513 ~ p514 표

=== ICMP 메시지 생성과 처리 관습, 규칙

* ICMP 메시지는 사용자 데이터를 담지 않아서 대역폭 낭비는 극히 일부이다
* 필요한 경우에만 ICMP 메시지를 보내고, 생성되는 상황을 신중하게 제어하려고 한다
* 여러 RFC 에서 ICMP 메시지 생성과 처리법을 설명한 관습, 규칙 모음이 존재한다

==== ICMP 메시지 응답의 한계

문제는 주로 오류 메시지에서 일어난다 +
생성 루프가 발생할 수도 있다

오류 메시지는 다음에 대한 응답으로 생성되면 안된다

* ICMP 오류 메시지
* 브로드캐스트 or 멀티캐스트 데이터그램
** ICMPv6 패킷 크기 초과 메시지는 멀티캐스트 주소로 송신될 수 있음
* 데이터그램 단편
* 유니캐스트가 아닌 출발지 주소를 가지고 있는 데이터그램

==== ICMP 메시지 처리 관습

* IPv6 에서는 메시지 클래스를 유형값을 통해 파악할 수 있다
** 알려지지 않은 유형 값의 오류 메시지는 상위 계층으로 전달되어야 한다
** 알려지지 않은 유형 값의 정보 메시지는 버려진다
* 메시지 유형 처리 방향을 지시하기 위한 구체적인 규칙이 존재한다
* ICMP 메시지를 수신 장비가 반드시 처리해야 하는 것은 아니다
** 광고 같은건 예외

=== ICMP 일반 메시지 포맷과 데이터 캡슐화

메시지 유형에 따라 담고 있는 정보의 유형도 다르지만, 일부분은 동일하다

==== ICMP 일반 메시지 포맷

모든 ICMP 메시지에서 동일한 크기와 의미를 가지는 3개의 필드로 구성 (v4, v6 동일)

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |메시지 유형 식별

|코드 |1 |하위 유형 식별

|체크섬 |2 |IP 헤더 체크섬과 유사한 방법으로 계산. 에러 탐지 기능 제공

|본문 |가변 |

|===

==== ICMP 오류 메시지에 포함된 원본 데이터그램

오류 메시지 본문에는 원본 데이터그램의 일부분을 포함한다

각 오류 메시지는 버전에 따라 아래와 같음

* ICMPv4: IP 헤더 전체 + 페이로드의 처음 8바이트 (캡슐화된 상위 계층 헤더)
* ICMPv6: 최소 IPv6 MTU 인 1,280 바이트를 초과하지 않는 범위에서 가능한 많은 양의 데이터그램 포함

==== ICMP 데이터 캡슐화

* IP 데이터그램으로 캡슐화

== 32장. ICMPv4 오류 메시지 유형과 포맷

=== ICMPv4 목적지 접근 불가 메시지

* 데이터그램이 목적지까지 도착한다는 보장이 없고, 도달 못할 수 있다 -> 이에 맞추어 설계되었다
* 목적지 접근 불가 메시지: 부적절한 일이 일어났고, 왜 일어났는지 출발지에 알려줄 수 있는 피드백 방법

==== ICMPv4 목적지 접근 불가 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |3

|코드 |1 |네트워크, 호스트, 프로토콜 접근 불가 등 (p523 ~ p524 표)

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 목적지 접근 불가 메시지 해석

* 이 메시지도 최선 노력 메시지다 (도달하지 않을 수 있다)
* 라우터는 데이터그램 전달 실패를 감지해도 ICMP 메시지를 보내지 않을 수 있다
** 상위 계층 처리 방법이 중요한 이유

=== ICMPv4 송신 속도 낮춤 (Source Quench) 메시지

* 각 장비는 데이터그램이 자신의 처리 속도보다 빠르게 들어올 경우를 대비하여 제한된 버퍼를 가진다
* 버퍼 공간이 남아있지 않은 장비는 데이터그램을 버릴 수 밖에 없다 -> 혼잡 상황
* 송신 속도 낮춤 메시지: 자신이 과부하가 걸리고 있다는 사실을 알리는 피드백 제공

==== ICMPv4 송신 속도 낮춤 메시지

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |4

|코드 |1 |0 으로 고정

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 송신 속도 낮춤 메시지 문제점

* 상황에 대한 구체적인 정보가 없음
* 혼잡 상태가 해제됐다는 사실도 알려주지 않음
* 사용되지 않고 49장 TCP 레벨의 흐름 제어을 더 많이 사용

=== ICMPv4 시간 초과 메시지

* TTL 필드 포함: 데이터그램이 한 장비에서 다른 장비로 전달될 수 있는 횟수
* TTL 만료로 버린 장비는 출발지에게 시간 초과 메시지를 송신
** 출발지 장비에서는 라우팅 문제 발생 or TTL 을 너무 낮게 설정했다고 인지
* 단편 메시지에서도 사용
** 목적지 장비가 첫 단편이 왔을 때 켜고, 수신하기 전에 만료되면 포기하고 시간 초과 메시지 송신

==== ICMPv4 시간 초과 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |11

|코드 |1 |0 이면 TTL 필드 만료, 1이면 단편 재조합 시간 초과

|체크섬 |2 |

|미사용 |4 |

|본문 |가변 |

|===

==== 시간 초과 메시지 응용

* traceroute (tracecert): 데이터그램의 출발지 ~ 목적지 사이의 경로 순서를 보여줌
* TTL 필드를 1씩 증가시켜서 각 홉에서 오는 ICMP 초과 메시지를 받아서 분석

=== ICMPv4 리다이렉트 메시지

* 라우터가 경로를 결정하고 라우팅 정보를 관리, 호스트는 경로 정보를 전부 라우터에 의존
* 어떤 목적지에 어떤 라우터를 사용할지 자동으로 학습하는 방법
* 특정 네트워크로 보낼 때 다른 라우터를 사용하라고 알려주는 메시지

==== ICMPv4 리다이렉트 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |5

|코드 |1 |바로 다음 설명으로 나옴

|체크섬 |2 |

|인터넷 주소 |4 |다음번 전송에 사용하기를 원하는 라우터 주소

|본문 |가변 |

|===

==== 리다이렉트 메시지 해석 코드

* 송신 장비가 나중에 어떤 주소로 리다이렉트 될지 알 수 있다
* 호스트에 대한 리다이렉트 (1) 만 많이 쓰임

==== 리다이렉트 메시지 한계

* 호스트에게 경로 정보를 제공하지만, 라우터 간 경로 정보를 교환하는 데는 쓰이지 않는다
* 라우터 간 비효율 문제는 라우팅 프로토콜로 해결해야 한다

=== ICMPv4 인자 문제 메시지

* 헤더 인자에서 잘못된 필드를 발견한 경우
* 어떤 필드가 문제를 일으켰는지 나타내는 특수 포인터 포함
* 호스트와 라우터 모두 생성할 수 있음

==== ICMPv4 인자 문제 메시지 포맷

[cols="1,1,3"]
|===
|필드명 |크기 |설명

|유형 |1 |12

|코드 |1 |0: 포인터 에러를 가리킴, 1: 필요 옵션의 부재, 2: 잘못된 길이

|체크섬 |2 |

|포인터 |1 |문제 바이트 위치

|미사용 |3 |

|본문 |가변 |

|===

== 33장. ICMPv4 정보 제공 메시지 유형과 포맷

=== ICMPv4 에코 요청/응답 메시지

* 서로 데이터그램을 송신할 수 있는 지 확인
* 에코 요청 메시지 송신, 에코 응답 메시지 반환
* 하나 이상의 에코 메시지를 하나 이상의 목적지로 보내고, 받을 수 있음
* ping: 호스트 접근성을 테스트하는 데 쓰이는 유틸리티

=== ICMPv4 타임스탬프 메시지

* 두 장비간 시간 동기화에 사용되나, 현재는 NTP 를 더 많이 사용하여 생략

=== ICMPv4 라우터 광고, 라우터 정보 요청 메시지

호스트에 라우터 정보 제공

==== 라우터 발견 절차

* 라우터 발견: 호스트가 자동으로 로컬 라우터를 식별하고 정보를 얻을 수 있는 방법
* 라우터는 라우터 광고 메시지를 송신할 책임이 있다
** 존재한다는 사실, 라우터의 주소, 얼마나 오래 정보를 가지고 있어야 하는지
** 송신 간격을 조절할 수 있다
* 광고 메시지를 기다리는 대신 라우터 정보 요청 메시지를 송신할 수 있다

=== ICMPv4 주소 마스크 요청/응답 메시지

생략

=== ICMPv4 경로 추적 메시지

* 첫 구현은 출발지 장비가 경로 상의 각 라우터마다 테스트 메시지를 보내도록 요구
** + 경로가 중간에 바뀔 수 있다는걸 고려하지 않음
* Traceroute IP 옵션을 포함한 **하나의** 데이터그램을 송신
** 각 라우터가 이 옵션을 보고 경로 추적 메시지 송신

==== 경로 추적 메시지 이용

* 호스트와 라우터가 새 IP 옵션과 경로 추적 ICMP 메시지를 이해하는 경우에만 사용 가능
* 그래서 대부분은 옛날 구현 방식을 사용

== 34장. ICMPv6 오류 메시지 유형과 포맷

=== ICMPv6 목적지 접근 불가 메시지

* IPv4 에서 나타나는 대부분의 문제가 IPv6 에서는 일어나지 않기 때문에 ICMPv6 코드값이 간소화됨

=== ICMPv6 패킷 크기 초과 메시지

* IPv6 는 라우터가 데이터그램을 단편화하지 못함
* 각 호스트가 데이터그램이 전송 경로에서 허용하는 크기인지 확인해야 한다
* 보내지 못한 라우터가 처음 전송한 장비에 데이터그램을 버렸다고 보고

==== 응용

* 경로 MTU 발견을 구현할 때 사용
* 검사용 메시지를 여러 번 전송하여 패킷 크기 초과 메시지가 돌아오지 않는 크기를 찾음

=== ICMPv6 시간 초과 메시지

* TTL (IPv4) -> Hop Limit (IPv6)
* IPv4 와 동일하게 단편화 재조합이 실패했을 때도 발생

==== 응용

* IPv6 용 traceroute6 커맨드도 있음

=== ICMPv6 인자 문제 미시지

* 포인터 필드를 32비트로 확장
* 포인터 필드를 모든 코드에서 같이 사용, 발생한 문제의 일반적인 특성을 알림