= 인터넷 프로토콜 버전 4 (IP/IPv4)

== 15장. 인터넷 프로토콜 버전, 개념, 개요

* 네트워크 계층은 서로 다른 네트워크에서 임의의 방법으로 연결된 장비 사이에서 데이터를 전달
** 서로 연결되지 않은 네트워크 장비 간 데이터를 전달
* IP 는 데이터를 TCP/IP 네트워크에서 전송하는 방법

=== 주요 동작 특성

* 전역 주소지정: 네트워크를 위한 주소지정 방법 정의, 데이터그램 전달에 사용
* 하위 프로토콜에 무관: 어떤 종류의 하위 네트워크에서도 데이터를 전송하도록 설계
* 비연결형 전달: 연결과 상관 없이 데이터그램을 만들어서 곧바로 전달
* 신뢰성 없는 전달: 데이터그램을 보낸 뒤 바로 송신. 전달을 보장하진 않음
* 비승인형 전달: 송신한 데이터그램이 제대로 전송됐는지 알지 못함

보장형 기능은 성능에 영향, 계층 구조에 맡김 +
TCP 와 UDP 의 차이로 이해할 수 있다

=== 기능

. 주소지정: 호스트 주소지정 방법을 포함
** 임의의 대형 네트워크에서 유일하게 장비의 주소를 지정할 수 있도록 설계
** 원거리 네트워크로 라우팅을 가능케하는 구조
. 데이터 캡슐화와 포매팅/패키징
. 단편화와 재조합: 데이터그램을 조각으로 단편화하여 로컬 네트워크로 보내는 기능
. 라우팅과 간접 전달
** 직접 연결되지 않은 원거리 네트워크로의 라우팅
** ICMP, RIP (Routing Information Protocol), BGP (Border Gateway Protocol)

=== 역사, 표준, 버전, 밀접히 연관된 프로토콜

* IP 자체는 TCP/IP 프로토콜 슈트가 정의된 처음 몇 년은 존재하지 않음
** TCP 에 속해서 3가지 버전으로 개선되었다가, 버전 4에서 분리
* 버전 5는 왜 없는가? -> 실험적 프로토콜에 할당되었다가 6이 새로 개발됨

==== 관련 프로토콜

IP 의 일부는 아니지만, 특수한 상황을 위해 IP 의 기능을 추가하거나 확장하는데 쓰임

* NAT (Network Address Translation) - 28장
* IPsec (IP Security) - 29장
* Mobile IP - 30장

== 16장. IPv4 주소지정 개념과 이슈

=== 개요와 기초

2가지 기능

* 네트워크 인터페이스 식별: 올바른 수신자에게 전달 보장을 위해 장비와 네트워크 간의 인터페이스를 유일하게 식별할 수 있도록 함
* 라우팅: 동일 네트워크에 있지 않은 경우 간접적으로 전달

IP 주소가 장비 자체가 아니라 네트워크 인터페이스를 식별 +
-> 대형, 가상 네트워크 연결에 초점이 맞춰져 있다

라우터가 주소 내용을 통해 데이터그램의 처리 방향을 결정할 수 있도록 주소지정 체계가 설계되어 있다

==== 장비별 IP 주소의 수, 유일성과 한정성

* 모든 장비에는 IP 주소가 하나씩 있다
* 라우터는 하나 이상의 IP 주소를 가질 수 있다
** 2계층 장비 (리피터, 브리지, 스위치) 는 IP 주소가 없어도 된다 (optional)
* 단일 인터네트워크 상에서 각 IP 는 유일해야 한다
* 장비가 새로운 네트워크로 이동한다면 IP 주소도 함께 바뀌어야 한다

==== Private/Public IP 네트워크 주소

* Private 네트워크에서는 각 기관이 모든 장비의 주소 할당 제어
* Public 네트워크에서는 유일성 보장을 위한 방법 필요 - 공인 IP 등록/관리 기관
** 사설 주소가 사용하는 네트워크가 공중 TCP/IP 네트워크에 접속할 수 있는 NAT 도 있다

==== IP 주소 설정과 주소지정 유형

* 정적: 고정 IP
* 동적: 소프트웨어가 IP 주소 할당과 변경 제어 (BOOTP, DHCP)
* 주소지정 방법은 uni/multi/broadcast 를 모두 지원한다

=== IP 주소 크기, 주소 공간, 표기법

* 32비트 이진수 -> 8비트 옥텟으로 나누어 보통 10진수로 표현
* IP 주소의 구조와 할당 방법 때문에 32승 전부를 사용할 수는 없다
** IP 가 비교적 작은 인터네트워크용으로 개발되어서 낭비가 심하다 (ex. 127 은 loopback 주소로 예약되어 있다)
* Public 네트워크에서는 모든 장비가 사용 가능한 주소 공간을 공유해야 한다
** CIDR (Classless Inter-Domain Networking), Supernetting, NAT 와 같은 것들은 효율적으로 사용하기 위해 설계됐다

=== IP 기본 주소 구조와 주요 구성 요소

==== 네트워크 ID 와 호스트 ID

* 네트워크 ID: 특정 수의 prefix 비트는 호스트나 기타 네트워크 인터페이스가 위치한 네트워크를 식별하는 데 쓰임
** 라우터가 IP 데이터그램을 라우팅하는 데 쓰임 - 목적지 IP 주소가 출발지 IP 주소와 동일 네트워크에 있는가?
* 호스트 ID: 네트워크의 호스트를 식별하는 데 쓰임

==== 네트워크 ID 와 호스트 ID 구분 위치

* 지점이 고정되어 있지 않음 -> 바로 뒤에 주소지정 범주에서 확인
* 자체적으로 특수한 의미를 갖기도 한다
** ex. 호스트 ID 부분이 모두 1로 설정된 네트워크 ID: 그 네트워크로의 브로드캐스트 주소
** ex. 네트워크 ID 부분이 모두 0으로 설정된 호스트 ID: 로컬 네트워크에서의 그 호스트 ID 를 지정하는 IP 주소

=== IP 주소지정 범주와 IP 주소 부속물

==== 전통적 (클래스 단위) 주소지정

* 옥텟 단위로 구분, classless 와 구분하기 위해 classful 주소지정 방법
* 구분 지점을 각 주소의 처음 몇 비트에 인코딩. 라우터는 이 비트로 파악

==== 서브넷을 이용하는 클래스 단위 주소 지정

* 네트워크, 호스트가 아닌 3단계로 분리
** 호스트 ID 의 일부 비트를 서브넷 식별자로 이용 (네트워크 ID 는 변하지 않음)
* ex. 네트워크 ID 24비트, 호스트 ID 8비트인 경우
** 호스트 ID 8비트 = 서브넷 ID 3비트 + 호스트 ID 5비트
** 서브넷 마스크 (subnet mask): 서브넷 ID 와 서브호스트 ID 를 구분하는 점 
*** 여기서는 27비트 = 255.255.255.224

==== 클래스 비사용 주소지정

* 옥텟 단위가 아닌 임의의 지점
* 구분점은 네트워크 ID 에 쓰이는 비트의 수
** ex. 227.82.157.177 이 처음 27비트를 네트워크 ID 로 사용하는 네트워크에 속하는 IP 라면?
*** 227.82.157.160 으로 표현

==== 서브넷 마스크와 기본 게이트웨이

* / 표기는 IP 주소의 부속물
* 그 외에 기본 게이트웨이 식별자도 많이 쓰임 - 특정 장비에 대한 기본 라우팅 기능을 제공하는 라우터 IP 주소
** 원격 장비에 데이터그램을 보내고 싶을 때 기본 게이트웨이에 전송

=== IP 주소의 수와 멀티호밍

호스트가 하나 이상의 IP 주소를 갖는 것, 2가지 방법이 가능

* 2개 이상의 인터페이스를 동일한 네트워크에 연결
* 2개 이상의 서로 다른 네트워크에 인터페이스를 연결

=== IP 주소 관리와 할당 방법과 기관

* 중앙 기관에서 주소를 기관이 필요로 하는 장비 수 만큼 블록 단위로 할당
* IANA (ICANN) -> 대륙별 할당 (RIR) -> 국가 (NIR), 로컬 (LIR)

== 17장. 클래스 단위 (전통적) 주소 지정

=== IP 주소 클래스

* 기관별 규모를 3가지로 분류, 총 5개의 클래스
** A ~ E
** A, B, C 가 7/8 을 차지. 유니캐스트 IP 주소지정
* 장점
** 단순성과 명확성
** 타당한 유연성: 당시 예상 발전 속도에 맞는 요구 충족
** 라우팅 용이성
** 예약 주소

=== IP 클래스 단위 주소지정의 네트워크/호스트 식별과 주소 용역

* 클래스에 관한 정보가 IP 주소에 직접 인코딩 되어 있음
** 주소 몇 비트만 보고 그 주소가 어떤 클래스에 속해 있는지 파악할 수 있음

==== 클래스 결정 알고리즘

* IP 주소의 처음 몇 비트만을 보고 라우터가 네트워크/호스트 ID 파악, 데이터그램을 어떻게 처리할 지 쉽게 파악할 수 있음
** 4개의 비트만 보고 판단 가능
** p260 표

=== 특수 의미를 갖는 IP 주소

* 일부 IP 주소는 하나 이상의 장비를 간접적으로 가리키는데 쓰인다
** 모두 0 or 모두 1
* 네트워크 ID / 호스트 ID 에서
** - / 모두 0: 전체 네트워크
** 모두 0 / -: 이 네트워크에서 지정된 호스트 (현재 or 기본 네트워크의 호스트)
** 모두 0 / 모두 0: 자신의 IP 주소를 모르는 장비가 자신을 가리킴
** - / 모두 1: 지정된 네트워크의 모든 호스트
** 모두 1 / 모두 1: 전역 브로드캐스트

=== IP 예약, 사설, 루프백 주소

* 일반 주소 할당에 쓰일 수 없는 IP 주소들
* p267 표에 정리
** 각 클래스별로 사설 주소 블록이 있다 (10, 127, 192.168)

==== 예약 주소

* 향후 테스트나 인터넷을 관리하기 위한 내부 용도 예약
** 주요 클래스 (A, B, C) 각각의 첫/끝 부분에 나타난다

==== 사설, 비등록, 라우팅 불가 주소

* 비등록 (unregistered) 주소: 사설 주소에만 사용할 수 있는, 라우팅이 불가능한 특수 주소 집합을 정의
* 사설 주소를 사용하는 네트워크를 Public 인터넷에 연결하려면 추가 장비, NAT 등을 도입해야 한다

==== 루프백 주소

* 127.0.0.0 ~ 127.255.255.255
* 여기로 보낸 IP 데이터그램은 데이터 링크 계층으로 가지 않고 IP 계층으로 되돌아온다
* 3계층 IP 구현은 자신이 전송한 데이터를 즉시 받는다
* TCP/IP 프로토콜 구현을 테스트하는 데 쓰인다

=== 클래스 단위 IP 주소지정의 문제점

* 내부 주소 유연성 부족: 대형 기관은 커다란 단일 블록 할당 -> 네트워크 구조를 적절히 반영할 수 없음
** 주소의 내부 계층 구조를 만들 방법이 없음
* 주소공간의 비효율적 사용: A, B, C 만 존재 -> 낭비
** 세밀성이 대형 인터네트워크에서 사용하기에는 너무 낮다 = 네트워크 크기를 선택할 수 있는 옵션이 매우 적다
* 라우터 테이블 항목이 너무 커짐: 라우터에 항목이 많이 추가되어 성능 문제
* 위 문제들은 서브네팅, 클래스 비사용 주소지정, 라우팅으로 해결

== 18장. IP 서브넷 주소지정 개념

=== IP 서브넷 주소지정 개요, 동기, 장점

* IP 해석 과정에 하나의 단계를 추가 -> 네트워크가 서브넷과 호스트를 포함하도록 만듦
** 네트워크, 서브넷, 서브넷 호스트의 3단계 계층 구조
** 인터넷 내에서 고유한 인터네트워크를 구축할 수 있도록 함
* 장점
** 물리 네트워크 구조에 더 잘 맞는다
** 유연성
** Public 인터넷에서는 (내부 구분이) 보이지 않는다
** 새로운 IP 주소를 요청할 필요가 없음
** 라우팅 테이블 항목을 많이 넣을 필요가 없음
* 서브넷 마스크: 서브넷 ID 의 크기를 나타내는, IP 주소를 보완하는 부가 정보
** 서브넷 환경에서 라우터는 목적지 서브넷 ID 까지 보고 동일 서브넷 or not or 다른 네트워크 판단

=== IP 서브네팅: 3단계 계층적 IP 서브넷 주소 지정

* 기존 호스트 ID -> 서브넷 ID + 호스트 ID
** 서브넷 ID 비트: 네트워크 내에서 각 서브넷을 식별하는데 쓰인다
* 더 많은 비트를 서브넷 ID 에 할당할수록 서브넷의 크기는 늘어나지만, 각 서브넷이 포함할 수 있는 호스트 수는 줄어든다
* 서브넷의 수는 전체 네트워크의 물리 하위 네트워크 수에 근거하여 결정
** 서브네트워크별 호스트 수는 각 서브넷 별로 허용되는 최대 호스트 수를 넘지 않아야 한다

=== IP 서브넷 마스크, 표기법, 서브넷 계산

* 서브네팅을 사용하는 경우 호스트 ID 가 어떻게 분리됐는지 알아야 한다 (IP 주소만으로는 알 수 없다)
** 서브넷 마스크: 어떤 비트가 서브넷 ID 이고 어떤 비트가 호스트 ID 인지 알려주는 부가 정보

==== 서브넷 마스크 기능

* 네트워크 ID or 서브넷 ID 비트는 1, 호스트 ID 에 속하는 비트는 0
* IP 주소와 AND 연산을 수행 -> 네트워크 ID & 서브넷 ID 는 그대로 있고 호스트 ID 비트만 0 으로
** (네트워크 ID 는 앞의 라우터에서 필터링 되어서 들어올테니, 내부 라우터에서 서브넷 ID 를 구할 때 이렇게 계산이 가능할 듯)

==== 서브넷 마스크 예제

* 클래스 B 네트워크 154.71.0.0 -> 5개 서브넷 ID + 11비트 호스트 ID 로 분리
** 서브넷 마스크: 255.255.248.0
* IP: 154.71.150.42 와 AND 연산
** 서브넷 주소: 154.71.144.0 -> 서브넷 ID: 10010 = 18

==== 서브넷 마스크 표기법 원리

* 효율성 고려: 32비트 2진수 사용
* 비연속 마스크 지원: RFC 950 에서는 가능하지만, 실제로는 주소 할당이 복잡해져서 쓰이지 않음
* 근래의 표기법
** IP 주소 154.71.150.42, 서브넷 마스크 255.255.248.0 = 154.71.150.42/21

=== 주소 클래스 A, B, C 의 IP 기본 서브넷 마스크

* 서브넷 비트가 존재하지 않는, 호스트 ID 가 전부 0 인 주소
* A: 255.0.0.0
* B: 255.255.0.0
** 이건 클래스 A 의 커스텀 서브넷 마스크일 수도 있음
* C: 255.255.255.0
** 이건 클래스 A, B 의 커스텀 서브넷 마스크일 수도 있음

=== IP 커스텀 서브넷 마스크

* 서브넷 ID 와 호스트 ID 를 구분하는 지점을 네트워크에 맞게 선택

==== 얼마나 많은 서브넷 비트를 사용할지 결정

* 사용해야 할 서브넷의 수, 각 서브넷 별로 사용 가능한 최대 호스트의 수에 따름
* p284 의 예시

==== 커스텀 서브넷 마스크 결정

* 네트워크 클래스에 맞는 기본 서브넷 마스크에서 시작한다

==== 서브넷별 호스트 수와 네트워크 서브넷 수에서 2를 뺌

* 모두 0으로 된 호스트 ID (이 네트워크), 모두 1로 된 호스트 ID (브로드캐스트)
* 서브네팅에도 그대로 적용되기 때문에 제외
** RFC 950 에서는 서브넷으로의 사용을 금지했으나, RFC 1812 (1995년) 에서는 제한 해제
** 만약 RFC 950 을 따른다면 서브넷 ID 비트로 1개는 의미가 없다

=== IP 서브넷 식별자, 서브넷 주소, 호스트 주소

==== 서브넷 식별자

* 네트워크의 서브넷 별로 할당된 서브넷 ID 를 파악해야 한다
* 5개 비트인 경우 0 ~ 31 번까지

==== 서브넷 주소

* 앞서 본 154.71.88.0 과 같이 네트워크 ID + 서브넷 ID 비트가 1로 채워진 주소

==== 호스트 주소

* 나머지 호스트 ID 비트에 값을 채워 IP 주소 할당

=== IP 가변 길이 네트워킹

* 서브넷으로 나누었지만, 특정 서브넷에서는 나눈 호스트 수보다 많은 호스트 ID 가 필요한 경우?

==== 가변 길이 서브넷 마스킹 (Variable Length Subnet Masking (VLSM))

* 네트워크를 서브넷으로 나눈 뒤, 그 서브넷을 다시 서브넷으로 나누기
* 일부 서브넷에만 적용해서 그 서브넷이 다른 서브넷보다 크도록 IP 주소를 분할할 수도 있음

==== VLSM 을 이용한 다중 단계 서브네팅

* 일반 서브네팅과 동일한 방법으로 수행, 추가적인 서브네팅 단계를 거침
* 클래스 비사용 주소지정 슬래시 표기법이 널리 쓰인다
* ex) 201.45.222.0/24 를 세 번 서브네팅
.. 1차 분할: /24 2개로 분할 (201.45.222.0/25, 201.45.222.128/25)
.. 2차 분할: 201.45.222.128/25 2개로 분할 (201.45.222.128/26, 201.45.222.192/26)
.. 3차 분할: 201.45.222.192/26 4개로 분할 (201.45.222.192/28, 201.45.222.208/28, 201.45.222.224/28, 201.45.222.240/28)
* VLSM 은 사설 기관의 단일 네트워크를 다루고, CIDR 은 네트워크 주소 할당 방법을 변경하고, 단일 클래스 계층 구조를 다중 계층 구조로 대체하여 VLSM 개념을 인터넷 전체로 확장

== 20장. IP 클래스 비사용 주소지정 - 클래스 비사용 도메인간 라우팅/슈퍼네팅

=== IP 클래스 비사용 주소지정과 슈퍼네팅 개요

==== 클래스 단위 주소지정의 주요 문제점

* 세밀성이 떨어진다
* 큰 클래스 B 1개 -> 작은 클래스 C 여러 개: 라우팅 테이블이 엄청나게 커짐

==== 해결책: 주소 클래스 제거

* 비효율적인 주소 공간과 라우팅 테이블의 급격한 증가 해결
* 클래스 비사용 도메인간 라우팅 (CIDR, Classless Inter-Domain Routing)
* 단일 네트워크 서브네팅의 개념을 전체 인터넷으로 확장
* 특정 네트워크를 서브넷으로 분해하는 대신 네트워크를 병합하여 더 큰 슈퍼넷을 만드는 것

==== 클래스 비사용 주소지정과 라우팅의 주요 장점

* 효율적인 주소 공간 할당: 구분성이 낮은 고정 크기 블록으로 주소 할당 대신 임의의 2의 지수 승 크기로 할당 가능
* 클래스 불균형 제거: A, B, C 구분이 없음
* 효율적인 라우팅 항목 관리: 여러 네트워크 설명을 병합하여 하나의 항목으로 표현할 수 있음
* 별도 서브네팅 방법이 필요 없음

=== IP 슈퍼네팅: CIDR 계층적 주소지정과 표기법

* CIDR 에서 인터넷은 다수의 대형 블록으로 분할된 하나의 거대한 네트워크에 불과
* CIDR 은 모든 인터넷 블록을 임의의 크기로 간주

==== CIDR 표기법

* CIDR 에서도 호스트 ID 와 네트워크 ID 를 구분하기 위해 서브넷 마스크를 사용, 슬래시 표기법
* ex) 184.13.152.0/22 - 네트워크 ID 로 22비트, 호스트 ID 로 10비트 사용
* CIDR 에서는 서브넷 ID 비트가 연속적이어야 한다는 요구가 명문화

==== 클래스 단위 주소지정과 비사용 주소지정의 공통점

CIDR에까지 남아있는 특성

* 사설 주소 블록
* 특수 의미를 갖는 주소: 0, 1
* 루프백 주소: 127.0.0.0/8

== 21장. 인터넷 프로토콜 데이터그램 캡슐화와 포매팅

=== IP 데이터그램 캡슐화

* 상위 계층에서 넘어온 메시지를 IP 메시지 포맷으로 캡슐화
* 하위 네트워크로 전달하기에 너무 큰 메시지는 분해, 수신 장비에서 재조합
* IP 헤더에 포함된 필드: 데이터그램 전달을 관리하는 데 쓰임
** 목적지 장비의 주소, 프레임 유형, 제어 비트 등

=== IP 데이터그램 일반 포맷

[cols="1,4"]
|===
|필드 이름 |설명

|버전 | IP 버전

|IHL |IP 헤더 길이

|TOS |서비스 품질 기능을 제공하기 위한 정보 전달 필드

|TL |IP 데이터그램의 전체 길이

|식별자 |특정 메시지에 속한 각 단편과 연관된 16비트, 수신자가 이 정보로 재조합

|플래그 |3개의 제어 플래그. 2개는 단편화 필드, 1개는 예약

|단편화 오프셋 |메시지 단편화가 일어날 때 전체 메시지 안에서 이 데이터의 위치 or 오프셋을 나타냄

|TTL |네트워크에서 얼마나 오래 살아남을 수 있는지

|프로토콜 |상위 계층 프로토콜

|헤더 체크섬 |전송 중 오류를 방지하기 위해 헤더에 대한 체크섬 계산

|출발지 주소 |32비트 IP주소

|목적지 주소 |32비트 IP주소

|옵션 |표준 헤더 위에 올 수 있는 하나 이상의 옵션

|패딩 |헤더 비트 수를 32 배수로 맞춰주기 위함

|데이터

|===

==== IP 데이터그램 TTL 필드

* 데이터그램이 무한히 인터넷을 방황하지 않도록 하기 위함 - 라우터 루프
* 데이터그램의 최대 홉 수를 나타냄
** 처리할 때마다 1만큼 감소
** 메시지의 최초 송신자에게 ICMP 시간 초과 메시지 전송

==== IP 데이터그램 서비스 유형 필드 (Type Of Service)

* 처음 6비트를 차등화 서비스 (Differentiated Service) 기술 지원

=== IP 데이터그램 옵션과 옵션 포맷

* 데이터그램을 유연하기 처리할 수 있도록 하기 위한 옵션
* 하위 필드 포맷 - 옵션 유형, 길이, 데이터

[cols="1,4"]
.IPv4 옵션: 옵션 유형 하위 필드
|===
|필드 이름 |설명

|복사 플래그 |데이터그램 단편화 시 옵션을 모든 단편에 복사 여부

|옵션 클래스 |옵션이 속한 일반 범주를 명시하는 4개 중 하나 지정 +
(0 - 제어 옵션, 2 - 디버깅과 측정)

|옵션 번호 |옵션의 종류 지정

|===

* 옵션 종류는 p338
* 소스 라우팅: 최초 송신 장비가 데이터그램이 지나가야 할 네트워크 경로 지정
** stric, loose