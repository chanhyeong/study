# 2. 프로덕션 환경에서 클라우드 네이티브 애플리케이션 실행

대부분 프로덕션 환경 배포 프로세스는 어려움  
위험을 줄이고 효율성을 높이기 위해 느리고 번거로움

배포 후 유지도 어려움

**소프트웨어 배포 + 실행 및 유지** 가 어렵다

## 장애물들
### Snowflakes (= 눈송이)
"제 컴에서는 되는데요"
- Sofeware Development Life Cycle (SDLC) 전반에 걸친 다양성
    - 배포 후 안정성과 최초 배포 시 장애 둘 다 영향
    - 배포되는 artifact 와 배포되는 환경의 (OS 등) 불일치
- 환경별로 `application.properties` 내부 값이 다른 경우도 불일치로 봄

### 위험한 배포
배포 과정에서 downtime 이 필요하거나 예기치 않게 발생 -> 매출 손실 가능성

릴리즈가 길면 batch 크기도 더 커짐 - 다른 부분과 연관되어 예기치 않은 결과를 초래할 가능성

### 변화는 예외다 (Change is the exception)
(무슨 소리를 하는지 모르겠다)

초기 배포에 개발자를 참여시켜야 함
- 불확실성이 존재
- 구현을 깊이 이해하는 팀을 참여시키는 것이 필수
- 프로덕션 -> 운영으로 넘겨지면 동작 상태를 유지하는 방법은 runbook 으로 제공
    - 발생 가능한 장애와 해결 방안에 대한 기술
    - = 장애 시나리오가 알려져있다는 가정

### 프로덕션 설치성 (Production instability)
안정적인 프로덕션 환경 -> 새로운 배포의 전제 조건

## 조력자 (Enablers)
![image](https://drek4537l1klr.cloudfront.net/cdavis/Figures/02fig04_alt.jpg)

- Repeatability: 빠름, 안정성
- Safe deployments: 민첩성, 안정성
- 변경없는 환경에 의존하는 방식과 소프트웨어 설계를 지속적인 변경이 예상되는 환경으로 대체하면, 장애 해결에 소요되는 시간을 획기적으로 단축한다.

### Continous Delivery (CD)
amazon 은 평균 1초마다 amazon.com 프로덕션으로 코드 릴리즈

**CD 는 Continous 하지 않다**  
= 모든 코드 변경이 프로덕션에 배포되는 것은 아니다
= 새로은 소프트웨어 버전을 언제든지 배포할 수 있다

- CD 모델 (enabler)
![image](https://drek4537l1klr.cloudfront.net/cdavis/Figures/02fig05_alt.jpg)
- 이전 모델 (blocker)
![image](https://drek4537l1klr.cloudfront.net/cdavis/Figures/02fig06_alt.jpg)

선 출시는 제품의 후속 버전을 위한 사용자 피드백을 수집할 수 있음

소프트웨어를 만드는데 걸리는 시간 예측은 자주 실패함
- 구현 문제 - 네트워크 지연시간, 복잡한 비동기 통신 프로토콜 등

짧은 이터레이션으로 빈번한 릴리즈, 소프트웨어 안정성을 가지자

(이게 fe 에서 가능한건가)  
(근데 결국은 ready to ship 에서 배포가 아니라 릴리즈 단계가 별도로 있는데 의미가 있나)  
(기능이 추가되면서 테스트 길이가 길어질 수 있고, 이전 기능에 영향이 갈 수 있는데 그거에 대한건?)  
(기획에서 한 번에 빵 오픈하는걸 원할텐데 이게 어떻게 되는건지)

### Repeatability

#### 소프트웨어를 배포할 환경 제어
1. 표준화된 머신 이미지로 시작
2. 기본 이미지에 적용되는 변경 사항을 코드화
    - Infrastructre as code (ex. Ubuntu + JDK)

초기 배포 후 통제를 보장하기 위한 기법 예시
- 실행 중인 환경에 대한 SSH 접근을 허용하지 않거나, SSH 접근하는 즉시 머신을 오프라인 상태로
    - 이런 경우가 있으려나..
    - 실행 환경에 잠재적 변경도 허용하지 않는 점에서 유용

#### 배포 가능한 아티팩트 제어
환경별로 다른 문자열을 매개변수화하여 프로퍼티에 추가  
-> 컴파일될 때 테스트/프로덕션의 각 JAR 파일은 다름

<ins>**효율적이고 안전 + 반복 가능한 프로덕션 운영을 위해서는, 전체 SDLC 에서 배포 가능한 아티팩트를 하나만 사용해야 한다**</ins>

- 프로퍼티 파일을 통해 환경 특화된 (environment-specific) 값을 전달하지 말고, 나중에 값을 주입할 수 있는 매개변수 세트를 정의
- 적절한 시점에 값을 가져와 매개변수에 바인딩

#### 배포 프로세스 제어
일관성 있는 환경 + 배포 가능한 아티팩트 제어의 원칙을 세우고 관리한다면  
이러한 부분이 통제되고 반복 가능한 방식으로 결합하는 것

어떤 것이 좋은 기본 이미지? + 환경 설정의 소스는 무엇? + 언제 애플리케이션 컨텍스트로 가져올지? + 언제 앱이 런타임 컨텍스트에 설치된 것인지?

일관성을 보장하는 유일한 방법은 자동화
- Pivotal cloud foundry - stem cell
    - 파이프라인으로 런타임 환경 + 애플리케이션 아티팩트의 조립
    - 다른 파이프라인은 프로덕션에 최종 배포
- 배포까지 자동화했을 때 이런 배포가 안전한지는 어떻게 확인? (바로 아래 주제)

### 안전한 배포
- 이전의 일반적인 방식
    - 느린 프로세스와 비용이 많이드는 테스트 환경을 구축
    - 모든 문제를 해결했다고 생각했지만, 잘못된게 발견되면 혼란
- 클라우드 시대에서는 **프로덕션 환경에서 실험을 하는 길이 제시됨**  
    - 프로덕션에서 실험을 할 때는 운영 방식과 소프트웨어 디자인 패턴을 엮음  
    - TDD 와 같은 방식으로 실패 가능성을 최소화
    - 실패를 계획하여 실패를 별거 아닌 일로 하기 위한 후퇴 경로를 의도적으로 만듦

상위 ```위험한 배포``` 절에서의 복잡하고 시간이 많이 드는 테스트 프로세스를 제거하고  
기본 통합 테스트 후 바로 프로덕션에 들어간다면, 시간 단축 + 더 많이 릴리즈 가능

적절한 안전망을 갖추면 재난을 피하고 몇 초 만에 완전한 기능을 갖춘 시스템으로 빨리 돌아갈 수 있음  
배포가 사전 절차 없이 더 자주 수행되는 경우 프로덕션에서의 실행 오류를 더 잘 해결할 수 있고 시스템을 좀 더 안정적으로 유지

#### 안전망이란?
3가지 패턴
1. 병렬 배포와 버전 서비스
    - 병렬 배포 - 새 버전을 추가할 때 기존의 작업 버전을 유지
        - (사내 kubernetes 배포 방식과 동일함, 93p 그림)
    - artifact 는 버전화되어야 하고, 버전은 라우팅 메커니즘에 의해 트래픽 제어가 가능해야 함
    - 더 작은 배포 단위를 만들어야 함
2. 필요한 telemetry (원격 측정) 생성
    - 모든 데이터는 비교를 위해 소프트웨어와 연결되어야 함
3. 유연한 라우팅
    - 라우팅은 핵심 요소이고, 라우팅 알고리즘은 소프트웨어의 일부
    - 로직의 구현은 다양할 수 있음 (애플리케이션 내/외로)

**버전화, 메트릭, 라우팅, 컴포넌트**화는 Cloud-native 애플리케이션을 설계, 구축 시 고려해야 함

### 변화는 비일비재 하다
변화가 있을 때 적응할 수 있는 능력을 만들면 더 큰 복원력을 제공함

**완료했다** 는 생각을 버려야 한다 - 이 생각은 본질적으로 변화하기 힘들게 함

Eventual Consistency System 은 시스템을 완료된 상태로 만들기 위해 명령 세트를 만들지도 않고, 완료되기를 기대하지도 않는다  
-> 대신 평형을 이루기 위해 끊임없이 노력

self-healing system 이 끊임없는 변화에 적응할 수 있도록 소프트웨어를 설계하고 구축하는 것을 보는 것이 이 책의 목적