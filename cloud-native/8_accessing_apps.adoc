= 8. 앱에 접근하기: 서비스, 라우팅, 서비스 탐색

== Service abstraction

* service discovery: 클라이언트가 해당 서비스를 찾는 방법
* (특정 순간에 구현을 정확히 대표하기 위해서는) 라우팅할 인스턴스 목록을 최신 상태로 유지해야 한다

DNS 를 통한 구글의 방식, IP + 쿠버네티스 레이블을 통한 방식

== Dynamic routing

=== Server-side load balancing

하드웨어/소프트웨어 기반 로드 밸런서: TCP/UDP, HTTP 수준에서 수행

* 성숙한 기술: 견고
* 중앙 집중식 구현: 동작 추론 쉬움
* 단일 설정: 쉬움

=== Client-side load balancing

라우팅 목록을 클라이언트 자체에 포함  +
네트워크 홉 제거에 효과적이기 떄문

* 라이브러리를 코드에 번들링하는 경우 앱 재빌드 필요
* 설정이 더 어려울 수 있음
* 로드 밸런싱 기능을 사용하는 세부 방법을 알아야 한다

인스턴스 목록이 최신 상태로 유지되는 패턴을 추가로 이해해야 한다

=== Route freshness

배포의 실제 상태를 지속적으로 평가하고 실제 라우팅 테이블에 반영하는 제어 루프

. 플랫폼이 시스템의 실제 상태에 대한 정확한 모델을 구축할 수 있도록 정보 제공
. 서비스가 구현된 인스턴스를 식별하는 방법 제공
** 쿠버네티스에서는 tag, selector 를 사용해 수행
*** 제어 루프가 라우팅 테이블을 업데이트

== Service Discovery

클라이언트가 서비스를 이름으로 참조할 수 있는 간단한 프로토콜

. 네이밍 서비스에 기입하는 방법이 있어야 한다
. 이름이 주어지면 주소를 가져오는 방법이 있어야 한다

네이밍 서비스는 일관성 < 가용성 -> 응답이 오래된 정보일 수도 있다 +
*클라이언트는 보상 활동을 구현할 책임이 있다*

IP 가 다른 앱으로 갱신되어 다른 정보를 줄 수 있으므로, 접근 제어 메커니즘을 구현해두어야 한다

=== 쿠버네티스에서 서비스 탐색

네이밍 서비스 & 네이밍 서비스에 진입점을 위치시키는 과정 & 이름에서 IP 주소를 얻기 위한 프로토콜

* CoreDNS 서비스: 쿠버네티스에서 DNS 를 구현
** 서비스 탐색 프로토콜을 설정하는 등록/찾기 작업을 수행하기 위해 CoreDNS 와 인터페이싱
* 서비스가 생성될 때 쿠버네티스가 자동으로 DNS 등록 수행