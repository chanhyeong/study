= 2. 실용주의 접근법

== Topic 8. 좋은 설계의 핵심 (The Essence of Good Design)

[NOTE]
====
Tip 14. 좋은 설계는 나쁜 설계보다 바꾸기 쉽다

* 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다
* 바꾸기 더 쉽게 (ETC, Easier To Change)
====

ETC 는 규칙이 아닌 가치

* '내가 방금 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까?'

어떤 길이 미래의 변경을 쉽게 만드는지 알기 어려울 때

* '바꾸기 쉽게' 라는 길을 선택 = 교체하기 쉽게
** 결합도를 낮추고 응집도를 높이기
* 직관을 발전시키는 기회로 삼으라
** 현재 상황과 선택, 변경 사항에 대한 추측을 정리

== Topic 9. DRY: 중복의 해악 (DRY—The Evils of Duplication)

프로그래머는 늘 유지 보수 모드에 있다 -> 애플리케이션에 표현되어 있는 지식을 찾아내고 바꿔야 한다 +
-> 지식을 중복해서 넣기 쉽다

[NOTE]
====
Tip 15. DRY (Don't Repeat Yourself)

* 같은 것이 두 군데 이상에 표현 = 하나를 바꾸면 나머지도 바꿔야
====

=== 코드 밖에서도

코드를 바꿔야 할 때 여러 곳을 바꿔야 하는가? 다른 형태 (문서, 스키마 등) 를?

=== 모든 코드 중복이 지식의 중복은 아니다

코드가 동일하지만 두 함수가 표현하는 지식은 다르다 +
서로 다른 것을 보지만, 규칙이 같은 것일 수도 (p47)

=== 문서화 중복

의도가 코드, 주석으로 두 번 표현

=== 데이터의 DRY 위반

p49 -> 지식을 표현하면서 DRY 위반

중복이 필요하면 중복의 영향을 적게 - 바깥 세상에는 DRY 원칙 위배를 노출하지 않기

자료 구조를 노출하면 구현과 사용하는 코드 사이의 결합이 생긴다 - accesor 를 위용하라

=== 표현상의 중복

* 내부: 언어/기술 중립적인 형식으로 내부 API 를 정의할 수 있는 도구를 찾아보기
* 외부: API 명세를 API 도구로 불러와서 사용 -> 신뢰성 있게 연동할 수 있다
* 데이터 저장소: 스키마 분석 기능, 영속성 프레임워크 - 데이터 저장소와 코드 간 중복 줄이기
* 개발자 간: 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다
** 공통의 문제를 다루기 위한 공간을 만들기
** 프로젝트 사서 두기: 지식 교환을 돕기
** 코드 리뷰를 통해 다른 사람의 소스 코드와 문서를 읽기 -> 배우고 기억

[NOTE]
====
Tip 16. 재사용하기 쉽게 만들어라.

* 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성해야 한다.
====

== Topic 10. 직교성 (Orthogonality)

설계, 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 중요한 개념

독립성, 결합도 줄이기 등 -> 서로 직교한다 = 하나가 바뀌어도 나머지에 영향을 주지 않는다

=== 장점

[NOTE]
====
Tip 17. 관련 없는 것들 간에 서로 영향이 없도록 하라.

* 단일하고 잘 정의된 목적을 가진 독립적인 컴포넌트
====

* 생산성 향상
** 변화를 국소화하여 개발 시간과 테스트 시간이 줄어든다
** 재사용 촉진
** 직교적인 컴포넌트간 결합 시 할 수 있는 일이 더 많아진다
* 리스크 감소
** 감염된 코드의 격리
** 잘 깨지지 않는 시스템
** 테스트 설계 & 실행이 쉬움 -> 테스트를 더 많이 하게 된다
** 특정 제품, 플랫폼에 덜 종속

=== 설계

컴포넌트를 나누었을 때 '특정 기능에 대한 요구 사항을 대폭 변경하는 경우, 몇 개의 모듈이 영향을 받는가?'

현실 세계의 변화와 설계 사이의 결합도 확인이 필요하다 - 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라.

=== 툴킷과 라이브러리

외부 것을 도입할 때 시스템의 직교성을 해치지 않는지 살펴봐야 한다

특정한 방식으로 무엇을 해야 한다 = 세부 사항 -> 코드로부터 분리가 필요하다

=== 코딩

애플리케이션의 큰 맥락을 살펴야 기능을 또 추가하거나, 동일한 지식 중복 표현을 막을 수 있다

* 코드의 결합도를 줄여라 - 가시성 제한 & 다른 모듈의 구현에 의존하지 않는 코드 작성
* 전역 데이터를 피하라
** 싱글턴을 전역 데이터로 사용하는 경우 주의 - 불필요한 결합을 만들 수 있다
* 유사한 함수를 피하라
** strategy 패턴을 사용하라

코드를 항상 비판적으로 바라보는 습관 - 코드의 구조와 직교성을 개선하기 위해 노력하라

=== 테스트

단위 테스트를 빌드, 실행하기 위해 나머지 시스템의 상당 부분을 불러와야 한다? = 결합도를 충분히 줄이지 못했다

문제가 발생했다면 버그 수정을 얼마나 국소화 할 수 있는지 평가

=== 문서화

내용과 표현

직교적인 문서라면 내용 변화 없이 모양새를 완전히 바꿀 수 있다

내용으르 쓸 때는 내용에만 집중하고, 예쁘게 꾸미는 것은 다른 변환 도구에 맡길 수 있다

== Topic 11. 가역성 (Reversibility)

특정 무언가에 종속된다면, 되돌리기 위해 큰 비용을 치러야 한다

되돌릴 수 없는 결정을 줄여야 하는 이유? +
= 프로젝트 초기에 늘 최선의 결정을 내리지는 못한다

[NOTE]
====
Tip 18. 최종 결정이란 없다.
Tip 19. 유행을 좇지 말라.
====

바꾸기 쉽게 만들어라.

== Topic 12. 예광탄 (Tracer Bullets)

첫 예광탄은 '프로젝트를 만들고, "hello world!" 를 추가한 다음, 컴파일 및 실행시키는 것' +
그 다음 불확실한 곳을 찾아 뼈대를 추가

예광탄 코드도 계속 사용할 코드 -> 오류 검사, 올바른 구조, 문서화, 자체 검사를 갖추어야 한다

장점

* 사용자가 작동하는 것을 일찍부터 보게 된다
* 개발자가 들어가서 일할 수 있는 구조를 얻는다
* 통합 작업을 수행할 기반이 생긴다
* 보여줄 것이 생긴다
* 진행 상황에 대해 더 정확하게 감을 잡을 수 있다

(잘못된 반영으로 버그 수정, 보정 등의 생각은 안하는건가)

=== 예광탄 vs 프로토타입

프로토타입은 대충 구현한거라 모두 버려야 한다 -> 얻은 교훈으로 코드를 새로 작성한다

예광탄은 애플리케이션이 전체적으로 어떻게 연결되는지를 보여준다 +
프레임워크가 생기고, 새로운 기능을 추가하게 된다

== Topic 13. 프로토타입과 포스트잇 (Prototypes and Post-it Notes)

포스트잇은 작업 흐름, 애플리케이션 로직과 같이 동적인 것을 프로토타이핑할 수 있는 훌륭한 도구다.

[NOTE]
====
Tip 21. 프로토타이핑으로 학습하라.

대상 - 위험을 수반하는 모든 것 +
해본 적이 없는, 증명되지 않은, 실험적인, 의심이 가는, 마음이 편하지 않은 것 등

프로토타이핑은 학습 경험이다, 코드가 아닌 배우는 것에 교훈 +
초기에 잠재적 문제 지점을 발견하고 고칠 수 있다
====

정확성, 완전성, 안정성, 스타일 등을 무시해도 된다

프로토타입이 버려지지 않을 것 같으면 예광탄 접근 방식이 더 나을 것이다

== Topic 14. 도메인 언어 (Domain Languages)

[NOTE]
====
Tip 22. 문제 도메인에 가깝게 프로그래밍하라.
====

* internal - host 언어로 원하는 내용을 쓰는 것 (RSpec, Pheonix)
* external - 자체 언어 사용 -> 자체 구조로 변환 후 사용/실행

도메인 언어를 만드려면 추가 비용이 발생하고, 이를 상쇄할 만큼 비용을 절감할 수 있으리라는 확신이 있어야 한다

== Topic 15. 추정 (Estimating)

[NOTE]
====
Tip 23. 추정으로 놀람을 피하라.
====

=== 얼마나 정확해야?

추정치를 물었을 때 답변이 사용될 상황이 무엇인지 생각해보기 +
정확도?, 큰 그림? 중 뭘 원하는건지 파악

p95 에서 기간 마다의 단위

=== 추정하는 법?

* 무엇을 묻고 있는지 이해
** 추정하기 전에 어떤 조건이 있을지 생각하는 습관
* 시스템의 모델 만들기
** 기본적인 것만 갖춘 개략적인 모델만 만들고, 추정
* 모델을 컴포넌트로 나누기
** 컴포넌트 상호 작용을 기술, 매개 변수 찾기
* 매개 변수에 값을 할당
* 답 계산
* 추정 실력을 기록

=== 프로젝트 일정 추정하기

==== PERT (Program Evaluation Review Technique)

낙관적 추정치, 가장 가능성이 높은 추정치, 비관적 추정치를 가지고 +
과업을 의존성에 따라 네트워크로 배열 +
전체 프로젝트의 예상 최소 및 최대 소요 시간 계산

==== 직접 경험해보기

점증적 개발 (incremental development)

* 요구 사항 확인
* 위험도가 높은 부분을 우선 하기
* 설계, 구현, 통합
* 사용자와 함께 검증하기

[NOTE]
====
Tip 24. 코드와 함께 일정도 반복하며 조정하라.
====

일단 iteration 을 수행하고 다듬으면, 일정에 대한 확신이 커질 것이다