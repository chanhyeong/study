= 4. 부호화와 발전

* 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있음
* 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있음

상위 호환성이 어렵다

데이터 부호화를 위한 다양한 형식을 볼 예정 = 어떻게 스키마를 변경하고 전/후 공존하는 시스템을 지원하는지

JSON, XML, Protocol Buffers, Thirft, Avro +
REST, RPC, MQ

== 데이터 부호화 형식 (Formats for Encoding Data)

메모리에 object, struct, list, array, hash table, tree 등으로 데이터가 유지

데이터를 다른 곳으로 이동시키려면 byte array 의 형태로 부호화해야 한다 +
byte array 는 메모리에서 사용하는 데이터 구조와는 다르다

메모리 <-> byte array 간 전환이 필요하다

* encoding (serialization or marshalling): inmemory -> byte arry
* decoding (parsing, deserialization, unmarshalling): byte arry -> inmemory

=== 언어별 형식

프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원 +
편리하지만 심각한 문제점도 많다

* 언어에 종속되어 다른 언어에서 읽기 어려움
* 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다
** 보안 문제의 원인 - 공격자가 애플리케이션을 얻는 경우 임의의 클래스를 인스턴스화 할 수 있음, 원격으로 임의 코드 실행
* 버전 관리 - 상위/하위 호환성 처리가 미뤄지게 된다
* 효울성 처리도 미뤄짐 (Java 의 내장 직려화를 성능이 좋지 않고 비대해지는 부호화)

=== JSON, XML, Binary variants

* 수 (number) 의 부호화가 애매하다
** XML, CSV 는 number, digit 으로 구성된 문자열을 구분할 수 없다
** JSON 은 문자열과 수를 구분, 정수와 부동소수점 수 구별 X, 정밀도를 지정하지 않음
* JSON, XML 은 유니코드 문자을을 잘 지원하지만, 이진 문자열을 지원하지 않는다
** 이진 데이터를 Base64 를 사용하여 텍스트로 부호화해서 해결 - 데이터 크기 33% 증가
* XML, JSON 모두 스키마 지원 - 익히고 구현하기 난해
* CSV 는 스키마가 없어 의미를 정의하는걸 애플리케이션이 해야 한다.

결점이 있지만 다양한 용도에 사용하기에 충분하므로 앞으로도 인기 있을 것

==== 이진 부호화

큰 데이터셋을 위한 공간 효율을 위해 JSON, XML 용 이진 부호화 개발이 이어짐 +
(BSON, WBXML, ...)

일부는 데이터타입 셋을 확장하지만, JSON/XML 데이터 모델은 유지 +
스키마를 지원하지 않아 부호화된 데이터 안에 모든 객체 필드 이름을 포함해야 함

p119 그림 4-1 은 예제 4-1 을 MessagePack 으로 이진 부호화한 예시

=== Thrift, Protocol Buffers (protobuf)

부호화할 데이터를 위한 스키마가 필요

[code]
----
// thrift
struct Person {
    1: required string          userName,
    2: optional i64             favoriteNumber,
    3: optional list<string>    interests
}

// protobuf
message Person {
    required string user_name       = 1;
    optional int64 favorite_number  = 2;
    repeated string interests       = 3;
}
----

애플리케이션 코드는 생성된 코드를 호출해 스키마르 레코드를 부호화/복호화 할 수 있음

thrift 부호화된 데이터 형식이 2개, BinaryProtocol (그림 4-2), CompactProtocol (그림 4-3)

protobuf 는 CompactProtocol 과 비슷 (그림 4-4)

==== 필드 태그와 스키마 발전

schema evolution: 스키마가 시간이 지남에 따라 변함

부호화된 레코드는 부호화된 필드의 연결

각 필드를 태그 숫자로 식별, 데이터타입을 주석으로 +
스키마에서 필드 이름은 변경할 수 있음, 필드 태그는 변경할 수 없음 +
(부호화된 데이터에서 필드 이름 참조 안함, 필드 태그는 데이터 인식에 필요)

필드에 새로운 태그 변호를 부여하는 방식으로 새로운 필드 추가 (상위 호환성 - 예전 코드에서는 추가된거 무시) +
고유한 태그 번호가 있는 동안에는 계속 같은 의미를 가짐, 새로운 코드는 예전 데이터를 항상 읽을 수 있음 (하위 호환성)

하위 호환성을 유지하려면 추가되는 모든 필드는 required 가 아니라 optional 로 하거나 기본값을 가져야 한다 +
(예전 코드에서는 기록되지 않으므로 깨진다)

필드는 optional 필드만 삭제할 수 있고, 같은 태그 번호는 절대 다시 사용할 수 없다