= 9. 일관성과 합의

tolerant 시스템에 쓰이는 알고리즘과 프로토콜을 볼 예정

합의 - 모든 노드가 어떤 것에 동의하게 만드는 것

== 일관성 보장

최종적 일관성은 매우 약한 보장이다 - 언제 복제본이 수렴될지 모름

시스템이 선택적으로 제공할 수 있는 강한 일관성 모델들이 뒤에 나온다 +
성능이 나쁘거나 tolerance 가 약할 수도 있으나 올바르게 사용하기 쉽다

분산 일관성은 지연, 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관함

선형성 (linearizability), 이벤트 순서화 문제, 분산 트랜잭션을 원자적으로 커밋하는 방법 등

== 선형성

복제본이 하나만 있다는 환상을 만들어준다면? a.k.a. atomic / strong / immediate / external consistency +
복사본이 하나만 있고 해당 데이터를 수행하는 모든 연산을 원자적으로 보이게

읽힌 값이 최근에 갱신된 값이며, 오래된 캐시나 복제본에서 나온 값이 아님을 보장 - recency guarantee

그림 9-1 비선형성

=== 무엇이 선형성을 부여?

==== 그림 9-3

한 클라이언트가 바뀐 값을 반환하면, 이후 모든 읽기도 바뀐 값을 반환 (쓰기 연산이 완료되지 않았더라도)

==== 그림 9-4

연산이 실행됐다고 생각하는 시점이 수직선으로 표시, 모여서 순차열

연산 표시를 모은 선들이 항상 시간순으로 진행되어야 하고, 뒤로 가서는 안된다 -> 최신성 보장

* 실행 시점은 (네트워크 지연을 고려한) db 인입 시점
* 트랜잭션 격리를 가정하지 않음, 과거 값을 읽는 것을 허용하지 ㅇ낳음

.선형성 vs 직렬성
****

* 직렬성: 트랜잭션들의 격리 속성, 특정 순서에 따른 트랜잭션들의 순서 보장
* 선형성: R/W 에 대한 최신성 보장, 연산을 트랜잭션으로 묶지 않음

strict serializability, strong one-copy serializability: 직렬성과 선형성을 둘 다 제공

****

=== 선형성에 기대기

==== 잠금과 리더 선출

모든 노드가 lock 획득, 성공한 노드가 리더

zookeeper, etcd 등의 코디네이션 서비스 사용 - 합의 알고리즘 사용하여 선형성 연상을 tolerant 하게 +
curator - zookeeper 위에 고수준 레시피 제공

분산 잠금 예로는 Oracle RAC - 여러 노드가 동일한 디스크 저장 시스템 공유, 디스크 페이지마다 잠금

==== 제약 조건과 유일성 보장

==== 채널 간 타이밍 의존성

=== 선형성 시스템 구현

"데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적"

복제 방법에 따른 확인 (p331)

==== 선형성과 정족수

정족수가 만족되어도 최신 값을 보지 못하는 경우 (그림 9-6)

읽기 복구를 동기식으로 하면 해결되지만 느림

다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 안전하다

=== 선형성의 비용

다중 리더에서는 네트워크가 끊겨도 정상 동작할 수 있다 +
(근데 끊겨있는 동안은 비선형적일 수 있는거 아닌가? - 클라이언트가 데이터센터마다 붙어있어서 아니라고 보는 것 같기도)

단일 리더 복제에서 팔로워로 온 R/W 요청은 동기식으로 리더로 보내져야 한다 +
네트워크가 끊기면 리더로 연결할 수 없다 - 팔로워에서 읽을 때 비선형적일 수도

==== 선형성과 네트워크 지연

선형성을 제거한 이유는 성능

지연이 심한 네트워크에서 선형성 R/W 의 응답 시간은 높아진다

12장에서는 정확성을 희생하지 않고 선형성을 회피하는 방법 설명

== 순서화 보장

연산과 그 연산의 실행 순서를 결합하여 나타냄

=== 순서화와 인과성 (Casuality)

순서화가 인과성 보존에 도움

인과성은 이벤트에 순서 부과 +
시스템이 그 순서를 지키면 인과적으로 일관적 (casually consistent)

==== 인과적 순서가 전체 (total) 순서는 아니다

전체 순서, 부분 순서 (비교 불가)

* 선형성: 연산의 전체 순서를 정할 수 있음
* 인과성: 두 이벤트가 동시에 실행되면 비교할 수 없다. 부분 순서를 정의

인과적 일관성 그래프와 유사한 예) git version history

==== 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 내포. 선형적이라면 인과성도 올바르게 유지한다

선형성은 인과성을 보장하는 유일한 방법은 아니다 +
인과적 일관성은 더 효율적으로 구현될 수 있다 - 최종적 일관성 등으로 연구가 되고 있지만 아직 연구 진행 중

==== 인과적 의존성 담기

연산이 먼저 실행됐는지 알아야 한다 = 후속 연산은 선행 연산 처리를 기다려야 한다

버전 벡터, SSI 충돌 검출 등

=== 일련변호 순서화

일련번호, 타임스탬프로 이벤트의 순서 정의 - 전체 순서

인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다

단일 리더에서는 쉽다

==== 비인과적 일련번호 생성기

단일 리더가 없다면,

* 각 노드마다 독립적인 일련번호 집합 생성 (ex. 홀/짝)
* 물리적 시계에서 얻은 타임스탬프를 붙이기
** 해상도가 높다면 전체 순서를 정하는데도 사용할 수 있음. LWW 에서 사용
* 일련번호 블록을 미리 할당 (1~1000, 1001~2000)

일련번호가 인과성에 일관적이지 않다

==== 램포드 타임스탬프

인과성에 일련번호를 생성하는 간단한 방법

(counter, Node ID)

각 노드가 고유 식별자를 갖고, 처리한 연산 개수를 카운터로 유지 +
카운터가 큰게 타임스탬프가 크다. 카운터가 같으면 노드 id 가 큰게 타임스탬프가 크다

==== 타임스탬프 순서화로는 충분하지 않다

유일성 제약 조건 등을 구현하려면 전체 순서로는 충분하지 않다 +
언제 그 순서가 확정되는지 알아야 한다

=== 전체 순서 브로드캐스트

노드 사이에 메시지를 교환하는 포로토콜로 기술. 비공식적인 두 가지 안정성 속성을 만족해야 한다

* 신뢰성 있는 전달 (reliability delivery)
* 전체 순서가 정해진 전달 (totally ordered delivery)

노드나 네트워크 결함이 있더라도 항상 만족되도록 보장해야 한다

==== 사용하기

zookeeper, etcd 등에서 구현되어 있음 - 전체 순서 브로드캐스트와 합의는 간한 연관이 있다

모든 복제 서버가 연산을 같은 순서로 처리하면 일관성 있는 상태로 유지 - state machine replication

메시지가 전달되는 시점에 그 순서가 고정된다 - 앞으로 끼워 넣는걸 불허

==== 사용하여 선형성 저장소 구현하기

전체 순서 브로드캐스트는 비동기식 - 메시지 순서는 보장되나 언제 메시지가 전달될지는 보장되지 않음

전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산 구현

. 메시지를 로그에 추가, 점유하기 원하는 사용자명을 시험적으로 가리킴
. 로그를 읽고, 추가한 메시지가 되돌아오기를 기다림
. 사용자명을 점유하려고 하는 메시지가 있는지 확인
** 첫 번째 메시지가 다른 사용자가 보낸거라면 abort

?

==== 선형성 저장소를 사용하여 전체 순서 브로드캐스트 구현하기

모든 메시지에 선형성 정수 일련번호를 붙인다 +
수신자들은 일련번호 순서대로 메시지를 전달. 처리 순서를 알 수 있음