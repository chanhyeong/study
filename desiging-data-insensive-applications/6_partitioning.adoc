= 6. 파티셔닝

데이터셋이 매우 크거나 처리량이 높다면 쪼개기 - 파티셔닝, 샤딩

파티셔닝하는 방법, 인덱스와 파티셔닝이 어떻게 상호작용하는지 볼 예정 +
+ 리밸런싱, DB 가 어떻게 요청을 파티션에 전달하고 쿼리하는지

== 파티셔닝과 복제

복제 + 파티셔닝 - 개별 파티션의 복사본을 여러 노드에 저장 (그림 6-1)

== key-value 데이터 파티셔닝

파티셔닝이 고르게 이루어지지 않은 상태 - **skewed** +
부하가 높은 파티션 - **hotspot**

=== key 범위 기준 파티셔닝

연속된 범위의 키를 할당 +
키 범위 크기가 반드시 동일할 필요는 없다

파티션 경계 - 관리자가 수동 선택 or DB 에서 자동으로 선택

파티션 내에서는 키를 정렬된 순서로 저장할 수 있다 +
key 를 연속적인 인덱스로 간주하여 여러 개를 읽어오는 데 사용할 수 있다

특정한 접근 패턴이 hotspot 을 유발하는 단점 - 타임스팸프가 키인 경우 등 +
(예전에 배달업체 데이터가 많아서 리밸런싱 중에 오류가 났던..)

=== key 의 해시값 기준 파티셔닝

skew, hotspot 위험으로 대부분 해시 함수 사용

언어의 해시 함수는 다른 프로세스에서는 다른 해시값을 반환할 수 있어 적합하지 않다

적합한 해시 함수 선택 -> 파티션에 해시값 범위 할당 -> 해시값이 파티션의 범위에 속하는 키들을 할당

파티션 경계는 크기가 동일하게 or 무작위에 가깝게 (consistent hashing)

.Consistent Hashing
****
캐시 시스템에서 부하를 균등하게 분산시키는 방법 +
중앙 제어나 분산 합의가 필요하지 않도록 파티션 경계를 무작위로 선택 +
일관성 = 특별한 리밸런싱 방법

DB 에서는 잘 동작하지 않아 안 쓴다

(대기열에서 이거 구현해서 쓴거로 알고 있긴 함)
****

인접했던 키들이 흩어져서 정렬 순서가 유지되지 않음 +
MongoDB 해시 기반 샤딩 -> 범위 질의가 모든 파티션에 전송 +
PK 범위 질의가 지원되지 않는 DB 들도 많음

=== 쏠린 작업부하와 핫스팟 완화

항상 동일한 키를 읽고 쓰면, 모든 요청이 하나의 파티션으로 쏠린다

간단한 해결책 - 각 키의 시작이나 끝에 임의의 숫자 붙이기 +
10진수 2개만 붙여도 100개의 다른 키로 write 가 균등하게 분산 +
100개 키에 해당하는 데이터를 읽어서 조합해야 하는 단점

