= 5. 복제

네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지

* 지리적으로 사용자와 가깝게 데이터 유지 - 지연 시간 줄이기
* 가용성
* read 장비 확장 - 처리량 증가

이 장에서 볼 것들

* 세 가지 알고리즘: single-leader, multi-leader, leaderless
* 동기식 복제, 비동기식 복제
* 잘못된 복제본을 어떻게 처리할지
* eventual consitency
* read-your-write (쓰기 읽기), monotonic read (단조 읽기)

== Leader, Follower

replica - 복제 서버

. client: leader 에게 write 요청
. leader 가 데이터 변경을 replication log or change stream 의 형태로 follower 에게 전송
. follower: 리더가 처리한 것과 동일한 순서로 모든 write 를 적용

(복제 지연이 있을 수 있어서, write 직후 조회는 master 로 했던 경험도..)

=== 동기식, 비동기식 복제

동기식은 비현실적이다 - 임의 노드의 장애가 전체 시스템을 멈추게 함

반동기식 (semi-synchronous): leader + 하나의 동기식 follower +
보통은 완전히 비동기식으로 구성

=== 새로운 follower 설정

새로운 follower 가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할지?

중단 없이 follower 설정을 하는 순서

. leader DB 스냅샷을 일정 시점에 가져옴 (DB 백업 기능으로)
. 스냅샷을 새로운 follower 노드에 복사
. follower 가 스냅샷 이후 변경을 leader 에게 요청
. 따라잡음: 스냅샷 이후 backlog 처리했을 때
** 리더에 발생하는 데이터 변화를 이어 처리

=== 노드 중단 (Outage) 처리

==== follower 장애: 따라잡기 복구

결함 발생 전 마지막 트랜잭션을 구함 -> leader 에 연결하여 끊어진 동안 발생한 데이터 변경 요청

==== leader 장애: 장애 복구

follower 중 하나를 새로운 leader 로 승격 -> leader 로 전송하기 위해 재설정 +
= failover

자동 failover 순서

. leader 장애 여부 판단
** 일정 시간 응답이 없으면 죽은 것으로 간주
. 새로운 leader 선출
. 새로운 leader 사용을 위해 시스템 재설정

잘못될만한 포인트들

* 새로운 leader 가 이전 leader 의 쓰기 일부를 수신하지 못할 수 있음
** 이전 leader 에 복제되지 않은 write 를 단순 폐기할 수 있음 - tolerance 기대를 버림
** 폐기 부작용 - Github 사고
* split brain: 둘 다 leader 라고 주장하는 경우
** 두 leader 가 write 충돌을 해소하는 과정이 없으면 데이터가 유실되거나 오염
** 일부 시스템에는 하나를 죽이는 매커니즘이 있는데, 잘못하면 둘 다 죽일 수도

=== 복제 로그 구현

==== 구문 (stetement) 기반 복제

SQL 을 그대로 파싱 

문제점

* NOW(), RAND() 구문이 다른 값이 될 수 있음
** 미리 고정 값을 반환하게 대체할 수도
* AUTO_INCREMENT: 모든 구문이 정확히 같은 순서로 실행되어야
* trigger, stored procedure 등은 부작용이 발생할 수도

MySQL 은 row-based 복제를 사용

==== Write-ahead log (WAL) 배송

* LS 저장소 엔진은 로그 자체가 저장소의 주요 부분 - 작게 유지, 백그라운드 가비지 컬렉션
* B tree 에서 모든 변경은 WAL 에 쓰기 - 고장 이후 일관성 있는 상태로 복원

로그 = append-only

완전히 동일한 로그로 다른 노드에서 복제 서버를 구축할 수 있다 +
follower 에게 로그를 전송하기도 한다

PostgreSQL, Oracle

로그가 제일 저수준의 데이터를 기술한다 - 어떤 디스크 블록에서 어떤 바이트 변경 +
복제가 저장소 엔진과 밀접하게 엮임

복제 프로토콜이 버전의 불일치를 허용하지 않는다면 업그레이드 시 중단이 필요 +
(카프카에서 버전 호환되게 롤링 업그레이드 하는거와 비슷하게 해야 한다)

==== logical (row-based) log 복제

복제 (logical) 와 저장소 엔진 (physical) 에 다른 로그 형식을 사용

* INSERT 로그: 모든 컬럼의 새로운 값을 포함
* DELETE 로그: PK 포함, PK 가 없으면 모든 컬럼의 예전 값을 로깅
* UPDATE 로그: PK & 모든 컬럼의 새로운 값

transaction 의 경우 마지막에 커밋됐음을 레코드에 표시

하위 호환성을 쉽게 유지할 수 있다 +
leader, follower 에서 다른 버전 DB 나 다른 저장소 엔진을 실행할 수 있다

파싱하기 쉽다 - CDC

==== trigger 기반 복제

유연성이 필요한 상황: 데이터의 서브셋만 복제, DB 를 다른 종류의 DB 로 복제

Oracle GoldenGate: db log 를 읽어서 애플리케이션이 데이터를 변경할 수 있게 함 +

trigger or stored procedure

애플리케이션 코드를 등록할 수 있게 - 데이터가 변경되면 자동으로 실행 +
데이터 변경을 분리된 테이블에 로깅 - 이 테이블로부터 데이터 변경을 외부 프로세스가 읽음 +
외부 프로세스가 다른 시스템으로 데이터 변경 복제

Oracle 용 Databus, PostgreSQL 용 Bucardo

오버헤드가 크고, 버그나 제한 사항이 더 많이 발생

== 복제 지연 문제

follower 가 뒤처지면 불일치할 수도

=== 자신이 쓴 내용 읽기

데이터를 자주 읽지만 가끔 쓰는 경우

write after read 일관성을 구현

* 사용자가 수정한 내용을 읽을 때는 leader 에서 읽음
** 대량의 내용을 사용자가 편집할 수 있다면 효율적이지 않음
** 마지막 갱신 시간 후 1분 동안은 leader 에서 모든 읽기 수행
** or 1분 이상 늦은 follower 에 대한 질의 금지
* client 에서 마지막 쓰기 타임스탬프 기억 - 복제 서버가 최신 내용이 아니면 다른 복제 서버가 읽기 or 대기
* 복제 서버가 여러 데이터센터에 복제됐다면 복잡함
** 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅

=== monotonic read

개별 복제 DB 에서 조회하는 경우 '시간이 거꾸로 흐르는' (조회됐다가 안됐다하는) 현상이 있을 수도

데이터를 읽을 때 이전 값을 볼 수 있게 +
개별 사용자마다 특정 기준으로 해시하여 복제 서버를 선택하게

=== 일관된 순서로 읽기 (Consistent Prefix Read)

복제 순서가 뒤바뀐 경우, 보통 파티셔닝된 DB 에서 발생하는 특징적인 문제

파티션이 독립적으로 동작하여 write 순서가 섞이는 문제

서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게 한다 +
인과성을 명시적으로 유지하기 위한 알고리즘도 있다

==== 복제 지연을 위한 해결책

복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 보이게 만들어야 한다

== 