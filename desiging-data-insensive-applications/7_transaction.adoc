= 7. 트랜잭션

발생할 수 있는 문제들

* 하드웨어, 소프트웨어 실패
* 애플리케이션, 네트워크 다운
* 동시성 문제 - 덮어쓰기
* 부분적으로만 갱신 - 비정상적 데이터 읽기
* 클라이언트 간 race condition - 버그

트랜잭션: 애플리케이션에서 몇 개의 R/W 를 하나의 논리적 단위로 묶는 방법 +
전체가 성공 (commit) or 실패 (abort, rollback) +
DB 에 접속하는 앱에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것

== 애매 모호한 트랜잭션의 개념

분산 DB 로 오면서 트랜잭션은 확장성의 antithesis (반대) 이며 +
성능, 고가용성을 유지하려면 트랜잭션을 포기해야한다고 나오기도

트랜잭션은 이점과 한계가 있다

=== ACID 의 의미

Atomicity, Consistency, Isolation, Durability

DB 마다 ACID 구현이 제각각이다 (격리성이라는 의미의 모호함)

ACID 를 따르지 않느 BASE (Base Available, Soft state, Eventual consistency)

==== Atomicity

시스템은 연산을 실행하기 전 or 후의 상태만 있을 수 있고, 그 중간 상태에는 머물 수 없다

트랜잭션이 실패했다면 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도 할 수 있다

없다면? -> 어떤 변경이 효과가 있고 없는지 판별이 어려움

==== Consistency

항상 진실이어야 하는, 데이터에 관한 불변식(invariant)이 있다 +
트랜잭션이 불변식이 유효한 DB 에서 시작, 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존

애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다

나머지는 DB 의 속성이지만 이건 애플리케이션의 속성이다

==== Isolation

동시에 실행되는 트랜잭션은 서로 격리된다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다

(과거 교과서에서는) +
Serialzability: 개별 트랜잭션이 전체 DB 에서 유일한 트랜잭션인 것처럼 동작할 수 있다 +
트랜잭션이 커밋됐을 때 결과가 순차적으로 실행됐을 때의 결과와 동일하도록 보장

serialization isolation 은 성능 손해가 있어 거의 사용되지 않는다 +
snapshot isolation 에서 구현 (직렬성보다 보장이 약함)

==== Durability

트랜잭션이 성공적으로 커밋됐다면 어떤 문제가 발생해도 트랜잭션에서 기록한 모든 데이터가 손실되지 않음

=== 단일 객체, 다중 객체 연산

클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면, DB 가 원자성, 격리성을 어떻게 해야하는지

다중 객체 트랜잭션은 특정 R/W 연산이 동일한 트랜젹신에 속하는지 알아낼 수단이 있어야 한다 +
RDB 에서는 TCP 연결을 기반으로 함

NoSQL 에서는 위와 같이 연산을 묶는 경우가 없다

==== 단일 객체 쓰기

저장소 엔진들은 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공 +
원자성 - 장애 복구용 로그 기록, 격리성 - 각 객체에 lock 사용

여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실 (lost update) 을 방지하므로 유용

트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 본다

==== 오류와 어보트 처리

트랜잭션을 완전히 폐기

다만 리더없는 복제의 경우에서는 최선을 다하는 원칙 - 오류 복구는 애플리케이션에게 책임이 있다

abort 의 취지는 안전하게 재시도할 수 있게 하는 것

* 트랜잭션이 실제로는 성공했지만, 커밋 성공을 응답 중 네트워크가 끊겼을 때
** 애플리케이션에 추가적인 중복 제거 메커니즘이 필요
* 과부하 시 재시도는 상황 악화 가능성
** 재시도 횟수 제한, exponential backoff 등
* 일시적인 오류만 재시도할 가치가 있고, 영구적인 오류는 소용 없다
* DB 외부에도 side effect 가 있다면 abort 시에도 side effect 가 있을 수 있다
* 클라이언트가 프로세스 재시도 중 죽으면 DB 에 쓰려고 했던 데이터가 모두 손실

== 완화된 (Weaked) 격리 수준

isolation level

도구에 의존하기보다 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법 +
-> 사용 가능한 도구로 신뢰성 있고 올바르게 동작하는 애플리케이션 개발

=== Read Committed

. read 시 커밋된 데이터만 본다 (dirty read 없음)
. write 시 커밋된 데이터만 덮어쓰게 된다 (dirty write 없음)

==== dirty read/write 방지

DB 에 데이터를 썼지만 아직 commit/abort 되지 않은 데이터를 다른 트랜잭션에서 볼 수 없게

먼저 쓴 내용이 커밋되지 않은 트랜젹선에서 쓰고, 나중에 실행된게 커밋되지 않은 값을 덮어쓰는 것을 방지

==== read committed 구현

dirty write 방지: row-level lock 을 사용 +
acquire lock 이후 변경 진행

dirty read 방지: 쓰여진 객체에 대한 과거 커밋 값, 현재 트랜잭션에서 쓴 새로운 값을 모두 기억 -> 커밋 전에는 과거의 값을 읽음

=== Snapshot Isolation, Repeatable Read

nonrepeatable read or read skew +
다른 트랜잭션의 결과가 현재 트랜잭션에서의 읽기에 영향

문제가 될 수 있는 경우

* 백업: 백업의 일부는 데이터의 과거 버전, 다른 부분은 새 버전
* 분석 질의와 무결성 확인: 다른 시점의 DB 를 보면 불합리한 결과를 반환할 수 있다

각 트랜잭션은 DB 의 일관된 snapshot 으로 부터 읽는다

오래 걸리고 읽기만 실행하는 쿼리에 유용

==== snapshot isloation 구현

읽는 쪽, 쓰는 쪽이 서로 차단하지 않는다

dirty read 를 막는 데 쓰는 메커니즘을 일반화한 방법 사용 +
DB 는 객체마다 커밋된 버전 여러 개 유지 - MVCC (multi-version concurrency control) +
진행 중인 여러 트랜잭션에서 서로 다른 시점의 DB 상태를 봐야하므로

(그림 7-7) +
트랜잭션이 시작하면 계속 증가하는 TXID 를 할당 - DB 에 데이터를 쓸 때마다 실행한 TXID 가 같이 붙는다 +
row 에 TXID 를 저장해두는 필드 유지, 삭제하는 필드 유지 -> 아무 트랜잭션도 삭제 데이터에 접근하지 않으면 실제 삭제

==== 일관된 스냅샷을 보는 가시성 규칙

DB 입장에서 개별 트랜잭션에 스냅샷을 제공하는 규칙

. 각 TX 를 시작할 때 진행중인 모든 트랜잭션 목록을 만든다 -> 이 트랜잭션들이 쓴 데이터는 (커밋되더라도) 무시
. abort 된 트랜잭션이 쓴 데이터 무시
. TX 가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부에 관계 없이 모두 무시
. 그 밖의 모든 데이터는 애플리케이션 질의로 볼 수 있다

트랜잭션 내에서 볼 수 있는 데이터

* 트랜잭션이 시작한 시점에 커밋된 상태
* 아직 삭제로 표시되지 않은 데이터

==== 인덱스와 스냅샷 격리

다양한 방법들

* 인덱스가 객체의 모든 버전을 가리키게, 현재 트랜잭션에서 볼 수 없는 버전을 걸러내기
* 동일 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면, 인덱스 갱신 회피
* 추가 전용이며 쓸 때 복사되는 (append-only/copy-on-write) 변종 사용
** 페이지가 갱신될 때 변경된 페이지의 복사본 생성 +
부모 페이지 복사 - 자식 페이지들의 새 버전으 가리키도록 갱신
** write transaction 들은 새로운 B 트리 루트 생성, 나중에 실행되는 트랜잭션들은 새로운 tree 에서만 검색

==== repatedable read 와 혼란스러운 이름

SQL 표준에 이 개념이 없어서 vendor 마다 이름이 다름

=== 갱신 손실 (lost update) 방지

동시에 실행되는 write 트랜잭션 사이에 발생할 수 있는 문제

애플리케이션이 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 (read-modify-write) +
두 번째 변경이 첫 번째 변경을 포함하지 않으므로 변경 중 하나가 손실

==== 원자적 쓰기 연산

DB 에서 제공하는 기능, concurrency-safe

[source,sql]
----
UPDATE counters SET value = value + 1 WHERE key = 'foo';
----

ORM 을 사용하면 read-modify-write 를 하기 쉽다

==== 명시적인 잠금

갱신할 객체를 명시적으로 잠그기

다른 트랜잭션이 동시에 같은 객체를 건드리려고 할 때 이전 주지가 완료되기를 기다림

[source,sql]
----
BEGIN TRASACTION;

SELECT * FROM figures
    WHERE name = 'rbot' AND game_id = 222
    FOR UPDATE;


UPDATE ~~~

COMMIT;
----

lock 추가를 잊어서 race condition 을 유발하기 쉽다

==== 갱신 손실 자동 감지

트랜잭션 관리자가 갱신 손실을 발견하면 abort 시키고 read-modify-write 주기를 재시도하도록 강제하는 방법

DB 가 이 확인을 스냅샷 격리와 결합해 효율적으로 수행할 수 있다 +
PostgreSQL, Oracle, SQL server 등에서는 갱신 손실이 발생하면 자동으로 발견 -> 문제가 되는걸 abort +
MySQL InnoDB 는 감지하지 않음

애플리케이션 코드에서 특별한 기능을 쓰지 않아도 갱신 손실 감지 +
원자적 연산이나 lock 을 쓰지 않아서 버그가 있을 순 있지만 자동 감지하여 오류가 덜 발생하게

==== Compare-and-set

마지막으로 읽은 이후로 변경되지 않았을 때만 갱신을 허용 -> 갱신 손실 회피

오래된 스냅샷을 읽는 것을 허용한다면 갱신 손실을 막지 못할 수도 +
사용하기 전 확인이 필요

==== 충돌 해소와 복제

다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하기 위한 추가 단계 +
다중 리더 or 리더 없는 복제

여러 개의 충돌된 버전을 허용 -> 사후에 애플리케이션 코드나 특별한 데이터 구조로 충돌 해소 -> 병합

LWW 충돌 해소는 갱신 손실이 발생하기 쉬우나, 대부분에서 이게 디폴트다

=== 쓰기 스큐와 팬텀

==== 쓰기 스큐를 득정 짓기

두 트랜잭션이 두 개의 다른 객체를 갱신 +
(책에서는 읽고 -> 조건 체크하고 -> 쓰면, 둘 다 커밋됐을 때 조건이 만족되지 않음)

* 여러 객체가 연관 - 원자적 단일 객체 연산이 도움되지 않음
* 쓰기 스큐를 자동으로 방지하려면 진짜 직렬성 격리가 필요하다 - 갱신 손실 자동 감지에서 되지 않음
* DB contraint 설정 - 객체와 연관된 제약 조건이 필요한데, 대부분은 이런걸 지원하지 않음
** DB 에 따라 tree 나 materialized view 를 사용해 구현할 수 있다
* 트랜잭션이 의존하는 로우를 명시적으로 잠그는게 차선책이다

==== 추가적인 쓰기 스큐

회의실 예약, 멀티플레이어 게임, 유니크 사용자명 획득, 이중 사용 금지

이 예시들에서는 아래 1단계 쿼리 결과가 없어서 FOR UPDATE 가 불가능

==== 쓰기 스큐를 유발하는 팬텀

. SELECT 쿼리가 요구사항을 만족하는지 확인
. 위 결과에 따라 코드 진행 결정
. 계속 처리하기로 결정하면 CUD 트랜잭션을 커밋
** 2번을 결정한 전제 조건이 바뀐다

write -> select -> 그 결과에 따라 abort/commit 하는 식에서도 재현될 수 있음

팬텀: 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과

==== 충돌 구체화

팬텀의 문제 = 잠글 수 있는 객체가 없다 -> 인위적으로 DB 에 lock 객체 추가 +
-> 충돌 구체화 (materializing conflict) = 팬텀을 DB 에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환

회의실 예약에서 회의실에 대한 테이블 - 회의실과 시간 범위의 모든 조합에 대해 row 를 미리 만들기 +
예약 시 FOR UPDATE 로 잠글 수 있다 (내부에서 1시간 제한이 있는게 혹시..?)

충돌을 구체화하는 방법을 알아내기 어렵고 오류가 발생하기 쉽다 +
동시성 제어 메커니즘이 데이터 모델로 나오는게 보기 좋지 않음 +
다른 대안이 불가능할 때 최후의 수단

대부분은 직렬성 격리 수준을 더 선호

== 직렬성 (Serializability)

isolation level 이해의 어려움 & 구현 일관성 없음 +
애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는게 안전한지 알 수 없음 +
race condition 감지에 좋은 도구가 없다

직렬성 격리를 사용하면 해결

여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행할 때와 같도록 보장

직렬성을 구현하는 선택지들 (트랜잭션 순차 실행, 2단계 잠금, 낙관적 동시성 제어)

=== 시제적인 직렬 실행

단일 스레드에서 동시에 하나의 트랜잭션만 수행

==== 트랜잭션을 Stored procedure 안에 캡슐화하기

초창기 DB 는 트랜잭션이 사용자 활동의 전체 흐름을 포함할 수 있게 함 (사용자와 상호작용하는 여러 과정을 하나로 통합)

현재는 사용자 응답 대기를 회피, 트랜잭션을 짧게 +
새로윤 HTTP 요청은 새로운 트랜잭션 -> 상호작용식 트랜잭션 -> 네트워크 통신 비용에 많은 시간

단일 스레드 순차 트랜잭션 시스템에서는 다중 구문 트랜잭션을 허용하지 않는다 +
애플리케이션은 트랜잭션 코드 전체를 stored procedure 형태로 DB 에 미리 제출해야 한다

==== stored procedure 장단점

* DB 벤더마다 개별 프로시저용 언어가 있음. 언어 발전을 따라잡지 못해서 생태계 빈약
* DB 에서 실행되는 코드는 관리되기 어려움 - 디버깅, 버전관리 및 배포, 테스트, 지표 수집 등
* 잘못된 코드로 인한 DB 성능 저하

일부 DB (Vault, Datomic, Redis) 에서는 Java, Groovy, Clojure, Lua 지원

store procedure 가 있고 데이터가 메모리에 저장된다면 +
I/O 대기가 필요 없고, 동시성 오버헤드를 회피하므로 단일 스레드로 좋은 처리량

==== 파티셔닝

각 트랜잭션이 단일 파티션 내에서만 읽고 쓰도록 한다면 +
각 파티션은 다른 파티션과 독립적으로 실행되는 개별 단일 스레드를 가질 수 있음

여러 파티션에 접근해야 하는 트랜잭션은 접근하는 모든 파티션에 걸친 코디네이션을 해야 한다 +
stored procedure 의 경우 모든 파티션에 lock 을 얻어야 함 +
여러 파티션의 경우는 느리다

==== 요약

* 모든 트랜잭션은 작고 빨라야 한다
* 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 제한 - 그렇지 않으면 시스템이 느려진다
* 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 낮아야 한다
* 여러 파티션도 가능은 하지만 제한적

=== 2단계 잠금 (2PL)

two-phase locking

어떤 객체에 쓰려고 하면 독점적인 접근이 필요

* A 가 읽고, B 가 쓰려면? B 가 진행하기 전 A 의 완료를 기다려야 한다
* A 가 썼고, B 가 읽으려면? B 는 진행하기 전에 A 의 완료를 기다려야 한다

스냅샷 격리는 서로를 막지 않지만, 2PL 은 막음

==== 2단계 잠금 구현

MySQL, SQL Server - 직렬성 격리 수준 구현에 사용, DB2 - repeatable read 구현에 사용

각 객체에 잠금을 사용하여 구현. shared mode, exclusive mode

* 읽기? - shared mode 로 lock 획득
** lock 획득하면 읽는건 문제가 없는지? - 아래 index ranged 에서는 발견하면 대기한다는데
** 여러 트랜잭션이 가능하지만 exclusive mode 로 획득한 트랜잭션이 있으면 완료될 때까지 기다려야야 함
* 쓰기? - exclusive mode 로 lock 획득
** 다른 트랜잭션들은 lock 이 존재하면 대기해야 한다
* 읽다가 쓰기를 실행할 때 shared mode -> exclusive mode 로 업그레이드해야 한다
* lock 을 획득한 후에는 종료될 때까지 lock 을 갖고 있어야 한다
** 1 (획득) + 1 (해제)

deadlock 발생 시 DB 가 자동 감지하여 하나를 abort 시킴 - 다른 트랜잭션들이 진행할 수 있게 함 +
abort 된건 애플리케이션에서 재시도해야 한다

==== 2단계 잠금 성능

트랜잭션 처리량과 질의 응답 시간이 크게 나쁘다

lock 획득/해제의 오버헤드 & 동시성이 줄어듦

RDB 들은 트랜잭션 실행 시간을 제한하지 않았음

lock 기반 read_committed 에서도 deadlock 이 생길 수도 있지만, 2PL 에서 훨씬 자주..

==== 서술 (predicate) 잠금

팬텀을 방지하기 위한, +
특정 조건에 부합하는 모든 객체에 걸친 lock

* 조건에 해당하는 shared mode predicate lock 을 획득
** 하나라도 exclusive 상태면 완료를 대기해야 한다
* 어떤 객체에 대해 CUD 를 원하면 predicate lock 에 부합하는게 있는지 확인해야 한다
** 다른 트랜잭션에서 predicate lock 을 가지고 있다면 완료를 기다려야 한다

아직 존재하지 않지만 미래에 추가될 수 있는 객체에도 적용 가능

==== 색인 범위 잠금 (index-range locking, next-key locking)

서술 잠금이 잘 동작하지 않음, 근사한게 이것

간략화된 검색 조건이 index 중 하나에 붙음 +
다른 트랜잭션이 같은 조건으로 CUD 를 원하면 index 의 같은 부분을 갱신 - shared lock 을 발견하고 해제 대기

팬텀과 쓰기 스큐 보호

적합한 index 가 없으면 테이블 전체에 shared lock - 다른 write 트랜잭션을 막아서 성능이 좋지 않음

=== 직렬성 스냅샷 격리 (Serializable Snaphot Isolation)

2008년에 기술된 알고리즘, 낙관적 동시성 제어

==== 비관성 동시성 제어 vs 낙관적 동시성 제어

pessimistic (2PL) vs optimistic

격리 위반이 발생할 가능성이 있어도 계속 진행 +
트랜잭션이 커밋되기 전 DB 에서 격리가 위반됐는지 확인 -> 위반이라면 abort

놕관적 아이디어에서 경쟁이 심하면 abort 시켜야 할 트랜잭션 비율이 높음 -> 성능이 떨어짐 +
최대 처리량에 근접했다면 재시도 트랜잭션 부하로 인한 추가 성능 저하

예비 용량이 충분하고 경쟁이 심하지 않다면 성능이 더 좋음 +
경쟁은 commutative 원자적 연산으로 줄일 수 있음 +
(ex. 동시에 카운터를 증가시키려고 할 때, 증가 연산이 어떤 순으로 적용되는지는 관계가 없다)

스냅샷 격리를 기반으로 하여 읽기는 일관된 스냅샷을 봄 +
스냅샷 격리 위에 쓰기 작업 사이의 직렬성 충돌 감지 - abort 할 트랜잭션을 결정하는 알고리즘 추가

==== 뒤쳐진 전제에 기반한 결정

트랜잭션에는 특정 전제를 기반으로 특정 동작을 한다 +
스냅샷 격리를 사용하므로, 커밋하려고 할 때 원래 데이터가 바뀌어서 전제가 참이 아닐 수 있음

어떻게 바뀐걸 감지할지

===== 1) 오래된 MVCC 감지하기

A read -> A write -> (A write 전 트랜잭션 시작) B read

MVCC (다중 버전 동시성 제어)

트랜잭션이 다른 트랜잭션의 쓰기를 무시하는 경우를 추적 +
커밋하려고 할 때 무시된 쓰기 중에 커밋된게 있는지 확인 -> 있다면 abort

감지되자마자 abort 가 아니라, 커밋 시점에 abort +
-> 불필요한 abort 를 피하고, 일관된 스냅샷을 읽으면서 오래 실행되는 작업을 지원하는 특성 유지

===== 2) 과거의 읽기에 영향을 미치는 쓰기 감지하기

A read -> B read -> A write -> B write

데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 경우

영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 index 에서 확인 +
커밋될 때까지 차단하지 않음

그림 7-11 에서 서로 다른 트랜잭션에서 알려주긴 하지만, 커밋되기 전에는 abort 없음

==== 직렬성 스냅샷 격리의 성능

다른 트랜잭션들이 잡고 있는 lock 을 기다리느라 차단될 필요가 없다

파티셔닝되어 있더라도 직렬성 격리를 보장하면서 여러 파티션을 읽고 쓸 수 있다

abort 비율이 성능에 영향 - 오랜 시간의 트랜잭션은 충돌, abort 가 쉬움 +
트랜잭션이 짧기를 요구