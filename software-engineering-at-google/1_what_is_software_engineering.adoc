= 1. 소프트웨어 엔지니어링이란?

(Part 1 전제)

시간의 흐름과 언젠가 변경될 가능성에 더 신경 써야 한다

소프트웨어 엔지니어링 = 개발 + 수정 + 유지보수

지속 가능성 = 소프트웨어의 기대 생애 동안 요구되는 모든 가지 있는 변경에 대응할 수 있는지

팀 조직, 프로젝트 구성, 정책, 관례는 모두 소프트웨어 엔지니어링의 복잡성을 좌우한다 & 규모와 관련

== 시간과 변경

수십 년을 지속하는 프로젝트로 전환하는 기점에 외부 환경의 변화에 대비하기 시작해야 한다 +
(저자는 개발 후 5년 내에 전환 시작)

전환하기는 어렵다, 그 이유

. 수행해본 적 없는 작업을 진행해야 한다 - 숨어 있던 가정들이 나타남
. 업그레이드 담당 엔지니어들이 이런 작업을 해본 경험이 없을 가능성이 크다
. 일반적인 업그레이드보다 작업 규모가 큰 경우가 많다 - 수년 치 업그레이드를 한 번에

수명이 길어질수록 '동작한다' 와 '유지보수 가능하다' 를 더 분명하게 인지해야 한다

=== 하이럼의 법칙

[quote]
API 사용자가 충분히 많다면 API 명세의 내용은 중요하지 않다 +
시스템에서 눈에 보이는 모든 행위를 누군가는 이용하게 될 것이기 떄문

\= 근거가 뒷받침되더라도 공표한 명세나 모범 사례를 완벽하게 구현해냈다고 단정할 수 없다 +
현실에서는 API 사용자가 없는 기능을 찾아 활용하기도 하고, 널리 쓰이면 API 변경이 어렵게 된다 +
(근데 이런거까지 지원해야할 의무는 없지 않나. 없는걸 쓰는거고 더 일반적인 패치인데 p47 그림 1-2)

=== 사례: 해시 순서

hash iteration ordering

수명에 대한 요구사항이 다양하다면, 프로그래밍 스타일을 이렇게 분류해볼 수 있음

* 명시되지 않은, 변할 수 있는 기능을 사용하는 코드는 임시방편적 (hacky) or 기발한 (clever) 코드
* 모범 사례를 따르고 미래에 대비한 코드는 클린하고 유지보수 가능한 코드

=== '변하지 않기'를 목표로 하지 않는 이유

'변경은 피할 수 없다'

대부분의 프로젝트는 기반 기술의 변화를 훨씬 많이 겪는다

이전 시스템에 문제가 없더라도 시간이 흐르면 변경을 진행할 이유가 생기기도 +
(최신 장비의 잠재력을 끌어낼 적절한 설계 변경 등)

== 규모 확장과 효율성

SRE 는 거대한 조직의 복잡성과 시스템을 운영하는 절차를 보여줌

비용이 너무 많이 드는 변경은 지연되기 쉽다

인력, 물리적인 컴퓨팅 리소스, 코드베이스

코드베이스 - 코드가 많아지고 변경 이력이 쌓이는 이유로 빌드 시스템이나 버전 관리 시스템이 느려지면, 운영할 수 없는 시점이 온다 +
전체 빌드에 걸리는 시간, 레포에서 새로 내려받는 시간, 언어 버전을 업그레이드하는 비용

조직에서 코드를 작성하고 관리하는 데 활용되는 모든 것이 총비용과 자원 소비 측면에서 확장 가능해야 한다

=== 확장하기 어려운 정책들

deprecation 은 의존성 그래프가 커지면 어렵다 - 사용자 쪽 수정 시 측면에서 얻는 이익이 눈에 보이지 않음 or 우선순위가 낮음

트렁크 브랜치 전략

=== 확장 가능한 정책들

비욘세 규칙: '인프라를 변경하여 서비스가 중단되는 등의 문제가 발생하더라도, 같은 문제가 CI 시스템의 자동 테스트에서 발견되지 않는다면 인프라팀의 책임이 아니다' +
(좋아했다면 CI 테스트를 준비해뒀어야 한다)

(? 인프라를 변경하는걸 테스트에서 어떻게 잡는가, 너무 과한 테스트를 준비해야 하는거 아닌가)

엔지니어들이 포럼에 질문하고 답하는 과정에서 지식이 전파되고, 새로운 전문가가 성장한다

=== 사례: 컴파일러 업그레이드

컴파일러 변경이 초래할 영향을 사전에 알기 어려웠고, 회귀 문제가 발생할수도

규모 문제를 극복할 기술을 찾고 조직 변화 -> 큰 규모가 장점이 되도록 노력 +
자동화, 통합과 일관성, 전문성으로 이어졌다

코드를 한 번 수정해두면 코드가 더 견고해지고 다음번 업그레이드도 수이ㅝ진다

코드베이스의 유연성에 영향을 주는 여러 오인들

* 전문성 (expertise): 여러 경험을 통한 충분한 시직
* 안정성 (stability): 더 규칙적인 릴리즈를 통해 릴리즈 간 변경을 줄임
* 순응 (conformity): 규칙적인 업그레이드
* 익숙함 (similiarity): 정기적인 업그레이드로 중복을 찾아 자동화, 삽집을 줄이는 관점
* 정책 (policy): 비욘세 규칙과 같은 정책과 절차를 갖춤

코드 베이스가 계속 커지더라도 일정한 수의 엔지니어만으로 업그레이드를 성공적으로 해내는 방법을 찾았다

=== 원점 회귀 (왼쪽으로 이동)

더 빨리 발견하면 더 쉽게 수정할 수 있다

(구현 - 리뷰 - 테스트 - 커밋 - 카나리)

== 트레이드오프와 비용

비용 = 투입된 노력과 다양한 요소들을 모두 보괄 +
(다양한 요소 = 돈, 리소스, 인적, 거래, 기회, 사회적)

비용 외에 현상 유지 편향 (status quo bias), 손실 회피 (loss aversion) 등의 치우침도 존재

구성원들이 스스로의 가치를 느끼고 생상적인 일을 하고 있다는 생각까지 포함

=== 사례: 화이트보드 마커

일상적인 개발 시 드는 경비, 서비스를 준비하고 운영하는 방법까지 +
모든 일과 관련된 비용/이윤 트레이드오프에 동일한 수준의 관심을 두고 명확히 재량

엔지니어링 조직의 선택을 결정짓는 요인

* 반드시 해야 하는 일 (법, 고객 요구사항)
* 근거에 기반하여 당시 내릴 수 있는 최선의 선택

'내가 시켰으니까' 는 안된다

=== 의사결정을 위한 근거 자료

근거 자료의 가중치를 정하는 두 가지 시나리오

. 정량적 데이터를 '측정' or '추정' 할 수 있는 경우
. 측정하기 어렵거나 측정 방법을 모르는 정량적 데이터

모든 것이 측정 가능하거나 예측 가능하지 않다는 사실을 인정하고, 그런 결정에도 똑같은 우선순위와 관시믈 두어야 한다

=== 사례: 분산 빌드

생략

(여기서 말하는 분산 빌드는 어떤 것일지. 기존에는 배포할 artifact 를 로컬에서 빌드했다는 건가?)

=== 사례: 시간과 규모 확장 사이에서 결정하기

특정 문제가 특정 집단에서만 발생할 때

프로젝트의 수명이 작다면 fork 해도 위험이 적다 (영향 범위가 제한적) +
프로젝트 수명에 종속되지 않는 인터페이스라면 fork 를 피하는 것이 좋다


=== 결정 재고하기와 잘못 인정하기

잘못했음을 인정할 수 있게 해주는 능력 - 데이터 중심 문화가 주는 장점

시스템의 생애 동안 과거에 내린 결정을 수시로 재고해봐야 한다

근거 (데이터) 에 의해 결정하되 측정할 수 없느 ㄴ요인들에도 가치가 있을 수 있다는 것을 명심해야

== 소프트웨어 엔지니어링 vs 프로그래밍

둘에 적용되는 제약 사항, 가치, 모범 사례가 다르다

한 영역에서는 훌륭해도 다른 영역에서는 아닐 수 있음

소프트웨어 엔지니어링은 오랫동안 코드를 유용하게 관리하고 팀 간 협업을 가능하게 하는 정책, 관례, 도구 모두를 아우르는 종합적인 개념