= 8. 스타일 가이드와 규칙

코드 베이스를 관리하는 규칙 - 파일 위치, 코드 포맷팅, 네이밍 방식, 패턴, 예외와 스레드 사용법

지침 - 권장사항과 모범 사례

구글에서 따라야 하는 혹은 하지 말아야 하는 규칙 -> 프로그래밍 스타일 가이드 +
프로그래밍 언어별로 관리, 코드베이스를 지속 가능하게 관리하기 위한 규칙들

== 규칙이 필요한 이유

(조직이 추구하는 가치에 따른) 좋은 행동 장려, 나쁜 행동 억제

조직이 커지더라도 일관되게 통용되는 공통의 코딩 어휘 +
형식 보다 내용에 집중할 수 있음

== 규칙 만들기

'어떤 목표를 이룰지?' 를 기준으로

=== 기본 원칙 안내

구글에서는 '규모, 시간 측면에서 탄력적인 엔지니어링 환경이 지속되도록 하는 것'

복잡도 관리 & 생산성을 희생하지 않는 선에서 코드베이스를 관리하게끔 유지하는 것

* 규칙의 양을 최소화
** 익히고 적응하는 데 비용 최소화, 너무 자명한 규칙은 배제
* 코드를 읽는 사람에게 맞춤
** 코드가 하려는 일이 무엇인지를 읽는 사람이 즉시 알 수 있게
** 함수의 구현부를 들여다보지 않고도 호출 지점에서 무슨 일이 벌어지는지 이해할 수 있게
* 일관되어야 한다
** 어떻게가 아닌 무엇에 집중할 수 있음
** 규모를 확장하기 쉽게
** 표준 정하기
*** 작게 시작해서 확장
*** 외부 규칙과 일관되게 잡는게 좋다
* 오류가 나기 쉽거나 예상치 못한 동작을 유발하는 구조를 피하기
* 꼭 필요하다면 실용성을 생각해 예외를 허용
** 최적화나 실용성을 위해

=== 스타일 가이드

3가지 범주

==== 위험 회피하기

기술적인 이유로 반드시 써야 하거나 쓰면 안되는 언어 특성 +
어떤 언어 특성은 사용하고, 어떤 구조는 피해야 하는지

static member/variable, lambda expression, exception processing, thread/access control, class inheritance, ...

직관적이지 않거나 올바르게 사용하려면 주의해야 해서, 잘못 쓰면 미묘한 버그 유발되기 때문

가이드의 판단에는 결론의 근거 (장/단점), 어디에 무게를 두었는지를 설명

==== 모범 사례 강제하기

ex) 주석을 어디에 어떻게 작성해야 하는지 +
작성자의 의도가 코드 자체에 명확하게 드러나지 않는 경우

소스 코드의 가독성을 높이도록 설계, 언어에 따라서는 자동 포맷팅 도구

새롭거나 아직 널리 이해되지 못한 언어 기능을 제한하기도

==== 일관성 구축하기

사소만 문제는 결정을 내리고 문서로 남긴다 - 네이밍 컨벤션, 들여쓰기 공백 수, import 순서

선택을 했다는 사실에 의의를 둠, 논쟁에서 벗어나 중요한 일로 시선을 돌리게

== 규칙 수정하기

결정 근거를 남겨둔 문서 -> 변경해야 할 때가 언제인지를 알아내기 쉬워진다 +
과거의 요인들 중 하나가 변했는지가 규칙을 다시 평가해야 하는 기준

=== 프로세스

변경해야 할 게 있는지 찾아내고 갱신하는 프로세스

현재 문제(현존하는 구글 코드에서 발견된 패턴)를 찾아내 설명, 해법을 보여준다

스타일 가이드의 수정이 대부분 커뮤니티에서의 토론에서 출발 +
수정 제안은 구체적일 수도, 모호한 질문일 수도 +
커뮤니티의 검토를 거친 제안은 최종 승인 단계로

=== 스타일 중재자 (arbiter)

언어별로 소유자가 있음 - 최종 결정과 승인

=== 예외

특정 상황에서는 일부 규칙을 적용하지 않아도 되게

규칙을 따르기보다 예외를 인정하는게 이득이라고 판달될 때

== 지침

엔지니어링 경험에서 선별한 지혜, 과거로부터 배운 교훈들을 문서로 남긴 것

규칙 must, 지침 should (되도록)

빠르게 실전 투입할 수 있도록 가르치는 교츅, 코드베이스에서 필요한 정보를 찾을 때 참고할 수 있는 자료 등

ex) 구현하기 어려운 주제에 관한 언어별 조언 (동시성, 해싱), 언어의 최신 버전에서 소개된 새로운 기능의 상세 설명과 적용하는 법에 관한 조언, 구글 라이브러리가 제공하는 중요한 추상 개념과 데이터 구조 목록

== 규칙 적용하기

구글은 규칙들이 요구하는 모범 사례를 숙달하게끔 도와주는 정규 교육 운영 +
업데이트에도 자원 투자

규칙이 실제로 지켜지는지는 자동화 도구를 활용 +
-> 실수로 누락되는걸 방지 +
-> 자의적으로 해석할 여지를 남기지 않음 +

도구만으로는 안되는, 판단이 필요한 것들도 있음 (catch 후 아무 일도 하지 않는 것, 클래스마다 순서가 다를 수 있음...)

사회적 문제를 다루는 규칙들 (ex. 변경 코드 크기를 작게) 은 엔지니어들의 재량에 맞긴다

=== 오류 검사기

정적 분석 도구로 강제

=== 코드 포매터

사소한 스타일 문제를 찾고, 체크하고, 수정하는데 허비되던 시간을 제거

presubmit check 로 포매터를 반드시 사용 +
커밋 전에 빌드 인프라의 서비스가 포매터 수행 -> 포맷과 차이가 있다면 submit 거부