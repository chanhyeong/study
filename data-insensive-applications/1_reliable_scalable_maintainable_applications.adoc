= 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

data-intensive 애플리케이션

* 데이터의 양, 복잡도, 변화 속도가 큰 문제
* 표준 구성 요소 (standard building block)
** database: 데이터를 찾을 수 있게 저장
** cache: 일기 속도 향상을 위해 비싼 수행 결과 기억
** search index: 키워드나 다양한 방법으로 검색, 필터링할 수 있게 제공
** stream processing: 비동기 처리를 위해 다른 프로세스로 메시지 전송
** batch processing: 주기적으로 대량의 누적된 데이터 분석

== 데이터 시스템에 대한 생각

(DB, queue, cache 등을) **데이터 시스템**이라는 포괄적 단어로 묶는 이유?

. 데이터 저장, 처리를 위한 새로운 도구들이 최근에 만들어져서 전통적인 분류에 맞지 않음
. 애플리케이션이 단일 도구로는 데이터 처리, 저장을 모두 만족시킬 수 없음

(그림 1-1 에서 애플리케이션과 데이터 시스템 간 관계도)

* 신뢰성 (Reliability): 하드웨어, 소프트웨어, 인적 오류 등의 역경에도 시스템은 올바르게 동작
* 확장성 (Scalability): 시스템의 데이터/트래픽 양, 복잡도가 증가하면서 이를 처리할 적절한 방법
* 유지보수성 (Maintainability): 모든 사용자가 시스템 상에서 생상적으로 작업할 수 있게

== 신뢰성

소프트웨어에서 일반적인 "신뢰한다" 의 기대치

* 애플리케이션은, 사용자가 기대한 기능 수행
* 시스템은, 사용자의 실수나 예상치 못한 사용법을 허용
* 시스템 성능은, 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족
* 시스템은, 허가되지 않은 접근과 오남용 방지

결함 (fault): 잘못될 수 있는 일, 사양에서 벗어난 시스템의 한 구성 요서 +
내결함성 (fault-tolerant) or 탄력성 (resilient): 결함을 예측하고 대처할 수 있는 시스템

결함 != 장애 (사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우)

이 책은 해결책이 있는 결함 유형을 다룬다

=== 하드웨어 결함

1만개의 디스크로 구성된 클러스터는 평균 하루에 1개가 죽는다고 예상해야 한다

소프트웨어 내결함성 기술을 사용 or 하드웨어 중복성 (redundancy) 을 추가

=== 소프트웨어 오류

* 특정 입력으로 인해 모든 애플리케이션 서버 인스턴스가 죽음
* 공유 자원을 과도하게 사용
* 속도가 느려저 반응이 없거나 잘못된 응답 반환
* cascading failure
* ...

특정 상황이 발생하기 전까지 나타나지 않음

=== 인적 오류

사람을 믿기 위해 다양한 접근 방식을 결합

* 오류 가능성을 최소화하는 방향으로 시스템 설계 (추상화 등)
* 가장 많이 실수하는 장소에서 장애가 발생할 수 있는 부분 분리
** 실제 데이터를 안전하게 살펴보고 실험할 수 있지만, 실제 사용자에게 영햐잉 없는 비 프로덕션 샌드박스 제공 (현재 있는 red 무슨 외부 데이터 저장소인듯)
* 단위 테스트부터 통합, 수동 테스트까지 철저하게
* (장애 발생의 영향을 최소화하기 위해) 인적 오류를 빠르고 쉽게 복구할 수 있도록 하기
** 빠르게 roll back, 서서히 roll out
* 성능 지표, 오류율 같은 상세하고 명확한 모니터링 대책 마련. 원격 측정 (telemetry), 지표 (metric)
* 조직 교육과 실습

== 확장성

증가한 부하에 대처하는 시스템 능력

아래와 같은 질문을 고려한다는 의미

[quote]
시스템이 특정 방식으로 커지면 대처하기 위한 선택은 무엇인가? +
추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

=== 부하 기술하기

현재 시스템의 부하를 간결하게 기술

**부하 매개변수 (load parameter)** - server RPS, DB R/W 비율, active user, cache hit ratio, ...

트위터의 사례에서는 사용자 당 팔로워 분포가 부하를 결정

=== 성능 기술하가

부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있음

* 동일한 리소스에서 부하 매개변수를 증가시키면 성능은 어떻게 영향을 받을지?
* 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되려면, 자원을 얼마나 늘려야 하는지?

p14 그림 1.4 - 평균, 백분위

평균보다는 **백분위**를 사용하는게 좋다 +
특이 값 (outlier) 가 얼마나 안 좋은지는 상위 백분위 (95, 99, 99.9분위 등) 으로 파악 (= tail latency)

백분위는 SLO (service level objective), SLA (service level agreement) 에 자주 사용

head-of-line blocking: 느린 요청으로 인해 후속 요청이 지체

.실전 백분위 (p16)
****
응답 시간 백분위 추가 - 지속적으로 백분위를 효율적으로 계산 +
10분 간 요청의 응답 시간을 rolling window 로 유지, 1분마다 중앙값, 다양한 백분위 계산하여 지표 발행

단순 구현 - 모든 요청의 응답 시간 목록 유지, 1분마다 목록 정렬 +
forward decay, t-digest, HdrHistogram 등의 알고리즘을 이요할 수도
****

=== 부하 대응 접근 방식

부하 매개변수가 증가하더라도 좋은 성능을 유지하려면?

* 용량 확장 (scaling up) (vertical scaling)
* 규모 확장 (scaling out) (horizontal scaling)

일반적으론 고가용성 요구가 있을 때까지 단일 DB 에 유지 +
향후에는 다를 수 있고, 뒤에서 다양한 분산 데이터 시스템 및 확장성과 손쉬운 사용, 유지보수 달성을 어떻게 할지 설명

대규모 시스템 아키텍처는 해당 애플리케이션에 특화되어 있음 +
read/write 양, 저장할 데이터 양, 데이터 복잡도, 응답 시간 요구사항, 접근 패턴, ....

== 유지보수성

소프트웨어 비용의 대부분은 유지보수에 들어간다

유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어 설계하는 원칙

* 운용성 (operability): 운영이 쉽게
* 단순성 (simplicity): 이해하기 쉽게
* 발전성 (evolvability): 변경하기 쉽게 (a.k.a. extensibility, modifiablilty, plasticity)

=== 운용성: 운영의 편리함 만들기

운영 중 일부 측면은 자동화할 수 있으며 자동화해야 한다

동일하게 반복되는 태스크를 쉽게 수행하게 만들어서 운영팀이 더 가치있는 활동에 노력을 집중하게

* 좋은 모니터링 - 런타임 동작, 시스템 내부에 대한 가시성
* 표준 도구 - 자동화와 통합을 위한 자원 제공
* 개별 장비 의존성 회피 - 장비를 내리더라도 시스템 전체에 영향을 주지 않아야
* 좋은 문서와 이해하기 쉬운 운영 모델
* 만족할 만한 기본 동작 제공, 필요할 때 관리자가 기본값을 다시 정의할 수 있게
* 적절한 self-healing, 관리자가 필요에 따라 시스템 상태 수동 제어
* 예측 가능하게 동작, 예기치 않은 상황 최소화

=== 단순성: 복잡도 관리

큰 상태 공간, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 네이밍, ...

복잡하면 버그가 생길 위험이 크다. 반대로 복잡도를 줄이면 유지보수성이 크게 향상

우발적 (accidential) 복잡도를 줄이게 - 소프트웨어의 기능이 아닌 구현에서만 발생하는 복잡도 +
-> **추상화**

=== 발전성: 변화를 쉽게 만들기

애자일 작업 패턴 - 변화에 적응하기 위한 프레임워크 제공

애자일 기법은 대부분 소규모에 초점을 두고 있다 +
이 책에서는 다양한, 대규모 수준에서 민첩성을 높이는 방법을 다룰 예정

간단함, 추상화와 밀접한 관련이 있다