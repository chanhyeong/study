= 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

data-intensive 애플리케이션

* 데이터의 양, 복잡도, 변화 속도가 큰 문제
* 표준 구성 요소 (standard building block)
** database: 데이터를 찾을 수 있게 저장
** cache: 일기 속도 향상을 위해 비싼 수행 결과 기억
** search index: 키워드나 다양한 방법으로 검색, 필터링할 수 있게 제공
** stream processing: 비동기 처리를 위해 다른 프로세스로 메시지 전송
** batch processing: 주기적으로 대량의 누적된 데이터 분석

== 데이터 시스템에 대한 생각

(DB, queue, cache 등을) **데이터 시스템**이라는 포괄적 단어로 묶는 이유?

. 데이터 저장, 처리를 위한 새로운 도구들이 최근에 만들어져서 전통적인 분류에 맞지 않음
. 애플리케이션이 단일 도구로는 데이터 처리, 저장을 모두 만족시킬 수 없음

(그림 1-1 에서 애플리케이션과 데이터 시스템 간 관계도)

* 신뢰성 (Reliability): 하드웨어, 소프트웨어, 인적 오류 등의 역경에도 시스템은 올바르게 동작
* 확장성 (Scalability): 시스템의 데이터/트래픽 양, 복잡도가 증가하면서 이를 처리할 적절한 방법
* 유지보수성 (Maintainability): 모든 사용자가 시스템 상에서 생상적으로 작업할 수 있게

== 신뢰성

소프트웨어에서 일반적인 "신뢰한다" 의 기대치

* 애플리케이션은, 사용자가 기대한 기능 수행
* 시스템은, 사용자의 실수나 예상치 못한 사용법을 허용
* 시스템 성능은, 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족
* 시스템은, 허가되지 않은 접근과 오남용 방지

결함 (fault): 잘못될 수 있는 일, 사양에서 벗어난 시스템의 한 구성 요서 +
내결함성 (fault-tolerant) or 탄력성 (resilient): 결함을 예측하고 대처할 수 있는 시스템

결함 != 장애 (사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우)

이 책은 해결책이 있는 결함 유형을 다룬다

=== 하드웨어 결함

1만개의 디스크로 구성된 클러스터는 평균 하루에 1개가 죽는다고 예상해야 한다

소프트웨어 내결함성 기술을 사용 or 하드웨어 중복성 (redundancy) 을 추가

=== 소프트웨어 오류

* 특정 입력으로 인해 모든 애플리케이션 서버 인스턴스가 죽음
* 공유 자원을 과도하게 사용
* 속도가 느려저 반응이 없거나 잘못된 응답 반환
* cascading failure
* ...

특정 상황이 발생하기 전까지 나타나지 않음

=== 인적 오류

사람을 믿기 위해 다양한 접근 방식을 결합

* 오류 가능성을 최소화하는 방향으로 시스템 설계 (추상화 등)
* 가장 많이 실수하는 장소에서 장애가 발생할 수 있는 부분 분리
** 실제 데이터를 안전하게 살펴보고 실험할 수 있지만, 실제 사용자에게 영햐잉 없는 비 프로덕션 샌드박스 제공 (현재 있는 red 무슨 외부 데이터 저장소인듯)
* 단위 테스트부터 통합, 수동 테스트까지 철저하게
* (장애 발생의 영향을 최소화하기 위해) 인적 오류를 빠르고 쉽게 복구할 수 있도록 하기
** 빠르게 roll back, 서서히 roll out
* 성능 지표, 오류율 같은 상세하고 명확한 모니터링 대책 마련. 원격 측정 (telemetry), 지표 (metric)
* 조직 교육과 실습