= 2. 데이터 모델과 질의 원어

데이터 모델 - 소프트웨어가 어떻게 작성됐는지 + 해결하려는 문제를 어떻게 생각하는지애 영향

데이터 저장과 질의를 위한 다양한 범용 데이터 모델 & 다양한 질의 언어 볼 예정

== 관계형 모델과 문서 모델

1970년, 관계형 모델을 기반으로 한 SQL +
데이터는 releation 으로 구성, 각 관계는 순서 없는 tuple 모음

RDBMS 과 SQL 은 정규화된 구조로 데이터를 저장하고 질의할 필요가 있는 대부분이 선택하는 도구가 되었다 +
transaction, batch 처리

=== NoSQL 의 탄생

원래는 오픈소스, 분산 환경, non RBDMS meetup 용 트위터 해시태그

**Not Only SQL** 로 재해석

NoSQL DB 채택의 이유?

* 대규모 데이터셋, 매우 높은 쓰기 처리량 달성을 RDBMS 보다 쉽게 할 수 있는 확장성 필요
* 상용 DB 제품보다 무료 오픈소스 소프트웨어에 대한 선호
* 관게형 모델에서 지원하지 않는 특수 질의 동작
* 관게형 스키마 제한에 대한 불만, 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

관계형, 비관계형을 함께 사용 - polyglot persistence

=== 객체 관계형 불일치

애플리케이션 코드 - DB 모델 객체 사이에 전환 계층이 필요하다 (impendance mismatch)

document-oriented DB 는 JSON 데이터 모델 지원 - MongoDB, RethinkDB, CouchDB, Espresso 등

=== many-to-one, many-to-many 관계

중복의 문제 +
의미 있는 정보는 한 곳에만 저장하고, 참조하는 모든 것은 ID 를 사용

중복 데이터 정규화 - many-to-one +
문서 모델에는 적합하지 않음. RDB 에서는 조인이 쉽지만 Document DB 에서는 조인이 약하다

DB 가 조인을 지원하지 않으면 다중 질의를 만들어서 애플리케이션 코드에서 조인을 흉내내야 한다

=== Document DB 는 역사를 반복하고 있나?

Document DB 와 NoSQL 에서 many-to-many 를 표현하는 제일 좋은 방법?

계층 모델: 간단, 모든 데이터를 레코드 내에 중첩된 레코드 트리로 표현, many-to-many join 이 안됨

계층 모델의 한계를 해결하기 위한 해결책들

==== 네트워크 모델

코다실 모델이라고도 함. 안쓰인다

계층 모델의 트리 구조에서 모든 레코드는 하나의 부모가 있는데, **네트워크 모델에서는 여러 개 가능**

FK 보다는 포인터와 비슷하다 +
레코드에 접근하는 방법은 접근 경로 - 최상위 레코드에서부터 연속된 연결 경로를 따르기

접근 경로를 따라 DB 끝에서 끝까지 커서를 움직여 수행 +
다중 부모인 경우 다양한 관계를 모두 추적해야 한다

제한된 하드웨어 성능을 효율적으로 사용할 수 있었지만 +
query, update 를 위한 코드가 복잡하고 유연하지 못한 문제

==== 관계형 모델

알려진 모든 데이터를 배치 +
관계 (테이블) = 튜플 (로우) 컬렉션

condition, all, one 읽기 +
다른 테이블 관계 없이 새 row insert 가능

query optimizer 가 query 의 어느 부분을 어떤 순서로 실행할지 결정, 사용할 index 를 자동으로 결정

==== Document DB 와의 비교

Document DB 는 계층 모델

many-to-one, many-to-many 은 RDB, Document DB 가 근본적으로는 다르지 않다 +
Unique ID 로 참조 (Foreign Key, document reference)

현재까지는 Document DB 가 코다실의 역사를 반복하진 않음

=== RDB 와 오늘날의 Document DB

데이터 모델의 차이점

Document DB - 스키마 유연성, 지역성 (더 나은 성능), 애플리케이션 데이터 구조와 가까움

==== 애플리케이션 코드를 더 간단하게 하는 데이터 모델?

데이터가 Document 와 비슷한 한 번에 전체 트리를 적재하는 구조 라면 Document 모델을 사용 +
여러 테이블로 나누어 찢는 (sherdding) 관계형 기법은 다루기 힘든 스키마, 불필요하게 복잡한 애플리케이션 코드 발생

Document 모델에서 중첩 항목은 바로 참조할 수 없다

비정규화로 조인을 줄일 수 있지만 비정규화된 데이터 일관성을 유지하기 위해 추가 작업을 해야 한다 +
Document 모델 사용하면서 애플리케이션 단에서 조인하는건 복잡한 코드, 나쁜 성능으로 이어질 수 있다

데이터 항목 간에 존재하는 관계 유형에 따라 데이터 모델을 선택

==== Document 모델에서 스키마 유연성

RDB, Document DB 에서 지원하는 JSON 은 스키마를 강요하지 않는다 +
= 임의 키/값을 추가할 수 있고 읽을 때 필드 존재 여부를 보장하지 않는다

애플리케이션에서 읽는 암묵적인 스키마가 있지만, Document DB 단에서는 강요하지 않는다

* schema-on-write: 명시적인 스키마, DB 는 스키마를 잘 따르고 있다
* schema-on-read: 암묵적인 스키마, 데이터를 읽을 때만 해석
** 데이터가 여러 다른 유형으로 구성되어 있을 때 유리

==== 질의를 위한 데이터 지역성

Document 는 JSON, XML 의 연속 문자열 or binary JSON, XML 로 저장

애플리케이션이 자주 전체 문서에 접근해야 할 때, 저장소 지역성 (storage locality) 을 활용한 성능 이점

(저장소 지역성???)

한 번에 문서의 많은 부분을 필요로 하는 경우에만 적용

Spanner, Oracle multi-table index cluster table, Bigtable column-family

==== Document DB 와 RDB 의 혼합

서로 부족한 부분을 보완해나가는 중이므로 해당 기능 사용