= 9. 보조 실천방법

기본 실천방법들을 완전히 하기 전에는 실행하기 어렵거나 위험한 것들

== 진짜 고객 참여 (Real Customer Involvement)

고객을 팀의 일원이 되게 하여 분기별 게획, 일주일별 계획에 참여할 수 있게

고객 참여의 핵심: 필요를 느끼는 사람들을 필요를 채워줄 수 있는 사람들과 직접 연결 시켜 노력의 낭비를 없애기

정확한 추정과 낮은 결함 비율로 대비가 되어 있다면 +
개발 프로세스 고객 참여는 신뢰 조성, 지속적인 개선을 북돋움

== 점진적 배치 (Incremental Deployment)

작은 기능이나 제한된 데이터 집합을 찾아 배포

== 팀 지속성 (Team Continuity)

효율적인 팀은 계속 함계 하도록 함

관계와 신뢰의 가치

사람을 마음대로 넣다 뺏다 할 수 있는 프로그래밍 단위로 보는 경향 +
프로젝트가 끝나면 인재 풀로 돌아가는 방식 +
허울뿐인 효율성은 추구하면서 신뢰의 가치는 무시

팀을 유지하되 구성원을 적정한 수준으로 회전하도록 장려 -> 안정된 팀이 내놓는 이익 + 지식과 경험이 꾸준히 전파되는 이익

== 팀 크기 줄이기 (Shrinking Teams)

작업량은 일정하게 유지하면서 점차 팀 크기를 줄이기 +
남은 사람으로 더 많은 팀을 만들 수 있다. 너무 적으면 다른 팀과 합침

== 근본 원인 분석 (Root-Cause Analysis)

결함이 발견될 때마다 결함과 그 원인을 모두 제거 +
같은 종류의 실수를 다시는 저지르지 않게 함

. 결함을 드러내는 시스템 차원의 자동화된 테스트 작성
. 결함을 재생산하는 가능한 범위가 좁은 단위 테스트 작성
. 단위 테스트가 통과하도록 시스템 수정
. 결함 해결 후 왜 이 결함이 생겼는지, 왜 이전에 잡히지 않았는지 알아내기

왜 문제가 발생했는지 다섯 번 묻기 +
예시) 왜 놓쳤나 -> 왜 몰랐나 -> 왜 우리 소속이 아닌가 -> 왜 다른 사람은 모르나 -> 왜 우선순위가 아닌가

== 코드 공유 (Shared Code)

팀 구성원 누구라도 언제든지 시스템의 어떤 부분이든 개선할 수 있다 +
시스템에 뭔가 문제가 생겼고 일의 범위를 벗어나지 않으면 고쳐야 한다

== 코드와 테스트 (Code and Tests)

오직 코드와 테스트만 영구 산출물로 유지. 문서들은 코드와 테스트에서 생성되도록 한다

== 단일 코드 기반 (Single Code Base)

코드 흐름은 하나여야 한다

여러 다발의 코드 흐름은 낭비를 낳는다 +
하나에서 고치면 다른 곳에서도 다 고쳐야 한다

코드 베이스가 여러 개면 수를 줄일 계획을 세운다

(브랜치가 될 수도 있고, 레포가 될 수도 있고..)

== 매일 배치 (Daily Deployment)

매일 밤 새로운 소프트웨어를 제품으로 내놓기

코드와 배포 버전 사이의 간격은 위험하다

이걸 하기 전에 먼저 해야 할 것들이 많다 +
낮은 결함 비율, 빌드/배포 도구 자동화, 롤백 플랜, 신뢰도, ...

장애물: 비용이 적게 드는 배치 방법 찾기, 심리적/사회적 문제, 요금 청구

== 범위 협상 계약 (Negotiated Scope Contract)

계약 작성 시 시간, 비용, 품질은 확정하나 시스템의 정확한 범위는 계속 협상하자고 요청 +
짧은 계약 여러 개를 여러 번에 걸쳐 서명 -> 위험도 낮추기

== 사용별 지불 (Pay-Per-Use)

시스템이 사용될 때마다 돈을 청구

돈의 흐름을 개발에 직접 연결하면 개선을 이끌어갈 정확하고 시기적절한 정보를 얻을 수 있음

릴리즈마다 돈 지불하는 방식은 이해관계가 충돌 +
릴리즈마다 돈을 내게 할 정도만 새로운 기능을 추가 -> 릴리즈를 많이 만들어 낼 이기적인 동기

구독 모델의 경우 개발팀은 최소한 유지 비율 (지속적인 구독 고객 수) 을 팀이 얼마나 잘 하는지 판단하는 정보의 원천