= 7. 기본 실천방법

== 함께 앉기 (Sit Together)

팀 전체가 들어가기 충분한 열린 공간에서 개발

== 전체 팀 (Whole Team)

프로젝트 성공을 위해 필요한 기술과 시야를 지닌 사람들을 전부 팀에 포함 +
어떤게 중요해진다면 그걸 지닌 사람을 데려오고, 필요 없다면 다른 곳으로 이동

팀이 일체라는 느낌을 주고, 필요한 모든 자원을 쉽게 이용할 수 있도록 만들겠다

팀에 속한다는 느낌이 필요하다

* 우리는 소속되어 있다
* 우리는 이 안에 함께 있다.
* 우리는 서로의 작업, 성장, 배움을 돕는다.

=== 이상적인 팀 규모?

* 12: 하루에 모두와 편안하게 의사소통할 수 있는 수
* 150: 한 사람이 모든 팀원의 얼굴을 기억할 수 없다
* 규모가 클 경우 여러 팀으로 구성된 팀이 해결할 수 있도록 하면 좋을 것

== 정보를 제공하는 작업 공간 (Informative Workspace)

작업 공간을 작업에 대한 것으로 채움

장점?: 진행 파악, 현재 문제에만 집중

스토리보드, 차트 +
(JIRA or Github projects 같은 느낌)

== 활기찬 작업 (Energized Work)

생산적으로 일할 수 있는 시간만, 일의 활력을 유지할 수 있는 시간만 일해라

소프트웨어 개발을 통찰력 싸움, 통찰력은 준비되고 잘 쉬고 긴장이 풀린 마음에서 생겨난다

== 짝 프로그래밍 (Pair Programming)

프로그램을 두 사람이 컴퓨터 하나에 앉아 작성

동시에 프로그래밍 (분석, 설계, 테스팅) 을 하면서 프로그램을 더 낫게 만드려고 노력하는 두 사람 사이의 대화

* 서로 일에 집중하도록 해줌
* 시스템을 더 좋게 하기 위해 브레인스토밍
* 떠오른 생각을 명료하게 다듬어 줌
* 한 사람이 막힐 때 주도권을 다른 사람에게 넘김
* 팀에서 지키기로 한 실천방법을 서로 책임지고 지키도록 함

짝은 자주 바꾸는게 좋다

=== 짝 프로그래밍과 개인적 공간

두 참여자가 모두 일을 잘 하려면 개인적 공간을 반드시 존중해주어야 한다

개인차를 존중하는 것이 중요

== 스토리 (Stories)

고객이 볼 수 있는 기능 단위로 계획 짜기

요구사항 (requirement) 이 아닌 스토리 +
요구사항 = 필수적이거나 강제적인 무엇

일찍 추정하기 - 사업과 기술적 시야가 상호 작용할 기회

짧은 글, 그림 + 이름을 달기. 인덱스카드에 적어 자주 다니는 벽에 붙임 +
예시 84p 그림

== 일주일별 주기 (Weekly Cycle)

한 번에 일주일 분량의 일을 계획 +
한 주를 시작하는 회의, 아래는 회의 내용

. 지금까지 진행된 상황 검토, 실제와 예상을 비교하여 어느 정도 달성했는지
. 이번 주에 구현할 일주일 분의 스토리를 고객이 고르도록 함
. 스토리를 여러 task 로 쪼갬. 팀 구성원들은 자기가 할 과업에 서명 및 추정

스토리들이 완성된 경우 (완료가 아니라 생성이 완성된 경우) 자동화 테스트를 작성하는 것으로 한 주를 시작 (85p) +

스토리를 쪼개 개인이 책임, 직접 추정하는 task 들로 만들기

== 분기별 주기 (Quaterly Cycle)

한 번에 한 분기 분량의 일을 계획 +
분기마다 한 번씩 팀, 프로젝트, 프로젝트의 진행 정도, 목표와 현재 방향 일치 여부 확인

* 병목, 특히 외부 병목을 찾아보기
* repair 작업 시작 - 회고 느낌인 듯?
* 이번 분기의 theme 을 계획
* theme 을 다룰 한 분기 분량의 스토리 고름
* 프로젝트가 조직에서 차지하는 위치라는 큰 그림에 초점을 맞춘다

스토리가 더 큰 그림에서 어떤 위치를 차지하는지 고려해야 함 +
일의 세부사항에만 초점을 맞추는 경향을 맞서기 위함

== 여유 (Slack)

일정에 뒤쳐질 경우 포기할 수 있는 덜 중요한 (급하지 않은) task 들을 계획에 포함시켜라

어떤 작업을 완수하는 데 걸릴 시간이 어느 정도인지 정확히 말해주고, 그만큼의 시간만 허용하라

== 10분 빌드 (Ten-Minute Build)

10분 만에 자동으로 전체 시스템을 빌드하고 모든 테스트를 돌려라 +
10분 보다 오래 걸리면 실행하는 횟수가 줄고, 피드백을 받을 기회를 놓친다

== 지속적 통합 (Continuous Integration)

변경한 것은 두세 시간 만에 통합하고 테스트

*동기적 방식이 좋다*

빌드 완료, 테스트 정상 확인 후 계속 일을 진행 +
자동으로 생기는 반성의 시간 (컴파일러가 끝나고 테스트가 도는 시간 = 막 끝낸 일을 어떻게 했더라면 더 잘 할 수 있었을까 이야기할 시간) +
짧고 분명한 피드백 주기를 만든다

== 테스트 우선 (Test-First Programming)

코드를 한 줄이라도 변경하기 전에, 일단 실패하는 자동화된 테스트를 먼저 작성

아래와 같은 문제를 동시에 해결

* 늘어나는 범위 - '혹시 모르니까' 코드를 작성하기 쉬움. 무엇을 해야하는지 명시적이고 객관적으로 밝혀 두면 초점을 잃어버리지 않는다. 기능을 넣고 싶으면 일단 테스트 통과 후 다른 테스트 작성
* 결합도와 응집성 - 테스트를 작성하기 어려우면 설계에 문제가 있는 신호. 결합도 낮고 응집성 높은 코드는 테스트가 쉽다
* 신뢰 - 테스트로 의도를 드러내면 신뢰적
* 리듬 - 무엇을 해야 할 지 길을 읽고 헤매는 일 -> 테스트로 우선 프고그래밍을 하면 다음에 무슨 일을 해야할지가 더 분명해진다

지속적인 테스팅 - 프로그램에 변화가 생길 때마다 테스트들이 돌아간다

테스트 우선으로 작성된 테스트들은 프로그램을 미시적 관점에서 보는 한계가 있다 +
테스트 안에 재보증 (reassurance) 들을 채워 넣을 수 있다

== 점진적 설계 (Incremental Design)

시스템의 설계에 매일 투자 +
시스템의 설계가 그 시점에 시스템이 필요로 하는 것에 훌륭하게 들어맞도록

설계 투자를 유지해가라

설계를 개선할 부분을 어떻게 찾을지? -> 중복 제거 등