== 1. 패턴을 이용한 통합 문제 해결

=== SOA (Service-Oriented Architecture)

* 서비스 = 공유 비즈니스 기능 = 특정 기능을 한 번만 구현하여 다른 시스템에 노출
** 보편적으로 사용 가능하고, 서비스 요청자의 요청에 응답하는 잘 정의된 기능
*** 서비스들의 관리 -> Service-Oriented Architecture
.... 서비스 디렉토리 (= 서비스들의 중앙 집중화한 목록) *(discovery)*
.... 서비스는 애플리케이션이 서비스와 통신 계약을 협상할 수 있는 인터페이스 방법을 기술 *(negotiation)*

[NOTE]
====
단일 비즈니스 트랜잭션이 여러 시스템에 분산되어 있다 +
-> 애플리케이션들 간에 조정 (coordination) 하는 기능을 하는 비즈니스 프로세스 관리 컴포넌트가 필요하다
====

=== Loose Coupling

* 핵심원리: 두 당사자가 정보를 교환할 때 서로에 대한 가정을 최소화한다

==== Tight Coupling
* 전형적인 예: 로컬 메소드 호출
** 동일한 프로세스 및 언어, 정확한 개수의 파라미터, 즉각적인 호출 및 처리
** 보안 위협이 없음, 유연성 및 재사용성을 높임

* 원격 통신을 로컬 메소드 호출처럼 보이게 하는 접근법을 사용했음
** RPC (Remote Procedure Call), RMI (Remote Method Invocation)
*** COBRA, MS DCOM, .NET Remoting, JAVA RMI, RPC
*** 긍정적인 면
**** 개발자가 동기 메소드 호출의 의미를 잘 알고 있음
**** 배포할 때까지 컴포넌트 실행을 로컬에서 할지, 원격에서 할지 실행 위치의 결정을 미룰 수 있음
*** 문제
**** 로컬 메소드 호출의 많은 가정을 실질적으로 무효화함
***** 원격 호출이 느린 겨우는 완료될 때까지 기다려야하는가? 연결할 수 없으면 얼마나 기다리는가? 보안 문제 등
** 요약: 사서 고생이다

=== 간단한 EAI 예시
웹 - 금융 시스템 통합

==== TCP/IP 프로토콜을 이용하여 연결하자
* 문제점
.. 플랫폼 기술: 숫자와 객체의 내부 표현
*** `+BitConverter+` 의 사용 (byte array 로 변환)
**** .NET 은 32 bit, 다른 시스템은 64 bit 를 사용할 수 있음
*** 시스템 별로 big-endian, little-endian 포맷으로 숫자 저장
.. 위치: 하드코딩된 시스템 주소
*** 코드에 원격 컴퓨터의 위치 (finance.bank.com) 을 저장
**** 이 기능을 도메인이 다른 별개의 컴퓨터로 이동시킨다면?
**** 네트워크에 있는 특정 컴퓨터에 독립해 통신할 수 있는 방법을 찾아야 함
.. 시간: 모든 컴포넌트의 동시 가용
*** TCP/IP 에서 두 시스템 간에는 시간 의존성이 있음 (연결 지향 프로토콜 - 데이터 전송 전 연결부터 완성)
.. 데이터 포맷: 형식과 파라미터 목록의 일치

* 개선하기
.. 데이터 포맷: XML 포맷 (자기 기술적 self-describing)
.. 위치: 채널 (발신자와 수신자가 서로 정체를 모르고도 공유할 수 있는 logical address)
*** 전송 요청을 큐에 담도록 채널 기능 확장 -> 시간 의존성 제거 가능
*** 요청 -> 독립적인 메시지로 쪼개져서 큐에 보관
*** 채널 내부에서 데이터 포맷의 변환을 지원하면 데이터 포맷 의존성도 제거 가능

* 느슨한 결합
** 장점: 시스템 사이 종속성을 제거하면 변경에 더 큰 저항력을 가짐
** 단점: 복잡성이 증가, 메시지 지향 미들웨어 인프라 사용