# 14. 모델의 무결성 유지

대규모 시스템의 도메인을 단일화하는건 타당하지 않거나 비용 대비 효과적이지 않을 것

복수 모델에 대한 거부감
- 여러 개의 모델 때문에 통합이 제한되고, 의사소통이 어려워져 발생하는 비용
- 여러 모델이 세련되보이지 않게 보일 수 있음

여러 모델 간의 경계와 관계를 표시해줄 수단

![image](https://user-images.githubusercontent.com/10507662/130462549-0f061311-2a8f-402b-8788-fbcd4924c050.png)

> CONTEXT MAP - 프로젝트의 컨텍스트와 각 컨텍스트 간의 관계의 전체적인 개관 제공  
> BOUNDED CONTEXT - 각 모델의 범위 정의  
> CONTINOUS INTEGRATION - 모델의 단일화 유지

## BOUNDED CONTEXT
무엇을 공유하고 무엇을 공유하지 않을지 명시하는 경계

개별적인 모델로 작성된 코드가 섞이면
- 많은 버그, 신뢰성 하락, 이해하기 힘든 소프트웨어, 구성원 간 의사소통 혼란
- 어떤 컨텍스트에서 어떤 모델을 사용해서는 안 되는지 불분명

### 모델은 컨텍스트에 적용
- 컨텍스트: 코드의 특정 부분 or 개별 팀이 수행하는 업무
- 회의를 거친 모델 -> 대화로 컨텍스트를 국한
- 모델 컨텍스트: 모델에서 사용된 용어를 특정한 의미로 의사소통하기 위한 조건의 집합

### 모델이 적용되는 컨텍스트를 명시적으로 정의
- 컨텍스트의 경계를 `팀, 애플리케이션의 특정 부분 사용법, 코드 기반, DB schema` 와 같은 **물리적인 형태**로 명시적으로 설정
- 경계 내에서는 모델을 일관된 상태로 유지, 바깥 이슈로 혼란스러워지면 안됨

팀 구성원이 어떤 부분에서 일관성을 갖고, 다른 context 와 어떤 식으로 관련되어 있는가를 명확하게 이해할 수 있게 **모델 적용 범위 제한**

서로 다른 컨텍스트에서는 용어, 개념과 규칙, UL 에 포함된 dialect 에 차이를 보이는 서로 다른 모델 적용

경계 정의 -> 영역 내 모델을 순수하게 유지 + 다른 context 로 초점을 옮길 때 혼란을 피할 수 있음

여러 경계에 걸친 통합에는 어느 정도의 translation 수반 (translation 은 context 밖, 경계의 일부에 있다)

> BOUND CONTEXT 은 MODULE 이 아니다

#### 예제
BOUNDED CONTEXT: 예약

화물추적 시스템은 translation 을 통해 연동

화물선 운항 일정 관리는 BOUNDED CONTEXT 로 일하고 있는 것이 아님. SHARED KERNEL 이 대안

### BOUNDED CONTEXT 내 균열 인식
CI 프로세스가 문제점을 발견하는데 도움. 초기에는 언어 혼동

구분되는 요소를 결합할 경우
- duplicate concepts (중복 개념)
  - 같은 개념을 나타내는 2개의 모델 요소가 존재
- false cognates (허위 어원)
  - 같은 용어를 사용하는 두 사람이 서로 다른 것을 이야기하고 있다고 생각

## CONTINUOUS INTEGRATION
모델 단편화의 가능성, 시스템을 작은 CONTEXT 로 분할하면 통합과 응집성을 잃게 될 수 있음

규모와 상관없이 통합된 시스템을 개발하기 위함
- 내부적으로 균열이 발생할 때 빠르게 포착하고 정정할 수 있게 **컨텍스트 내의 모든 작업을 병합하여 일관성을 유지**
- UL 을 다듬고, 모델 균열을 조기에 드러내는 체계적인 merge/build/test 프로세스를 토대로 통합
- 통합을 위한 프로세스
  - 단계적이고 재생성이 가능한 merge/build
  - 자동화된 테스트 suite
  - 통합되지 않은 변경점 유지에 대해 적당한 최소 시간을 설정하는 규칙 (머지 기한 설정?)

자동화된 테스트 + 구현 산출물을 merge 하는 프로세스 수립 + 끊임없는 UL 사용

CI 는 오직 하나의 BOUNDED CONTEXT 내에서만 필수적? -> translation 을 비롯한 인접한 context 와 관련된걸 똑같은 수준으로 다룰 필요는 없음  
(외부 연동은 CI 가 필요 없다는건가)

여러 BOUNDED CONTEXT 가 존재한다면 그 간의 관계를 결정하고 필요한 인터페이스를 설계해야 함

## CONTEXT MAP
BOUNDED CONTEXT 로는 전체를 볼 수 없음

다른 팀에선 CONTEXT 간 경계 인식 못함 -> CONTEXT 경계를 흐리게 하거나 or 연결되는 방식을 복잡하게 바꿈 (서로에게 스며듦)

CONTEXT MAP 은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸친 개념

#### 프로젝트 상에 사용되는 모델 식별 + 각 BOUNDED CONTEXT 정의 (비 객체지향적인 하위 시스템에 대한 암시적인 모델 포함)  
각 BOUNDED CONTEXT 에 이름 부여 + UL 의 일부로 포함

#### 의사소통을 위해 컨텍스트 간 - 번역에 대한 윤곽을 명확하게 표현 + 공유해야 하는 정보 강조 => 경계 지점 서술

#### 컨텍스트의 현재 영역을 나타내는 지도 작성

MAP 은 BOUNDED CONTEXT 의 명확한 이름을 제공해야 하고, 경계와 경계 특성을 명확하게 표현

CONTEXT MAP 은 항상 현재 상태 그대로의 상황을 표현

균열을 발견했다면 -> 지도에 모른다고 적고 서술 중단 -> 전체적인 뷰를 보고 혼란스러운 지점 설명

#### 예제
Booking (예약) CONTEXT 와 Transport Network (운송망) 의 CONTEXT 간의 번역을 수행하는 Booking-Transport Network Translator

![image](https://user-images.githubusercontent.com/10507662/130636275-9f34576b-c9bd-432a-a8d5-761179782a90.png)

> 이게 CONTEXT MAP 을 그린건가?

### 테스트가 중요하다
경계에 존재하는 번역의 미묘한 차이와 의사소통을 보완하는데 기여

통제할 수 없는 모델을 다룰 때 안심할 수 있음

### CONTEXT MAP 의 조직화와 문서화
1. BOUNDED CONTEXT 의 이름은 그 자체에 대해 말할 수 있어야 함. UL 에 들어가야 함
2. 모든 사람들이 경계가 어디에 위치하는지 알아야하고, 어떠한 CONTEXT 도 인식할 수 있어야 함

팀 구성원이 모두 동일하게 개념적 경계를 이해하도록 의사소통을 활발히 하는게 필요 (위에 그림과 같은 간단한 다이어그램을 활용하는 등)

## SHARED KERNEL
기능 통합에 한계가 있는 경우 CI 비용이 너무 높을 수 있음  
\+ CI 를 유지할 수 있는 기술, 조직이 갖춰지지 않거나 규모가 너무 큰 경우

CI 를 적용했을 때보다 더 많은 시간을 번역 계층을 개발하고 구조를 개선하는데 허비 + UL 구축 작업이 중복되고 UL 로 얻을 수 있는 이점을 잃어버릴 때

### 정리
- 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 명시 (+ 연관 코드 + DB 설계의 부분집합 포함)
  - 공유하는 부분들은 특별한 상태를 가지며, 다른 팀과 협의 없이는 변경할 수 없음
- 기능적인 시스템을 자주 통합하는데, CI 빈도보다는 적은 빈도로 통합
  - 통합할 때는 양 팀에서 작성한 테스트를 모두 실행

변경 시 양 팀에서 작성한 모든 테스트를 통과해야함  
KERNEL 의 복사본을 변경하고, 주기적으로 다른 팀의 복사본과 자신의 복사본을 통합

대부분 CORE DOMAIN 이거나, GENERIC SUBDOMAIN 의 일부 or 양쪽 모두  
두 팀에 모두 필요한 부분이라면 모델의 어떤 부분이라도 SHARED KERNEL 이 될 수 있다  
중복을 줄이고 두 하위 시스템 간의 통합을 용이하게 만드는 것이 목적

## CUSTOMER/SUPPLIER DEVERLOPMENT TEAM
의존성이 단방향, 번역도 한 방향으로 하는게 좋음  
자연스럽게 2개의 BC 로 나뉨

upstream 은 자유롭게 개발을 진행하는 데 downstream 에 속박당할 수 있음 + downstream 이 잘못될 수 있어 개발 자체 억제  
downstream 은 upstream 의 우선순위에 의존되므로 무력해질 수 있음

### 정리
- 명확한 CUSTOMER/SUPPLIER 관계 확립 - (upstream/downstream)  
downstream 에 대한 작업 협상을 통해 모든 사람들이 일정과 약속을 이해할 수 있게
- 결과로 예상되는 인터페이스를 검증할 인수 테스트를 같이 개발  
upstream 의 test suite 에 추가해서 CI 일부로 실행
  - (인터페이스를 정의해둔) 테스트 라이브러리를 공유해야하는건가? -> 근데 이건 SHARED KERNEL 이어서 아닌 것 같고 어떻게 하는건지


1. CUSTOMER 의 요구사항이 가장 중요하다
2. upstream 이 downstream 에 관계 없이 코드를 수정하고, downstream 이 upstream 을 의식하지 않고도 작업할 수 있는 test suite 가 필요

## CONFORMIST
(준수자)

upstream 이 원하는대로 안 해주는데 downstream 에서는 거기서 더 기능이 더 필요한 경우

1. upstream 에서 제공하는 기능의 사용 포기 (SEPERATE WAYS)
    - 근데 이게 되나?
2. 캡슐화, 추상화 상태가 안 좋은 등의 상태 -> downstream 의 자체적인 모델 생성
    - 번역 계층 + 유지보수 필요 (ANTICORRUPTION LAYER)
3. (CONFORMIST) 품질이 괜찮다면 독립적인 모델을 포기하고 upstream 의 모델을 무조건 따름
    - BC 간의 번역 복잡도 제거
    - 설계가 upstream 에 속박되고, 이상적인 모델은 못 만들지만 통합은 단순해짐
    - SUPPLIER 와 UL 공유

## ANTICORRUPTION LAYER
다른 시스템 연동을 위한 새로운 모델이 다른 시스템의 모델과 유사해져, 새로운 모델의 의도가 전체적으로 매몰될 수 있다  
레거시 모델은 취약하고 잘 설계되어도 필요에 적합하지 않은 경우가 대부분

### 정리
- 클라이언트 고유의 도메인 모델 측면에서 기능을 제공할 수 있는 격리 계층을 만들어라  
- 격리 계층은 기존에 이미 존재하는 인터페이스를 거쳐 다른 시스템과 통신  
- 필요에 따라 두 모델 (내부 모델, 외부 모델) 을 양방향으로 번역 수행  
- 개념적인 객체와 행위를 하나의 모델과 프로토콜에서 다른 모델과 프로토콜로 변환하기 위한 메커니즘

service model -> dao model 변환 개념인가?

### 설계
SERVICE 의 집합으로 표현

두 시스템 간 번역을 담당하는 새로운 계층을 구축하다보면..
- 외부 시스템의 행위를 새로 추상화
- 외부 시스템의 서비스와 정보를 현재 모델에 일관성 있게 제공할 기회를 얻음

외부 시스템을 모델 내에 단일 컴포넌트로 표현하는건 불가능  
모델 관점에서 응집력있는 책임을 맡는 여러 SERVICE 를 사용하는게 최선

### 구현
FACADE, ADAPTER, Translator 를 조합

#### FACADE
하위 시스템에 대한 클라이언트의 접근을 단순화, 더 쉽게 하위 시스템을 사용할 수 있게 만드는 인터페이스

다른 시스템의 모델에 따라 엄격하게 작성해야 함

#### ADAPTER
다른 프로토콜을 클라이언트에서 사용하게 해주는 wrapper

클라이언트에서 ADAPTER 에 메시지를 전송하면 응답이 변환되어 adaptee 로 전송됨

SERVICE 에는 SERVICE 의 인터페이스를 지원하고,  
다른 시스템이나 해당 시스템의 FACADE 에 상응하는 요청을 수행하는 법을 알고 있는 ADAPTER 가 필요

