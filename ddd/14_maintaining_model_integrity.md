# 14. 모델의 무결성 유지

대규모 시스템의 도메인을 단일화하는건 타당하지 않거나 비용 대비 효과적이지 않을 것

복수 모델에 대한 거부감
- 여러 개의 모델 때문에 통합이 제한되고, 의사소통이 어려워져 발생하는 비용
- 여러 모델이 세련되보이지 않게 보일 수 있음

여러 모델 간의 경계와 관계를 표시해줄 수단

![image](https://user-images.githubusercontent.com/10507662/130462549-0f061311-2a8f-402b-8788-fbcd4924c050.png)

> CONTEXT MAP - 프로젝트의 컨텍스트와 각 컨텍스트 간의 관계의 전체적인 개관 제공  
> BOUNDED CONTEXT - 각 모델의 범위 정의  
> CONTINOUS INTEGRATION - 모델의 단일화 유지

## BOUNDED CONTEXT
무엇을 공유하고 무엇을 공유하지 않을지 명시하는 경계

개별적인 모델로 작성된 코드가 섞이면
- 많은 버그, 신뢰성 하락, 이해하기 힘든 소프트웨어, 구성원 간 의사소통 혼란
- 어떤 컨텍스트에서 어떤 모델을 사용해서는 안 되는지 불분명

### 모델은 컨텍스트에 적용
- 컨텍스트: 코드의 특정 부분 or 개별 팀이 수행하는 업무
- 회의를 거친 모델 -> 대화로 컨텍스트를 국한
- 모델 컨텍스트: 모델에서 사용된 용어를 특정한 의미로 의사소통하기 위한 조건의 집합

### 모델이 적용되는 컨텍스트를 명시적으로 정의
- 컨텍스트의 경계를 `팀, 애플리케이션의 특정 부분 사용법, 코드 기반, DB schema` 와 같은 **물리적인 형태**로 명시적으로 설정
- 경계 내에서는 모델을 일관된 상태로 유지, 바깥 이슈로 혼란스러워지면 안됨

팀 구성원이 어떤 부분에서 일관성을 갖고, 다른 context 와 어떤 식으로 관련되어 있는가를 명확하게 이해할 수 있게 **모델 적용 범위 제한**

서로 다른 컨텍스트에서는 용어, 개념과 규칙, UL 에 포함된 dialect 에 차이를 보이는 서로 다른 모델 적용

경계 정의 -> 영역 내 모델을 순수하게 유지 + 다른 context 로 초점을 옮길 때 혼란을 피할 수 있음

여러 경계에 걸친 통합에는 어느 정도의 translation 수반 (translation 은 context 밖, 경계의 일부에 있다)

> BOUND CONTEXT 은 MODULE 이 아니다

#### 예제
BOUNDED CONTEXT: 예약

화물추적 시스템은 translation 을 통해 연동

화물선 운항 일정 관리는 BOUNDED CONTEXT 로 일하고 있는 것이 아님. SHARED KERNEL 이 대안

### BOUNDED CONTEXT 내 균열 인식
CI 프로세스가 문제점을 발견하는데 도움. 초기에는 언어 혼동

구분되는 요소를 결합할 경우
- duplicate concepts (중복 개념)
  - 같은 개념을 나타내는 2개의 모델 요소가 존재
- false cognates (허위 어원)
  - 같은 용어를 사용하는 두 사람이 서로 다른 것을 이야기하고 있다고 생각

## CONTINUOUS INTEGRATION
모델 단편화의 가능성, 시스템을 작은 CONTEXT 로 분할하면 통합과 응집성을 잃게 될 수 있음

규모와 상관없이 통합된 시스템을 개발하기 위함
- 내부적으로 균열이 발생할 때 빠르게 포착하고 정정할 수 있게 **컨텍스트 내의 모든 작업을 병합하여 일관성을 유지**
- UL 을 다듬고, 모델 균열을 조기에 드러내는 체계적인 merge/build/test 프로세스를 토대로 통합
- 통합을 위한 프로세스
  - 단계적이고 재생성이 가능한 merge/build
  - 자동화된 테스트 suite
  - 통합되지 않은 변경점 유지에 대해 적당한 최소 시간을 설정하는 규칙 (머지 기한 설정?)

자동화된 테스트 + 구현 산출물을 merge 하는 프로세스 수립 + 끊임없는 UL 사용

CI 는 오직 하나의 BOUNDED CONTEXT 내에서만 필수적? -> translation 을 비롯한 인접한 context 와 관련된걸 똑같은 수준으로 다룰 필요는 없음  
(외부 연동은 CI 가 필요 없다는건가)

여러 BOUNDED CONTEXT 가 존재한다면 그 간의 관계를 결정하고 필요한 인터페이스를 설계해야 함

## CONTEXT MAP
BOUNDED CONTEXT 로는 전체를 볼 수 없음

다른 팀에선 CONTEXT 간 경계 인식 못함 -> CONTEXT 경계를 흐리게 하거나 or 연결되는 방식을 복잡하게 바꿈 (서로에게 스며듦)

CONTEXT MAP 은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸친 개념

#### 프로젝트 상에 사용되는 모델 식별 + 각 BOUNDED CONTEXT 정의 (비 객체지향적인 하위 시스템에 대한 암시적인 모델 포함)  
각 BOUNDED CONTEXT 에 이름 부여 + UL 의 일부로 포함

#### 의사소통을 위해 컨텍스트 간 - 번역에 대한 윤곽을 명확하게 표현 + 공유해야 하는 정보 강조 => 경계 지점 서술

#### 컨텍스트의 현재 영역을 나타내는 지도 작성

MAP 은 BOUNDED CONTEXT 의 명확한 이름을 제공해야 하고, 경계와 경계 특성을 명확하게 표현

CONTEXT MAP 은 항상 현재 상태 그대로의 상황을 표현

균열을 발견했다면 -> 지도에 모른다고 적고 서술 중단 -> 전체적인 뷰를 보고 혼란스러운 지점 설명

#### 예제
Booking (예약) CONTEXT 와 Transport Network (운송망) 의 CONTEXT 간의 번역을 수행하는 Booking-Transport Network Translator

![image](https://user-images.githubusercontent.com/10507662/130636275-9f34576b-c9bd-432a-a8d5-761179782a90.png)

> 이게 CONTEXT MAP 을 그린건가?

### 테스트가 중요하다
경계에 존재하는 번역의 미묘한 차이와 의사소통을 보완하는데 기여

통제할 수 없는 모델을 다룰 때 안심할 수 있음

### CONTEXT MAP 의 조직화와 문서화
1. BOUNDED CONTEXT 의 이름은 그 자체에 대해 말할 수 있어야 함. UL 에 들어가야 함
2. 모든 사람들이 경계가 어디에 위치하는지 알아야하고, 어떠한 CONTEXT 도 인식할 수 있어야 함

팀 구성원이 모두 동일하게 개념적 경계를 이해하도록 의사소통을 활발히 하는게 필요 (위에 그림과 같은 간단한 다이어그램을 활용하는 등)

## SHARED KERNEL
기능 통합에 한계가 있는 경우 CI 비용이 너무 높을 수 있음  
\+ CI 를 유지할 수 있는 기술, 조직이 갖춰지지 않거나 규모가 너무 큰 경우

CI 를 적용했을 때보다 더 많은 시간을 번역 계층을 개발하고 구조를 개선하는데 허비 + UL 구축 작업이 중복되고 UL 로 얻을 수 있는 이점을 잃어버릴 때

### 정리
- 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 명시 (+ 연관 코드 + DB 설계의 부분집합 포함)
  - 공유하는 부분들은 특별한 상태를 가지며, 다른 팀과 협의 없이는 변경할 수 없음
- 기능적인 시스템을 자주 통합하는데, CI 빈도보다는 적은 빈도로 통합
  - 통합할 때는 양 팀에서 작성한 테스트를 모두 실행

변경 시 양 팀에서 작성한 모든 테스트를 통과해야함  
KERNEL 의 복사본을 변경하고, 주기적으로 다른 팀의 복사본과 자신의 복사본을 통합

대부분 CORE DOMAIN 이거나, GENERIC SUBDOMAIN 의 일부 or 양쪽 모두  
두 팀에 모두 필요한 부분이라면 모델의 어떤 부분이라도 SHARED KERNEL 이 될 수 있다  
중복을 줄이고 두 하위 시스템 간의 통합을 용이하게 만드는 것이 목적

## CUSTOMER/SUPPLIER DEVERLOPMENT TEAM
의존성이 단방향, 번역도 한 방향으로 하는게 좋음  
자연스럽게 2개의 BC 로 나뉨

upstream 은 자유롭게 개발을 진행하는 데 downstream 에 속박당할 수 있음 + downstream 이 잘못될 수 있어 개발 자체 억제  
downstream 은 upstream 의 우선순위에 의존되므로 무력해질 수 있음

### 정리
- 명확한 CUSTOMER/SUPPLIER 관계 확립 - (upstream/downstream)  
downstream 에 대한 작업 협상을 통해 모든 사람들이 일정과 약속을 이해할 수 있게
- 결과로 예상되는 인터페이스를 검증할 인수 테스트를 같이 개발  
upstream 의 test suite 에 추가해서 CI 일부로 실행
  - (인터페이스를 정의해둔) 테스트 라이브러리를 공유해야하는건가? -> 근데 이건 SHARED KERNEL 이어서 아닌 것 같고 어떻게 하는건지

1. CUSTOMER 의 요구사항이 가장 중요하다
2. upstream 이 downstream 에 관계 없이 코드를 수정하고, downstream 이 upstream 을 의식하지 않고도 작업할 수 있는 test suite 가 필요

## CONFORMIST
(준수자)

upstream 이 원하는대로 안 해주는데 downstream 에서는 거기서 더 기능이 더 필요한 경우

1. upstream 에서 제공하는 기능의 사용 포기 (SEPERATE WAYS)
    - 근데 이게 되나?
2. 캡슐화, 추상화 상태가 안 좋은 등의 상태 -> downstream 의 자체적인 모델 생성
    - 번역 계층 + 유지보수 필요 (ANTICORRUPTION LAYER)
3. (CONFORMIST) 품질이 괜찮다면 독립적인 모델을 포기하고 upstream 의 모델을 무조건 따름
    - BC 간의 번역 복잡도 제거
    - 설계가 upstream 에 속박되고, 이상적인 모델은 못 만들지만 통합은 단순해짐
    - SUPPLIER 와 UL 공유

## ANTICORRUPTION LAYER
다른 시스템 연동을 위한 새로운 모델이 다른 시스템의 모델과 유사해져, 새로운 모델의 의도가 전체적으로 매몰될 수 있다  
레거시 모델은 취약하고 잘 설계되어도 필요에 적합하지 않은 경우가 대부분

### 정리
- 클라이언트 고유의 도메인 모델 측면에서 기능을 제공할 수 있는 격리 계층을 만들어라  
- 격리 계층은 기존에 이미 존재하는 인터페이스를 거쳐 다른 시스템과 통신  
- 필요에 따라 두 모델 (내부 모델, 외부 모델) 을 양방향으로 번역 수행  
- 개념적인 객체와 행위를 하나의 모델과 프로토콜에서 다른 모델과 프로토콜로 변환하기 위한 메커니즘

service model -> dao model 변환 개념인가?

### 설계
SERVICE 의 집합으로 표현

두 시스템 간 번역을 담당하는 새로운 계층을 구축하다보면..
- 외부 시스템의 행위를 새로 추상화
- 외부 시스템의 서비스와 정보를 현재 모델에 일관성 있게 제공할 기회를 얻음

외부 시스템을 모델 내에 단일 컴포넌트로 표현하는건 불가능  
모델 관점에서 응집력있는 책임을 맡는 여러 SERVICE 를 사용하는게 최선

### 구현
FACADE, ADAPTER, Translator 를 조합

#### FACADE
하위 시스템에 대한 클라이언트의 접근을 단순화, 더 쉽게 하위 시스템을 사용할 수 있게 만드는 인터페이스

다른 시스템의 모델에 따라 엄격하게 작성해야 함

#### ADAPTER
다른 프로토콜을 클라이언트에서 사용하게 해주는 wrapper

클라이언트에서 ADAPTER 에 메시지를 전송하면 응답이 변환되어 adaptee 로 전송됨

SERVICE 에는 SERVICE 의 인터페이스를 지원하고,  
다른 시스템이나 해당 시스템의 FACADE 에 상응하는 요청을 수행하는 법을 알고 있는 ADAPTER 가 필요

#### Translator
ADAPTER 가 하는 일은 요청 방법을 파악하는 것

개념 객체나 데이터의 실제 변환. 번역기는 ADAPTER 에 속함, 아무런 상태가 필요하지 않음

필요할 때 인스턴스화 되는 가벼운 객체일 수도

![image](https://user-images.githubusercontent.com/10507662/131360240-cec958f5-f476-4fab-8c27-d6dd41200716.png)

## SEPERATE WAYS
통합에는 비용이 많이 들고, 혜택이 적은 경우도 있음

BC 가 다른 것과 아무 관계 없이 범위 내에서 단순하고 특화된 해결책을 찾음

middleware 나 UI layer 에 기능을 구성할 수 있지만, 로직은 공유하지 않고 번역 계층을 거쳐 최소한의 데이터만 전송

## OPEN HOST SERVICE
여러 하위 시스템과 통합 할 때 각 번역기를 커스터마이징한다면 팀 전체가 교착 상태 (bog down) 가 될 수 있음

하위 시스템 접근과 관련된 프로토콜을 일련의 SERVICE 로 정의  
프로토콜을 공개해서 통합하고자 하는 모든 사람들이 해당 프로토콜을 사용할 수 있게 함  
특수한 요구사항은 일회성 번역기로 프로토콜 보강 -> 공유 프로토콜을 단순하고 일관되게 유지

다른 하위 시스템이 OPEN HOST 의 모델과 결합  
HOST 의 특정한 표현 방식: PUBLISHED LANGUAGE

## PUBLISEHD LANGUAGE
두 BC 모델 간에 이뤄지는 번역에 필요한 공통의 언어

필요한 도메인 정보를 표현할 수 있는 문서화된 공유 언어를 공통의 의사소통에 사용.  
이 언어로 혹은 이 언어로부터 번역 수행

## 모델의 컨텍스트 전략 선택
### 팀 의사결정 혹은 그 이상
BC 를 어디에 정의하고 BC 간 관계가 어떨지 결정

### 경계의 변형
BC 경계를 세우는 많은 상황과 선택사항

#### 규모가 큰 BC 가 선호되는 경우
- 작업 흐름이 단일화된 모델을 토대로 처리
- 2개 매핑보단 일관성 있는 하나의 모델
- 두 모델 간의 번역이 어려울 수 있을 때
- 공유 언어로 팀 의사소통이 명확해질 때

#### 규모가 작은 BC 가 선호되는 경우
- 개발자 간의 의사소통 부하 감소
- 소규모 팀과 코드 기반으로 CI 쉬워지는 경우
- 다양한 추상화 모델을 제공하기 힘든 기술이 필요할 때
- UL 의 특화된 방언과 전문적인 사용자 집단의 전문 용어를 포괄할 때

### 외부 시스템의 묘사를 변경할 수 없는 것을 인정

### 외부 시스템과의 관계
SEPERATE WAYS
  - 통합이 필요하지 않다면 SEPERATE WAYS 를 포함하지 않았을 것이다(???)

통합이 정말 필요하다면 CONFORMIST, ANTICORRUPTION LAYER 중 하나 선택
- CONFORMIST
  - 대형 시스템의 보조적인 확장 기능
  - CONTEXT 간 번역이 애플리케이션 기능보다 더 큰 일이 되는 경우 이게 나음
  - 확장에만 주력하고 기존 모델을 변경하면 안됨
- ANTICORRUPTION LAYER
  - 확장하는 것 보다 설계 중인 시스템의 기능이 더 복잡해질 경우 자체적인 BC

### 설계 중인 시스템
프로젝트 팀에서 구축하고 있는 소프트웨어

BC 선언, 내부에 CI 적용하여 BC 의 단일화 유지

규모가 커지만 SHARED KERNEL 을 찾아 개별 BC 로 분할  
-> 의존성이 한 방향이라면 CUSTOMER/SUPPLIER DEVELOPMENT TEAM

모델링 과정이 충돌한다면 SEPERATE WAYS 를 따르고 통합이 필요하면 => CI 의 단일 지점으로 번역 계층을 공동으로 개발 및 유지

### 개별 모델의 특수한 요구사항 충족하기
..

### 배치 (deployment)
보통 배포로 쓰는 그 의미가 맞을 듯

변경 시 서로 협업하여 함께 테스트한 버전을 출시  
코드 + 데이터 마이그레이션

SHARED KERNEL 은 개발 + 배포에서도 협업에 부담  
SEPERATE WAYS 로 단순해질 수 있음

### 타협점 (trade-off)
> 협업과 의사소통에 드는 비용 <-> 자연스러운 기능 통합이 주는 이점

이 사이에서 타협점

### 프로젝트가 이미 진행 중일 때
1. 현재 상태에 따라 BC 정의
2. CI 개선
3. 번역 코드를 ANTICORRUPTION LAYER 로 이동
4. 기존 BC 에 이름 부여하고 UL 에 속하게 함

## 변형 (Transformation)
BC 에 관한 결정을 변경하는 것

규모가 너무 커서 리팩토링 1번이나 iteration 으로는 못함

### SEPERATE WAYS -> SHARED KERNEL
번역 비용이 너무 클 때

#### 방법
두 CONTEXT 에서 중복되는 부분을 포함하는 규모가 작은 하위 도메인 선택
- 하나의 단위로 개발된 모델의 일관성 유지 하거나
- 한 번에 한 부분을 골라 두 모델에 맞는 결과를 맞는 식으로 진행 (??)

하위 도메인에 대한 공유 모델을 만들기 위해, 각 팀에서 차출
- 원래 모델에 비해 두 모델의 책임을 모두 담당할 수 있는 새로운 모델을 찾아냄

#### 후속
SHARED KERNEL 통합 -> 필요 없어진 번역 제거

### SHARED KERNEL -> CI
SHARED KERNEL 이 확장 중일 때, BC 를 단일화했을 때 얻을 수 있는 이점에 끌릴 수 있음

1. CI 에 필요한 권한 부여, 동일한 방식으로 업무 수행하도록 갖춤
2. 팀 간 인원 교류 시작
3. 모델 간 디스틸레이션 과정을 명확하게
4. 핵심 도메인을 SHARED KERNEL 에 시작
5. SHARED KERNEL 이 확장 -> 통합 빈도 늘림 -> CI 에 이름
6. SHARED KERNEL 이 기존 두 BC 를 포괄하면 CI 코드 기반을 갖춘 큰 하나의 팀 or 규모가 작은 두 팀(??)이 됨

### 레거시의 단계적 폐기
ANTICORRUPTION LAYER 를 거쳐 레거시와 소통하는 작은 최신 시스템으로 보완

1. 단일 iteration 내에 레거시 특정 기능 파악
2. ANTICORRUPTION LAYER 에 필요할 추가 사항 파악
3. 구현
4. 배포
5. ANTICORRUPTION LAYER 에서 불필요한 부분 파악해 제거
6. 레거시 모듈 삭제

### OPEN HOST SERVICE -> PUBLISHED LANGUAGE
접근을 원하는 시스템이 늘어나거나 상호작용이 이해하기 어려워지는 경우

1. 업계 표준 언어 사용
2. 1이 안되면 CORE DOMAIN 을 다듬는다 (15장)
3. CORE DOMAIN 을 교환 언어의 기반으로 사용하고, 표준 교환 패러다임 활용 (우리의 경우엔 OAI 가 될 듯)
4. 협업에 참여하는 사람들에 공유
5. 새 시스템 아키텍처가 있다면 같이 공유
6. 각 협업 시스템을 상대롭 ㅓㄴ역
7. 전환

PL 은 안정적이어야 함, 끊임없는 리팩토링을 하며 호스트 모델을 자유롭게 변경 가능  
교환 언어와 호스트 모델을 동일하게 보면 안됨