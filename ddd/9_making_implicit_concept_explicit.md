# 9장. 암시적인 개념을 명확하게

설계 상에 암시적으로 존재하는 개념을 인지하면  
도메인 모델과 관련 코드를 대량으로 변환 -> 하나 이상의 객체와 객체 간의 관계를 이용해 모델 내에 해당 개념을 명확하게 표현

## 개념 파헤치기

#### 잠재해 있는 암시적인 개념을 드러내는 단서에 민감해야 한다
- 팀에서 사용하는 언어를 주의깊게 경청
- 부자연스러운 부분과 모순되어 보이는 전문가의 견해를 면밀하게 검토
- 도메인과 관련된 문서를 조사하고 수없이 많은 실험을 해야 함
- (생각) 결국은 숨은 스펙 찾기?

### Listen to Language
- 모델에 기여하는 개념의 실마리
- 도메인 전문가가 사용하는 언어를 잘 듣고
  - 복잡하게 얽힌 개념을 간결하게 표현하는 용어가 있는지
  - 우리가 선택한 단어를 고쳐주는지
  - 특정 문구를 이야기할 때 도메인 전문가의 눈치가 어떠한지

### Scrutinize Awkwardness (어색한 부분을 조사)
누락된 개념이 있는지, 할당된 일부 책임이 어색한지

누락된걸 알아도 어떻게 풀어야 할지 감이 안 잡힐 때 -> 도메인 전문가가 발견하도록 함

### Contemplate Contradictions (모순에 대해 깊이 고민)
모순은 심층 모델에 이르는 주용한 단서로 활용될 수 있다
- 용어를 다르게 쓰는 데서 발생
- 도메인을 잘못 이해하는 데서 발생

모순은 흥미롭지 않고 심오한 내용을 암시하지도 않음  
-> 이런 사고를 거쳐 도메인의 심층적인 통찰력에 이를 수 있다

모든 모순을 해소하는 것은 불가능, 바람직하지도 않음 (14장에서 볼 예정)  
모순을 유지하는 상황에서 모순되는 양측의 주장을 모두 적용하는 과정 간에 숨겨져 있던 사실을 밝힐 수도 있다

### 책을 읽어라 (서적을 참고하라)
다양한 분야에 대해 근본 개념을 설명하는 책을 찾을 수 있음 (이자 수익 예제, Accural Basis Accounting)

다른 대안으로는 해당 도메인을 경험한 다른 소프트웨어 전문가의 책을 읽기

### Try, Try Again

## How to Model Less Obvious Kinds of Concepts
(불명확한 개념을 모델링하는 법)

### Explicit Constraints (명시적인 제약조건)
제약조건은 모델 개념에서 특별히 중요한 분야, 보통은 암시적인 상태 -> 명시적으로 표현하면 설계 개선 가능

#### 예시
제약조건을 별도의 메소드로 분리하고, 메소드 명에 의미를 분명하고 명확하게 표현

제약조건을 포함한 객체 설계가 잘못된 상태임을 확인하는 3가지 방법
1. 제약조건을 평가할 때 해당 객체에 적합하지 않은 데이터가 필요
2. 관련된 규칙이 여러 객체에 걸쳐 나타나고, 동일한 계층구조에 속하지 않는 객체 간 중복 or 상속 관계 강요
3. 설계와 요구사항은 제약조건에 맞춰지지만, 구현 단계에서는 절차적인 코드에 묻혀 명시적으로 표현되지 않음

### Processes as Domain Objects (도메인 객체로서의 프로세스)
모델 내에 프로세스를 표현해야 한다. 프로세스가 나타나면 객체를 어색하게 설계하게 된다

#### 알고리즘 자체 or 일부를 하나의 객체로 만들기
어떤 프로세스를 선택할 것인가 = 어떤 객체를 선택할 것인가  
각 객체는 STRATEGY 를 표현

## SPECIFICATION (명세)
#### 기존의 logic-programming
- predicate (true or false)
- 더 복잡한 규칙을 표현하기 위해 AND, OR 연산자로 결합
- 어떤건 너무 복잡하고, 어떤건 너무 단순함

업무 규칙이 Entity, Value object 의 책임에 맞지 않고, 규칙의 다양성 및 조합이 도메인 객체의 기본 의미를 압도할 때가 있음  
도메인 계층에서 분리하면, 도메인 코드가 더는 모델을 표현할 수 없어 안좋아짐

predicate 의 개념을 차용하여 Boolean 결과를 내는 특별한 객체 생성 -> 테스트 메소드가 독립적인 객체로 발전

![image](https://user-images.githubusercontent.com/10507662/128197964-2f2187db-067c-4164-8cce-1f71b7234b31.png)

### 정의
- 다른 객체에 대한 제약조건을 기술하는 새로운 객체
- 특별한 목적을 위해 술어와 유사한 명시적인 VALUE OBJECT
  - 생성 -> 테스트 -> 제거
  - Invoice 예시에선 평가 일자를 specification 안에 명시할 수 있음
- (생각) 실제 저장되진 않는 Value object?, static 으로 만들면 안되는건가
  - polymorphic 을 위해 VO 로 만드는 듯

specification 을 이용하여 규칙을 도메인 계층에 유지할 수 있음

### 적용과 구현
객체의 상태를 3가지 목적으로 명시
1. validation: 어떤 요건을 충족시키거나, 특정 목적으로 사용할 수 있는지 검증
2. selection: 컬렉션 내의 객체를 선택
3. building to order: 특정한 요구사항을 만족하는 새로운 객체 생성을 명시

### Validation
가장 단순한 용도. 개념을 직관적으로 설명해주는 방식

특정한 조건에 부합하는지 여부를 판단하기 위해 개별 객체를 테스트

interface 와 다양한 구현체에 대한 예시 (Invoice Specification)

### Selection
특정한 조건을 기반으로 객체 컬렉션 일부 선택

1. RDB 의 검색 기능을 활용하기 위한 쿼리문 생성 메소드 `asSQL()`
    - 테이블 구조가 Domain layer 에 노출됨
2. Repository 에 특정 쿼리문으로 명시 -> Specification 객체에서 해당 메소드를 실행하도록 repository 를 받아서 실행
    - 규칙을 Specification 에 모으지는 못했지만, 본질적인 규칙은 모아져있음
3. 일단 조건에 맞는걸 다 들고와서 -> Specification 의 메소드를 수행
    - 메모리 성능 저하

### Building to order (Generating)
아직 존재하지 않는 객체에 대한 기준 명시  
명시된 조건을 만족하는 객체나 객체 집합을 새로 만들어 내거나 재구성하는 것이 목적

서술적인 Specification 을 사용하여 Generator 의 인터페이스를 정의하면 생성할 결과물을 명시적으로 인터페이스에 포함할 수 있다 (?)

#### 장점
- Generator 구현을 인터페이스로부터 분리 (decouple)
  - 생성할 결과물에 대한 요구사항은 선언. 결과물을 생성하는 방법은 정의하지 않음
- 생성 규칙을 명시적으로 전달하므로 -> 세부 이해 없이도 결과물 예상 가능
- 단순히 Specification 에 포함된 조건에 따라 객체를 생성하여, 더 유연한 인터페이스 및 개선 가능
- Generator 에 대한 입력을 정의하는 방법이 모델에 포함되어 있어 테스트가 수월

WarehousePacker 는 Specification 인가? Generator 는 뭐지?
