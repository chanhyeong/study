== 9. 데이터 조직화

=== 변수 쪼개기 (Split Variable)

==== 배경

* 수집 변수 (collecting variable): 메소드가 동작하는 중간중간 값을 저장
* 코드 결과를 저장했다가 나중에 참조하기 위함 변수 등 (단순히 i += j 형태라면 쪼개면 안된다)
* 역할이 둘 이상인 변수 -> 쪼개라

==== 절차

. 변수를 선언한 곳, 대입하는 곳에서 변수명을 바꿈
. 가능하면 immutable
. 두 번째 대입하는 곳 앞까지 모든 참조를 새로운 변수명으로 바꿈
. 두 번째 대입 시 변수명을 원래 이름으로 다시 선언
. 테스트, 반복

=== 필드 이름 바꾸기 (Rename Field)

==== 절차

. 변경 범위가 적으면 접근하는 모든 코드를 수정 -> 테스트
. (1이 아니라면) 레코드 캡슐화
. 캡슐화된 객체의 private 필드명을 변경. 내부 메소드 수정
. 테스트
. 생성자의 매개변수 중 필드와 이름이 겹치면 함수 선언 바꾸기로 변경
. 접근자 이름도 바꿔줌

=== 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)

==== 배경

* 가변 데이터는 문제를 일으킬 여지가 많다
* 가변 데이터의 유효 범위를 가능한 좁혀야 한다

==== 절차

. 변수 값이 변경되는 지점을 모두 찾음. 필요하면 변수 쪼개기
. 해당 변수의 값을 계산해주는 함수 생성
. 해당 변수가 사용되는 모든 값에 assertion 추가하여 계산 결과 == 변수 값이 같은지 확인
. 테스트
. 읽는 코드를 함수 호출로 대체
. 테스트
. 변수 선언 후 변경 코드는 죽은 코드 제거하기로 없앰

=== 참조를 값으로 바꾸기 (Change Reference to Value)

==== 배경

* 데이터 구조를 중첩하면 내부 객체를 참조 or 값으로 취급할 수 있다
** 참조: 내부 객체는 그대로 두고 객체 속성만 갱신
** 값: 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체
* Value Object 는 immutable 이므로 필드 -> 값으로 바꾸면 자유롭게 활용하기 좋음

==== 절차

. 대상 클래스가 immtuable 인지, 혹은 될 수 있는지 확인
. setter 를 제거
** 아예 제거하는게 아니라, 해당 필드에 직접 set 하는 동작을 제거하고 value 필드를 set 하는거로
. 값 객체의 필드를 사용하는 equality 비교 메소드 생성

=== 값을 참조로 바꾸기 (Change Value to Reference)

==== 배경

* 많은 데이터를 갱신해야 할 때

==== 절차

. 같은 부류에 속하는 객체를 보관할 저장소를 만듦
. 생성자에서 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인
. 호스트 객체의 생성자들 수정 -> 필요한 객체를 이 저장소에서 찾도록 함

=== 매직 리터럴 바꾸기 (Replace Magic Literal)

* 특별한 의미를 갖는 숫자, 문자열 등

==== 절차

. 상수 선언, 매직 리터럴 대입
. 리터릴이 사용되는 모든 곳을 찾아서 똑같은 의미인지 확인, 같은 의미라면 상수로 대체. 테스트