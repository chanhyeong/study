== 2. 리팩토링 원칙

=== 정의

*소프트웨어의 동작 (observable behavior) 은 유지하고 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 (을 적용해서 재구성하다)*

재구성 (reconstructing): 코드베이스를 정리하거나 구조를 바꾸는 작업 (조금 더 포괄적인 개념)

* 리팩토링 과정에서 발견한 버그는 후에도 그대로 남아 있어야 한다 (???)
* 코드를 이해하고 수정하기 쉽게 만든다
** 성능은 좋아질 수도, 나빠질 수도 있다

=== two hats

* 기능 추가를 할 때는
** 기존 코드는 건드리지 않고 새 기능을 추가만 한다
** 진척도는 테스트 추가 -> 통과로 확인
* 리팩토링을 할때는
** 기능 추가는 절대 안하고 코드 재구성만 한다
** (누락된 케이스를 제외한) 테스트 추가 없다

=== 이유

==== 소프트웨어 설계가 좋아진다

* 코드의 구조를 지탱
* 중복 코드를 제거하면 -> 모든 코드가 언제나 고유한 작업임을 보장
* 리팩토링을 하지 않으면
** 소프트웨어 아키텍처가 썩기 쉽다
** 단기적 목표 달성을 위한 코드 수정 -> 기반 구조가 무너짐 -> 코드로 설계 파악이 어려움 -> 설계 유지 어려움 -> 설계 부패 속도 가속화

==== 소프트웨어를 이해하기 쉬워진다

* 코드를 잘 읽히게 도와준다
** 코드의 목적이 더 잘 드러나게 = 의도를 더 명확하게 전달하도록 개선

==== 버그를 쉽게 찾을 수 있다

* 코드가 하는 일을 파악하면서 새로 깨달은걸 반영

==== 프로그래밍 속도를 높일 수 있다

* 모듈화가 잘 되어 있으면 일부 코드베이스만 이해하면 됨
* 코드가 명확하면 버그를 만들 가능성이 줄고, 디버깅하기가 쉽다
* 한 시스템을 오래 개발
** 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다
** 기능을 추가하면 버그가 자주 발생하고 해결 시간이 오래걸린다
** 패치가 덧대어 지면서 동작 파악이 어려워진다

=== 언제 하는가?

.3의 법칙
----
1. 그냥 한다
2. 비슷한 일을 두 번째 하면, 일단 계속 진행한다
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다
----

==== 준비 (Preparatory) - 기능을 쉽게 추가하게 만들기

* 함수 매개변수화하기 [11.2]
** 중복 코드 제거 - 비슷한 기능인데 함수 다른걸 변수로 받아서 처리하는거로 합치기

==== 이해 (Comprehension) - 코드를 이해하기 쉽게 만들기

* 코드의 의도가 더 명확하게 드러나도록
** 조건부 로직의 구조가 이상하지 않은지, 함수 이름이 잘 정해져 있는지

==== 쓰레기 줍기 (Litter-Pickup)

* 간단히 수정할 수 있는건 바로
* 시간이 걸리면 메모만 남기고 나중에 처리

==== 계획해서 & 수시로

앞선 3가지는 기회가 될 때만

* 따로 리팩토링 시간을 잡지 않고 다른 일을 하는 중에 처리

[quote]
----
보기 싫은 코드를 발견하면 리팩토링. 그런데 잘 작성된 코드 역시 수많은 리팩토링을 거쳐야 한다
----

* 어제와 오늘의 리팩토링 기준이 다를 수 있다 -> 코드가 이미 깔끔하다면 더 쉽다

[quote]
----
무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자
----

* 계획된 리팩토링은 최소한으로 줄이고 수시로 해야한다
* VCS 에서 리팩토링 커밋과 기능 추가 커밋을 분리해야 한다?
** 저자는 완전히 동의하지는 않음 - 왜 그렇게 수정했는지 이해가 어려워짐
** 팀에 적합한 방식을 찾아내야 한다 - 사실 분리하는게 맞는거 같긴 하다

==== 오래 걸리는 리팩토링

* 대규모 - 라이브러리 버전업, 컴포넌트 분리, 의존성 제거
* 라이브러리 교체 예시 - Branch By Abstraction
.. 기존, 새거를 모두 포용하는 인터페이스 추가
.. 기존 코드를 위를 호출하도록 변경
** 예전에 등급 코드 고치면서 비슷하기 하긴 한듯

==== 코드 리뷰에 활용

* 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움
** 개선안 제시 -> 즉시 구현
* PR 모델에서는 효과적이지 않다
* 작성자와 나란히 앉아서 리팩토링 - pair programming

==== 리팩토링하지 말아야 할 때

* 굳이 수정할 필요가 없을 때
** 내부 동작을 이해해야 할 시점에 리팩토링
* 처음부터 새로 작성하는게 더 쉬울 때
** 물론 이건 판단력, 경험이 받쳐줘야 함

=== 고려해야할 문제

==== 새 기능 개발에 대한 속도 저하

* 리팩토링의 목적 - 개발 속도 높이기
* 리팩토링으로 인해 진행이 느려진다고 생각하는 사람이 많다
* 준비를 위한 리팩토링을 하면 쉽게 할 수 있다

==== 코드 소유권

* 소유권을 팀에 두고 누구나 팀이 소유한 코드를 수정할 수 있게 한다
** 이건 당연한 얘기로 보이긴 한다

==== 브랜치

===== 보통의 방식

* 기능별 브랜치 -> 완료되면 마스터에 통합
* 단점
** 기간이 길어질 수록 통합이 어려워짐
** 그래서 rebase, merge 를 수시로 하게됨

===== 저자가 정의하는 머지와 통합

* 머지: 마스터 -> 브랜치로 단방향
* 통합: 마스터를 개인 브랜치로 가져와서 작업한 결과를 다시 마스터에 푸시하는 양방향
** 마스터와 브랜치가 모두 변경됨
** 통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에 머지

===== 그래서 어떻게

* Continuous Integration or Trunk-Based Development
** 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다
** 마스터를 건강하게 유지하고, 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 feature toggle 을 적용해야 한다
** 리팩토링과 궁합이 좋다
* CI + Refactoring = Extreme Programming

==== 테스팅

* 리팩토링을 위해서는 자가 테스트 코드 (self-testing code) 를 마련해 한다
* 리팩토링을 할 수 있게 해주고, 새 기능 추가도 훨씬 안전하게 진행할 수 있다
** 실패한다면 무엇이 달라졌는지 알 수 있다 (리팩토링 과정에서 버그의 불안감 해소)
* CI 에 통합된 테스트는 XP 의 권장사항 + CD 의 핵심

==== 레거시 코드

* 테스트 보강이 답이다
* "레거시 코드 활용 전략" 에 나온 지침을 따르는게 좋다
** 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다 -> 이후 리팩토링이 가능
* 서로 관련된 부분끼리 나눠서 하나씩 수행

==== 데이터베이스

* 진화형 데이터베이스 설계 (evolutionary database design), http://www.yes24.com/Product/Goods/2606054[데이터베이스 리팩토링]
** 마이그레이션 스크립트를 작성 -> 접근 코드와 스키마에 변경 처리
* 함수 선언 바꾸기 [6.5]
* 전체 변경 과정을 작고 독립된 단계로 쪼개기
** 프로덕션 환경에 여러 단계로 나눠서 릴리즈

=== 리팩터링, 아키텍처, 애그니 (YAGNI)

* 단순: 향후 변경에 유연하게 대처할 수 있는 flexibility mechanism
** 범용적으로 사용할 수 있는 함수 - 다양한 시나리오에 대응하는 매개변수
** 당장의 쓰임에 비해 함수가 너무 복잡해질 수 있음
*** 근데 이건 클린코드에서는 이렇게 하느니 함수를 쪼개라고 했던 것 같은데..?
* 리팩토링을 활용: 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축
** 근데 이러면 만들고 도망가면 어떻게 되는건가?? 아무리 잘 만들어도 그 뒤에 사람이 리팩토링을 어떻게 할 줄 알고
** 사용자의 요구사항에 맞게 아키텍처도 리팩토링
** 복잡도를 높일 수 있는 유연성 메커니즘은 검증 후 추가
** simple design, incremental design, YAGNI (You aren't going to need it)
* https://martinfowler.com/articles/evodb.html::[evolutionary architecture] - 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 낫다
** 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다 -> 이를 활용하는 패턴과 실천법

=== 리팩토링과 소프트웨어 개발 프로세스

* TDD: 자가 테스트 코드 + 리팩토링
* 자가 테스트 코드: 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다 - 5장
* CI: 각자가 수행한 리팩토링 결과를 빠로게 공유

=== 성능

* 튜닝을 하기 쉽게 만들기 -> 원하는 속도가 나게 튜닝하기
* 아무것도 안 만드는 데도 시간이 걸린다
** 시스템을 잘 알아도 추측하지 말고 성능을 측정해봐야 한다
* 그래서 성능을 신경쓰지 말고 코드를 쉽게 만들어라
* 성능 최적화는 다음 단계로
.. 프로파일러로 분석하여 자원을 많이 잡아먹는 지점을 알아낸다
.. 부분 개선
.. 부분 개선마다 프로파일러 다시 실행
* 잘 리팩토링해두면 성능 튜닝에 투입할 시간을 벌 수 있다, 성능을 더 세밀하게 분석할 수 있다

=== 유래

* 스몰토크: 기능이 풍부한 소프트웨어를 빠르게 작성할 수 있는 역동적인 환경
** 컴파일-링크-실행 주기가 짧아서 마지막 컴파일 시점을 알면 수정을 빠르게 할 수 있음

=== 자동화

* 인텔리제이, 이클립스
* 최초: 리팩토링 브라우저
* 자동 리팩토링을 제대로 구현하려면 syntax tree 로 해석해서 다루어야 한다
* 최근엔 LSP 라는 것도 있다
** syntax tree 를 구성해서 에디터에 API 형태로 제공하는 소프트웨어
** 정교한 코드 분석, 리팩토링 기능 제공

=== 더 알고 싶다면

* 리팩토링 연습 - 리팩토링 워크북
* 패턴을 활용한 리팩토링
* 리팩토링 데이터베이스
* 레커시 코드 활용 전략
*