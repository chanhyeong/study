== 2. 리팩토링 원칙

=== 정의

*소프트웨어의 동작 (observable behavior) 은 유지하고 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 (을 적용해서 재구성하다)*

재구성 (reconstructing): 코드베이스를 정리하거나 구조를 바꾸는 작업 (조금 더 포괄적인 개념)

* 리팩토링 과정에서 발견한 버그는 후에도 그대로 남아 있어야 한다 (???)
* 코드를 이해하고 수정하기 쉽게 만든다
** 성능은 좋아질 수도, 나빠질 수도 있다

=== two hats

* 기능 추가를 할 때는
** 기존 코드는 건드리지 않고 새 기능을 추가만 한다
** 진척도는 테스트 추가 -> 통과로 확인
* 리팩토링을 할때는
** 기능 추가는 절대 안하고 코드 재구성만 한다
** (누락된 케이스를 제외한) 테스트 추가 없다

=== 이유

==== 소프트웨어 설계가 좋아진다

* 코드의 구조를 지탱
* 중복 코드를 제거하면 -> 모든 코드가 언제나 고유한 작업임을 보장
* 리팩토링을 하지 않으면
** 소프트웨어 아키텍처가 썩기 쉽다
** 단기적 목표 달성을 위한 코드 수정 -> 기반 구조가 무너짐 -> 코드로 설계 파악이 어려움 -> 설계 유지 어려움 -> 설계 부패 속도 가속화

==== 소프트웨어를 이해하기 쉬워진다

* 코드를 잘 읽히게 도와준다
** 코드의 목적이 더 잘 드러나게 = 의도를 더 명확하게 전달하도록 개선

==== 버그를 쉽게 찾을 수 있다

* 코드가 하는 일을 파악하면서 새로 깨달은걸 반영

==== 프로그래밍 속도를 높일 수 있다

* 모듈화가 잘 되어 있으면 일부 코드베이스만 이해하면 됨
* 코드가 명확하면 버그를 만들 가능성이 줄고, 디버깅하기가 쉽다
* 한 시스템을 오래 개발
** 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다
** 기능을 추가하면 버그가 자주 발생하고 해결 시간이 오래걸린다
** 패치가 덧대어 지면서 동작 파악이 어려워진다

=== 언제 하는가?

.3의 법칙
----
1. 그냥 한다
2. 비슷한 일을 두 번째 하면, 일단 계속 진행한다
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다
----

==== 준비 (Preparatory) - 기능을 쉽게 추가하게 만들기

* 함수 매개변수화하기 [11.2]
** 중복 코드 제거 - 비슷한 기능인데 함수 다른걸 변수로 받아서 처리하는거로 합치기

==== 이해 (Comprehension) - 코드를 이해하기 쉽게 만들기

* 코드의 의도가 더 명확하게 드러나도록
** 조건부 로직의 구조가 이상하지 않은지, 함수 이름이 잘 정해져 있는지

==== 쓰레기 줍기 (Litter-Pickup)

* 간단히 수정할 수 있는건 바로
* 시간이 걸리면 메모만 남기고 나중에 처리

==== 계획해서 & 수시로

앞선 3가지는 기회가 될 때만

* 따로 리팩토링 시간을 잡지 않고 다른 일을 하는 중에 처리

[quote]
----
보기 싫은 코드를 발견하면 리팩토링. 그런데 잘 작성된 코드 역시 수많은 리팩토링을 거쳐야 한다
----

* 어제와 오늘의 리팩토링 기준이 다를 수 있다 -> 코드가 이미 깔끔하다면 더 쉽다

[quote]
----
무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자
----

* 계획된 리팩토링은 최소한으로 줄이고 수시로 해야한다
* VCS 에서 리팩토링 커밋과 기능 추가 커밋을 분리해야 한다?
** 저자는 완전히 동의하지는 않음 - 왜 그렇게 수정했는지 이해가 어려워짐
** 팀에 적합한 방식을 찾아내야 한다 - 사실 분리하는게 맞는거 같긴 하다

==== 오래 걸리는 리팩토링

* 대규모 - 라이브러리 버전업, 컴포넌트 분리, 의존성 제거
* 라이브러리 교체 예시 - Branch By Abstraction
.. 기존, 새거를 모두 포용하는 인터페이스 추가
.. 기존 코드를 위를 호출하도록 변경
** 예전에 등급 코드 고치면서 비슷하기 하긴 한듯

==== 코드 리뷰에 활용

* 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움
** 개선안 제시 -> 즉시 구현
* PR 모델에서는 효과적이지 않다
* 작성자와 나란히 앉아서 리팩토링 - pair programming

==== 리팩토링하지 말아야 할 때

* 굳이 수정할 필요가 없을 때
** 내부 동작을 이해해야 할 시점에 리팩토링
* 처음부터 새로 작성하는게 더 쉬울 때
** 물론 이건 판단력, 경험이 받쳐줘야 함

=== 고려해야할 문제

==== 새 기능 개발에 대한 속도 저하

* 리팩토링의 목적 - 개발 속도 높이기
* 리팩토링으로 인해 진행이 느려진다고 생각하는 사람이 많다
* 준비를 위한 리팩토링을 하면 쉽게 할 수 있다

==== 코드 소유권

* 소유권을 팀에 두고 누구나 팀이 소유한 코드를 수정할 수 있게 한다
** 이건 당연한 얘기로 보이긴 한다

==== 브랜치

TODO