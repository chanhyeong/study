== 11. API 리팩토링

=== 질의 함수와 변경 함수 분리하기 (Sepreate Query from Modifier)

==== 배경

* observable side effect (겉보기 부수효과) 가 없이 반환하는 함수를 만들어야 한다
* 질의 함수는 모두 side effect 가 없어야 한다
** Command-Query Seperation
* 캐싱도 객체의 상태를 변경하지만 객체 밖에서는 관찰할 수 없다

==== 절차

. 대상 함수 복제, 질의를 위한 네이밍
. 새 질의 함수에서 side effect 제거
. 컴파일
. 원래 함수를 호출 코드를 대체
** 반환 값을 사용?: 질의 함수 호출 -> 원래 함수를 호출하는 코드를 바로 아래 추가
. 원래 함수에서 질의 관련 코드 제거
. 테스트

=== 함수 매개변수화하기 (Parameterize Function)

==== 배경

* 로직이 비슷하고 리터럴 값만 다른 경우

==== 절차

. 비슷한 함수 선택
. 함수 선언 바꾸기로 리터럴을 매개변수로 추가
. 함수 호출하는 곳에 리터럴 값 추가
. 테스트
. 매개변수로 받은 값을 사용하도록 본문 수정
. 비슷한 코드 전부 대체

=== 플래그 인수 제거하기 (Remove Flag Argument)

==== 배경

* flag argument: 함수가 실행할 로직을 선택하기 위해 전달하는 argument
* 호출할 수 있는 함수들이 무엇이고 어떻게 하는지 이해가 어려움

==== 절차

. 매개변수로 주어질 수 있는 값 가각 대응하는 명시적 함수 생성
. 원래 함수를 대체

=== 객체 통째로 넘기기 (Preserve Whole Object)

==== 배경

* 통째로 넘기면 변화에 대응하기 쉽다

==== 절차

. 매개변수들을 원하는 형태로 받는 빈 함수 생성
. 새 함수는 원래 함수를 호출하도록 함. 새 매개변수와 원래 매개변수 매핑
. 컴파일
. 모든 호출자가 새 함수 사용하게 수정
. 새 함수에 원래 함수 인라인
. 새 함수 명칭 수정, 모든 호출자에 반영

=== 매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)

==== 배경

* 매개변수 = 함수의 변동 요인을 모아놓은 곳이므로 중복을 피하고 짧으면 이해하기 좋다

==== 절차

. 필요하다면 매개변수 값 계산 코드를 별도 함수로 추출
. 함수 본문에서 대상 매개변수로 참조를 모두 찾아서 매개변수 값을 만들어주는 표현식을 참조하도록 바꿈
. 함수 선언 바꾸기로 대상 매개변수 제거

=== 질의 함수를 매개변수로 바꾸기 (Replace Query with Parameter)

==== 배경

* 코드의 의존 관계를 바꾸려 할 때
** 대상 함수가 더 이상 특정 원소에 의존하길 원치 않을 때

==== 절차

. 변수 추출하기로 질의 코드를 나머지 코드와 분리
. 함수 본문에서 해당 질의를 호출하지 않는 코드를 별도 함수로 추출
. 방금 생성한 변수를 인라인하여 제거
. 원래 함수도 인라인
. 새 함수 이름을 원래 함수 이름으로 변경

=== 세터 제거하기 (Remove Setting Method)

==== 배경

* 무조건 접근 메소드를 통해서만 필드를 다루려고 할 때 (even in constructor)
* 클라이언트에서 생성 스크립트 (creation script) 를 사용해 객체를 생성할 때
** 생성자 호출 -> 일련의 세터 호출하여 객체 완성하는 코드

==== 절차

. 설정해야 할 값들을 생성자에서 받도록 추가, 생성자에서 세터 호출
. 생성자 밖에서 세터 호출 제거, 새로운 생성자를 사용하도록 변경
. 세터 메소드를 인라인, 필드는 immutable 로 만든다

=== 생성자를 팩토리 함수로 바꾸기 (Replace Construtor with Factory Function)

==== 배경

* 팩토리 함수에는 생성자에 대한 제약이 없고 다른 무언가로 대체할 수 있다 (서브 클래스, 인스턴스 프록시 반환 등)

==== 절차

. factory method 생성
. 생성자 호출을 factory method 로 변경
. 테스트
. 생성자의 공개 범위 제한

=== 함수를 명령으로 바꾸기 (Replace Function with Command)

==== 배경

* 명령: 함수를 함수만을 위한 객체로 캡슐화
** 대부분 메소드 하나로 구성 -> 메소드를 요청하여 실행
* 다만 first-function 이 더 좋다 (명령은 복잡성을 높인다)

==== 절차

. 대상 함수의 기능을 옮길 클래스 생성
. 함수 이동
. 함수의 파라미터들을 명령 필드로 만들어 생성자를 통해 설정할지 고려

=== 명령을 함수로 바꾸기 (Replace Command with Function)

==== 배경

* 명령이 공짜가 아니므로 로직이 크게 복잡하지 않다면 평범한 함수로 바꿔주는게 낫다

==== 절차

. 명령 생성 & 실행 메소드 호출 코드 -> 함수로 추출
. 실행 함수로 호출하는 보조 메소드들 인라인
. 함수 선언 바꾸기로 생성자의 매개변수 전부 실행 메소드로 옮김
. 실행 메소드에서 참조하는 필드 대신 매개 변수 사용하게 변경
. 생성자와 명령 실행 메소드 호출을 호출자 안으로 인라인
. 테스트
. 명령 클래스 제거

=== 수정된 값 반환하기 (Return Modified Value)

==== 절차

. 함수가 수정된 값을 반환하게 하여, 호출자가 자신의 변수에 값을 저장하게 함
. 반환할 값을 가리키는 새로운 변수 선언
. 계산이 선언과 동시에 이뤄지도록 통합
. 변수명을 잘 네이밍

=== 오류 코드를 예외로 바꾸기 (Replace Error Code with Exception)

==== 배경

* 예외: 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘
** 정확히 예상 밖의 동작일 때만 쓰여야 함

==== 절차

. callstack 상위에 예외 핸들러 작성
. 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법 찾기
. 컴파일
. catch 절을 수정하여 직접 처리할 수 있는 건 대처, 아닌건 다시 던짐
. 오류 코드 반환 -> 모두 예외로 변경
. 오류 코드를 callsatck 위로 전달하는 코드 전부 제거

=== 예외를 사전확인으로 바꾸기 (Replace Exception with Precheck)

==== 절차

. 예외 상황을 검사하는 조건문 추가, catch 코드를 조건절
. catch 쪽에 assertion 추가하고 테스트
. try, catch 제거