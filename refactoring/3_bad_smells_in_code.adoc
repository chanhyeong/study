== 3. 코드에서 나는 악취

=== 기이한 이름 (Mysterious Name)

* 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야 한다
* 함수 선언 바꾸기 [6.5], 변수 이름 바꾸기 [6.7], 필드 이름 바꾸기 [9.2]
* 마땅한 이름이 떠오르지 않는다면 설계에 근본적인 문제가 숨어 있다

=== 중복 코드 (Duplicated Code)

* 코드가 중복되면 차이점이 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다
* 힘수 추출하기 [6.1], 문장 슬라이드하기 [6.6], 메소드 올리기 [12.1]

=== 긴 함수 (Long Function)

* 좋은 이름을 지어 짧은 함수로 코드를 구성
* 주석을 달아야 할 만한 부분은 무조건 함수로 만든다 (!)
** 본문: 주석으로 설명하려던 코드
** 이름: 동작 방식이 아닌 의도
* 엄청나게 많은 리팩토링 기법.. (116p)

=== 긴 매개변수 목록 (Long Parameter List)

* 목록이 길어지면 이해하기 어려울 때가 많다
* 매개변수를 질의 함수로 바꾸기 [11.5], 객체를 통째로 넘기기 [11.4], 매개변수 객체 만들기 [6.8], 플래그 인수 제거하기 [11.3], 여러 함수를 클래스로 묶기 [6.9]
* 지금 팀의 자체 기준: 5개가 넘어가면 객체로 만들자
** Params: 서비스 단
** Criteria: 저장소 단

=== 전역 데이터 (Global Data)

* 어디에서든 건들 수 있고 누가 바꿨는지 찾아낼 메커니즘이 없다
* 변수 캡슐화 하기 [6.6]

=== 가변 데이터 (Mutable Data)

* 데이터 변경 시 예상치 못한 결과 or 버그로 이어지는 경우가 있음
* 함수형에서는 변하지 않고 복사본을 만들어서 반환한다는 개념
* 이거도 많은 리팩토링 기법.. (119p)

=== 뒤엉킨 변경 (Divergent Change)

* 변경하기 어려운 소프트웨어 구조가 된 형태 중 하나 (뒤엉킨 변경 or 산탄총 수술)
* SRP (Single Responsiblity Principle) 이 제대로 지켜지지 않을 때 나타남
** 하나의 묘듈이 다양한 이유로 여러 가지 방식으로 변경되는 일이 많을 때
** ex) DB 추가마다 3개 함수, 금융 상품 추가마다 4개 함수 변경
*** DB 연동과 금융 상품은 독립된 모듈로 분리해야 프로그래밍이 편하다
*** (???) 그러면 모듈이 나뉘어 있어도 개별 모듈에서 함수 3개, 4개가 수정되어야 하는거 아닌가?
*** 모듈을 작게 보면 패키지로 봐도 되는거 같다 (개인 생각)
* 단계 쪼개기 [6.11], 함수 옮기기 [8.1], 함수 추출하기 [6.1], 클래스 추출하기 [7.5]

=== 산탄총 수술 (Shotgun Surgery)

* 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때
* 이거는 약간 DDD 에서 로직을 클래스로 두는 것과 비슷한 것 같다 (개인 생각)
* 목록 (121p)]

=== 기능 편애 (Feature Envy)

* 함수가 자신의 모듈 보다 다른 모듈과 상효작용을 더 많이 할 때
* 함수 옮기기 [8.1], 함수 추출하기 [6.1]

=== 데이터 뭉치 (Data Clumps)

* 데이터 항목 서너 개가 함께 뭉쳐 다니는 경우
** 클래스 두어 개의 필드, 여러 메서드의 시그니처
* 클래스 추출하기 [7.5], 매개변수 객체 만들기 [6.8], 객체 통째로 넘기기 [11.4]
* 지식iN 기준으로는 dirId, docId 가 그렇게 될듯
* 기능 편애나 여기나 클래스를 만들었다면 동작도 옮길만한게 있는지 찾아보자

=== 기본형 집착 (Primitive Obsession)

* 주어진 문제에 딱 맞는 기초 타입을 직접 정의하기
* 기본형을 객체로 바꾸기 [7.3], 타입 코드를 서브클래스로 바꾸기 [12.6], 조건부 로직을 다형성으로 바꾸기 [10.4], 클래스 추출하기, 매개변수 객체 만들기

=== 반복되는 switch 문 (Repeated Switches)

* switch 를 무조건적으로 나쁘다고 보기 보다는
* 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중
** 여기 있던 switch 조건이 저기도 있어서 같이 수정해야 하는 경우

=== 반복문 (Loops)

* 반복문을 파이프라인으로 바꾸기 [8.8]

=== 성의 없는 요소 (Lazy Element)

* element: fuction, class, interface 등 코드 구조를 잡는 데 활용되는 요소
* 이런 코드 구조가 필요 없을 때도 있음
** 본문 코드를 그대로 쓰는 것과 다름 없음 or 메소드가 하나 뿐인 클래스
* 함수 인라인하기, 클래스 인라인하기, 계층 합치기

=== 추측성 일반화 (Speculative Generality)

* 나중을 위한 당장 필요없는 모든 hooking 포인트와 특이 케이스 처리 로직들
** 이해하거나 관리하기 어려워진 코드
* 계층 합치기, 함수 인라인하기, 클래스 인라인하기, 함수 선언 바꾸기, 죽은 코드 제거하기

=== 임시 필드 (Temporary Field)

* 특정 상황에서만 값이 설정되는 필드
** 쓰이지 않는 필드가 존재하는 이유를 파악하는 어려움
* 클래스 추출하기, 함수 옮기기, 특이 케이스 추가하기

=== 메시지 체인 (Message Changes)

* 클라이언트가 객체 -> 객체 -> .. 호출하는 구조
** getter 가 꼬리를 물고 이어지는 경우 등
* 위임 숨기기, 함수 추출하기, 함수 옮기기

=== 중개자 (Middle man)

* 외부로부터 세부 사항을 숨겨주는 캡술화, 그 과정에서는 위임
** 다른 사람에게 일정 요청 시, 다른 사람이 일정을 어디서 보든 상관 없이 일정을 보고 알려줌
* 클래스가 제공하는 메소드 절반이 다른 클래스에 구현을 위임하고 있다면?
** 실제로 일을 하는 객체와 직접 소통
* 중개자 제거하기

=== 내부자 거래 (Insider Trading)

* 모듈 사이의 데이터 거래 양을 최소로 줄이고 투명하게 처리
* 이건 뭐하는건지 잘 이해가 안간다 (개인 의견)
* 함수 옮기기, 필드 옮기기, 위임 숨기기, 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기

=== 거대한 클래스 (Large Class)

* 한 클래스가 너무 많은 일을 하면 필드 수가 늘어남 + 중복 코드가 생기기 쉬움
* 클래스 추출하기, 슈퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기

=== 서로 다른 인터페이스의 대안 클래스 (Alternative Classes with Different Interfaces)

* 클래스 장점: 언제 든 다른 클래스로 교체할 수 있다
* 함수 선언 바꾸기, 함수 옮기기, 슈퍼클래스 추출하기
* 이거는 코드 중복 제거하는건가? 뭐가 문제인지가 안나옴

=== 데이터 클래스 (Data Class)

* getter/setter 로만 구성된 클래스
* 레코드 캡슐화 하기, 세터 제거하기, 함수 옮기기, 함수 추출하기, 단계 쪼개기

=== 상속 포기 (Refused Bequest)

* 서브 클래스가 부모의 것을 필요로 하지 않는다면?
* 예전 방식
** 같은 계층에 서브클래스를 새로 만들고 메소드 내리기, 필드 내리기
*** 상속하지 않을 코드를 새로 만든 서브클래스로 넘김
*** 가끔 Spring 코드 까보면 부모꺼 상속해서 NotSupported 달린 것들이 보이던데 이거인 듯
* 권하지 않는다
** 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기

=== 주석 (Comments)

* 주석이 장황하게 달렸다 -> 코드를 잘못 작성했다
* 함수 추출하기, 함수 선언 바구기, 어서션 추가하기
