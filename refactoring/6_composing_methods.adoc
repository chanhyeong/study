== 6. 기본적인 리팩토링

원어판은 함수 구성 (Composing Method) 로 제목이 있음

=== https://refactoring.com/catalog/extractFunction.html[함수 추출하기 (Extract Function)]

반대: 함수 인라인하기

==== 배경

* 코드가 무슨 일을 하는지 파악 -> 독립된 함수로 추출, 목적에 맞는 이름 부여
* 기준 - 길이?, 재사용성?
** 목적과 구현으르 분리
*** 코드를 보고 무슨 일을 하는지 바로 파악할 수 있게
* 짧은 함수는 이름을 잘 지어야만 이점
** 코드 덩어리에 해당하는 주석을 이름 짓기에 참고

==== 절차

. 함수를 새로 만들고 목적을 잘 드러내는 이름 짓기 (어떻게 X, 무엇을 O)
** 이름이 떠오르지 않는다면 추출하면 안된다
** 처음부터 최선의 이름일 필요는 없이 다시 인라인 시켜버려도 됨
. 추출할 코드를 새 함수에 붙여 넣음
. 코드에서 원본 지역 변수 / 유효범위를 벗어나는 변수는 매개변수로 전달
** 값이 바뀌는건 리턴 값으로 대입
** 변수가 너무 많으면 변수 쪼개기[9.1] or 임시 변수를 질의 함수로 바꾸기[7.4]
. 컴파일
. 원본 함수의 코드 블럭을 새로 만든 함수로 대체
. 테스트
. 다른 코드에 비슷한거 찾음. 있다면 변경 검토

==== 예시

* 164p `recordDueDate` 는 immtuable 한게 아니어서 별로인 듯
** 이런게 추가로 리팩토링할 요소가 있다고 하는거인 듯

=== 함수 인라인하기 (Inline Function)

반대: 함수 추출하기

==== 배경

* 함수 본문이 이름만큼 명확한 경우

==== 절차

. 다형 메소드 (polymorphic method) 인지 확인
** override 하는건 안됨
. 함수를 호출하는 곳을 모두 찾음
. 각 호출문을 함수 본문으로 교체
. 교체 시마다 테스트
. 정의 삭제
* 복잡하면 인라인하면 안된다 (재귀, 반환문 여러 개, ...)

=== 변수 추출하기 (Extract Variable)

반대: 변수 인라인하기

==== 배경

* 표현식이 너무 복잡해서 이해하기 어려울 때
* 디버깅에도 도움
* 변수 이름
** 함수 내에서만 의미가 있음: 표현식의 이름
** 넓은 문맥: 함수로 추출해야 함


==== 절차

. 추출하려는 표현식에 부작용이 없는지 확인
. immutable 변수를 선언, 표현식의 복제본 대입
. 원본 표현식 대체
. 테스트
. 2~5 반복 교체 -> 교체마다 테스트

=== 변수 인라인하기 (Inline Variable)

반대: 변수 추출하기

==== 배경

* 원래 표현식과 다를 바 없을 때

==== 절차

. 부작용 확인
. immutable 로 선언되지 않은 경우 immutable 로 바꿔서 테스트
** java 같은데서는 어떻게 하지?
. 변경
. 테스트
. 변수 사용 부분 교체까지 반복
. 선언문, 대입문 제거
. 테스트

=== 함수 선언 바꾸기 (Change Function Declaration)

함수명과 매개변수까지 적절하게 변경하자

==== 배경

* 이름이 잘못된 함수를 발견하면 즉시 변경
** 쉬운 동작 파악을 위해
* 매개변수도 잘못된걸 넘기고 있으면 변경
** ex) 전화번호 포매팅 함수가 사람을 받음
* 정답은 없다

==== 절차

===== 간단한 절차

. 함수 본문에서 제거 대상 매개변수 참조 확인
. 메소드 선언을 원하는 형태로 바꿈
. 기존 메소드 선언을 전부 대체
. 테스트

===== 마이그레이션 절차

. 함수 본문을 적절히 리팩토링
. 함수 본문을 새로운 함수로 추출 [6.1]
. 추출한 함수에 매개변수를 추가한다면 간단한 절차로 추가
. 테스트
. 기존 함수에 새 함수를 인라인
. 임시로 네이밍했다면 변경
. 테스트

=== 변수 캡슐화하기 (Encapsulate Variable)

==== 배경

* 함수는 호출 방식이므로, 이름을 바꾸거나 다른 모듈로 옮기기 어렵지 않음
** 기존 함수를 그대로 두고 새로 만든 함수로 대체할 수도 있음
* 데이터는 다루기 까다로움 - 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동
** 데이터로 접근을 독점하는 함수를 만드는 식으로 캡슐화하는게 좋다

==== 절차

. 변수로의 접근과 갱신을 전담하는 캡슐화 함수 생성
. 정적 검사 수행
. 직접 참조 -> 캡슐화 함수 호출. 변경 시 마다 테스트
. 변수 접근 범위 제한 (public -> private)
. 테스트
. 레코드면 레코드 캡슐화하기[7.1] 적용 검토

=== 변수 이름 바꾸기 (Rename Variable)

==== 배경

* 설명을 잘 해주는 이름으로 짓자
* 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드면 더 신경써야 한다
** 무슨 뜻이지? - 계속 쓰이는 값이면 더 신경써서 네이밍해야한다는 것인 듯

==== 절차

. 폭 넓게 쓰이는 변수 - 변수 캡슐화하기 고려
. 변경 대상 변수 찾음, 하나씩 변경
. 테스트

=== 매개변수 객체 만들기 (Introduce Parameter Object)

==== 배경

* 데이터 뭉치를 데이터 구조로 묶으면
** 명확해진다
** 매개변수 수가 줄어든다
** 똑같은 이름을 사용하여 일관성도 높여준다
** 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성할 수 있다

==== 절차

요약 - 기존 메소드에 새 클래스를 추가하고, 다 바꾸고, 기존 매개변수를 제거해라

. 적당한 데이터 구조를 만든다
** 클래스, Value Object
** 근데 VO 에 동작까지 함께 묶는다는게 맞나?
*** 간단한 between, include, contains 이런 정도만 들어가는 듯
. 테스트
. 함수 선언 바꾸기[6.5]로 새 데이터 구조를 매개변수로 추가
. 테스트
. 호출 시 새 데이터 구조 인스턴스를 넘기게 함, 테스트
. 기존 매개변수 사용 코드를 새 데이터 구조의 원소를 사용하도록 바꿈
. 다 바꾸면 기존 매개변수 제거하고 테스트

=== 여러 함수를 클래스로 묶기 (Combine Functions into Class)

==== 배경

* 클래스 = 데이터 + 함수를 외부에 제공
* 공통 데이터를 중심으로 엮여서 작동하는 함수 무리를 발견했을 때
* 함수 재구성 & 놓친 연산을 찾아 새 클래스의 메소드로 만들기도 좋음

==== 절차

. 함수들이 공유하는 공통 데이터 레코드를 캡슐화[7.1]
. 1의 레코드를 사용하는 함수를 새 클래스로 옮김
. 데이터를 조작하는 로직들을 함수로 추출하여 새 클래스로 옮김

=== 여러 함수를 변환 함수로 묶기 (Combine Functions into Transform)

==== 배경

* 여러 곳에서 반복되는 로직을 하나로 모음
* 변환 함수: 데이터 입력받아서 정보 도출 -> 출력 데이터의 필드에 넣어 반환

==== 절차

. 레코드를 받아서 deep copy 하여 그대로 반환하는 변환 함수 만듦
. 함수 중 하나를 골라 본문 코드를 변환 함수로 옮김, 처리 결과를 새 필드로 기록 -> 클라이언트가 새 필드 사용하도록 수정
. 테스트
. 반복
